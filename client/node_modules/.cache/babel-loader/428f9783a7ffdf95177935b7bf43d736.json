{"ast":null,"code":"\"use strict\";\n\nvar esprima = require(\"esprima\");\n\nvar uniq = require(\"uniq\");\n\nvar PREFIX_COUNTER = 0;\n\nfunction CompiledArgument(name, lvalue, rvalue) {\n  this.name = name;\n  this.lvalue = lvalue;\n  this.rvalue = rvalue;\n  this.count = 0;\n}\n\nfunction CompiledRoutine(body, args, thisVars, localVars) {\n  this.body = body;\n  this.args = args;\n  this.thisVars = thisVars;\n  this.localVars = localVars;\n}\n\nfunction isGlobal(identifier) {\n  if (identifier === \"eval\") {\n    throw new Error(\"cwise-parser: eval() not allowed\");\n  }\n\n  if (typeof window !== \"undefined\") {\n    return identifier in window;\n  } else if (typeof global !== \"undefined\") {\n    return identifier in global;\n  } else if (typeof self !== \"undefined\") {\n    return identifier in self;\n  } else {\n    return false;\n  }\n}\n\nfunction getArgNames(ast) {\n  var params = ast.body[0].expression.callee.params;\n  var names = new Array(params.length);\n\n  for (var i = 0; i < params.length; ++i) {\n    names[i] = params[i].name;\n  }\n\n  return names;\n}\n\nfunction preprocess(func) {\n  var src = [\"(\", func, \")()\"].join(\"\");\n  var ast = esprima.parse(src, {\n    range: true\n  }); //Compute new prefix\n\n  var prefix = \"_inline_\" + PREFIX_COUNTER++ + \"_\"; //Parse out arguments\n\n  var argNames = getArgNames(ast);\n  var compiledArgs = new Array(argNames.length);\n\n  for (var i = 0; i < argNames.length; ++i) {\n    compiledArgs[i] = new CompiledArgument([prefix, \"arg\", i, \"_\"].join(\"\"), false, false);\n  } //Create temporary data structure for source rewriting\n\n\n  var exploded = new Array(src.length);\n\n  for (var i = 0, n = src.length; i < n; ++i) {\n    exploded[i] = src.charAt(i);\n  } //Local variables\n\n\n  var localVars = [];\n  var thisVars = [];\n  var computedThis = false; //Retrieves a local variable\n\n  function createLocal(id) {\n    var nstr = prefix + id.replace(/\\_/g, \"__\");\n    localVars.push(nstr);\n    return nstr;\n  } //Creates a this variable\n\n\n  function createThisVar(id) {\n    var nstr = \"this_\" + id.replace(/\\_/g, \"__\");\n    thisVars.push(nstr);\n    return nstr;\n  } //Rewrites an ast node\n\n\n  function rewrite(node, nstr) {\n    var lo = node.range[0],\n        hi = node.range[1];\n\n    for (var i = lo + 1; i < hi; ++i) {\n      exploded[i] = \"\";\n    }\n\n    exploded[lo] = nstr;\n  } //Remove any underscores\n\n\n  function escapeString(str) {\n    return \"'\" + str.replace(/\\_/g, \"\\\\_\").replace(/\\'/g, \"\\'\") + \"'\";\n  } //Returns the source of an identifier\n\n\n  function source(node) {\n    return exploded.slice(node.range[0], node.range[1]).join(\"\");\n  } //Computes the usage of a node\n\n\n  var LVALUE = 1;\n  var RVALUE = 2;\n\n  function getUsage(node) {\n    if (node.parent.type === \"AssignmentExpression\") {\n      if (node.parent.left === node) {\n        if (node.parent.operator === \"=\") {\n          return LVALUE;\n        }\n\n        return LVALUE | RVALUE;\n      }\n    }\n\n    if (node.parent.type === \"UpdateExpression\") {\n      return LVALUE | RVALUE;\n    }\n\n    return RVALUE;\n  } //Handle visiting a node\n\n\n  (function visit(node, parent) {\n    node.parent = parent;\n\n    if (node.type === \"MemberExpression\") {\n      //Handle member expression\n      if (node.computed) {\n        visit(node.object, node);\n        visit(node.property, node);\n      } else if (node.object.type === \"ThisExpression\") {\n        rewrite(node, createThisVar(node.property.name));\n      } else {\n        visit(node.object, node);\n      }\n    } else if (node.type === \"ThisExpression\") {\n      throw new Error(\"cwise-parser: Computed this is not allowed\");\n    } else if (node.type === \"Identifier\") {\n      //Handle identifier\n      var name = node.name;\n      var argNo = argNames.indexOf(name);\n\n      if (argNo >= 0) {\n        var carg = compiledArgs[argNo];\n        var usage = getUsage(node);\n\n        if (usage & LVALUE) {\n          carg.lvalue = true;\n        }\n\n        if (usage & RVALUE) {\n          carg.rvalue = true;\n        }\n\n        ++carg.count;\n        rewrite(node, carg.name);\n      } else if (isGlobal(name)) {//Don't rewrite globals\n      } else {\n        rewrite(node, createLocal(name));\n      }\n    } else if (node.type === \"Literal\") {\n      if (typeof node.value === \"string\") {\n        rewrite(node, escapeString(node.value));\n      }\n    } else if (node.type === \"WithStatement\") {\n      throw new Error(\"cwise-parser: with() statements not allowed\");\n    } else {\n      //Visit all children\n      var keys = Object.keys(node);\n\n      for (var i = 0, n = keys.length; i < n; ++i) {\n        if (keys[i] === \"parent\") {\n          continue;\n        }\n\n        var value = node[keys[i]];\n\n        if (value) {\n          if (value instanceof Array) {\n            for (var j = 0; j < value.length; ++j) {\n              if (value[j] && typeof value[j].type === \"string\") {\n                visit(value[j], node);\n              }\n            }\n          } else if (typeof value.type === \"string\") {\n            visit(value, node);\n          }\n        }\n      }\n    }\n  })(ast.body[0].expression.callee.body, undefined); //Remove duplicate variables\n\n\n  uniq(localVars);\n  uniq(thisVars); //Return body\n\n  var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars);\n  return routine;\n}\n\nmodule.exports = preprocess;","map":null,"metadata":{},"sourceType":"script"}