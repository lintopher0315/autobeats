{"ast":null,"code":"\"use strict\";\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\n\nvar utf8 = exports;\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\n\nutf8.length = function utf8_length(string) {\n  var len = 0,\n      c = 0;\n\n  for (var i = 0; i < string.length; ++i) {\n    c = string.charCodeAt(i);\n    if (c < 128) len += 1;else if (c < 2048) len += 2;else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i;\n      len += 4;\n    } else len += 3;\n  }\n\n  return len;\n};\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\n\n\nutf8.read = function utf8_read(buffer, start, end) {\n  var len = end - start;\n  if (len < 1) return \"\";\n  var parts = null,\n      chunk = [],\n      i = 0,\n      // char offset\n  t; // temporary\n\n  while (start < end) {\n    t = buffer[start++];\n    if (t < 128) chunk[i++] = t;else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n      chunk[i++] = 0xD800 + (t >> 10);\n      chunk[i++] = 0xDC00 + (t & 1023);\n    } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n      i = 0;\n    }\n  }\n\n  if (parts) {\n    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\n\n\nutf8.write = function utf8_write(string, buffer, offset) {\n  var start = offset,\n      c1,\n      // character 1\n  c2; // character 2\n\n  for (var i = 0; i < string.length; ++i) {\n    c1 = string.charCodeAt(i);\n\n    if (c1 < 128) {\n      buffer[offset++] = c1;\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192;\n      buffer[offset++] = c1 & 63 | 128;\n    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n      ++i;\n      buffer[offset++] = c1 >> 18 | 240;\n      buffer[offset++] = c1 >> 12 & 63 | 128;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    } else {\n      buffer[offset++] = c1 >> 12 | 224;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    }\n  }\n\n  return offset - start;\n};","map":null,"metadata":{},"sourceType":"script"}