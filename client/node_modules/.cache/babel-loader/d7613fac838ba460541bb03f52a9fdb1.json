{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs-core\");\n\nvar __1 = require(\"..\");\n\nvar coconet_utils_1 = require(\"./coconet_utils\");\n\nvar DEFAULT_SPEC = {\n  useSoftmaxLoss: true,\n  batchNormVarianceEpsilon: 1.0e-07,\n  numInstruments: 4,\n  numFilters: 128,\n  numLayers: 33,\n  numRegularConvLayers: 0,\n  dilation: [[1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32], [1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32], [1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32], [1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32], [1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32]],\n  layers: null,\n  interleaveSplitEveryNLayers: 16,\n  numPointwiseSplits: 4\n};\n\nvar ConvNet = function () {\n  function ConvNet(spec, vars) {\n    this.residualPeriod = 2;\n    this.outputForResidual = null;\n    this.residualCounter = -1;\n    this.rawVars = null;\n    this.spec = spec;\n    this.rawVars = vars;\n  }\n\n  ConvNet.prototype.dispose = function () {\n    if (this.rawVars !== null) {\n      tf.dispose(this.rawVars);\n    }\n\n    if (this.outputForResidual) {\n      this.outputForResidual.dispose();\n    }\n  };\n\n  ConvNet.prototype.predictFromPianoroll = function (pianoroll, masks) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      var featuremaps = _this.getConvnetInput(pianoroll, masks);\n\n      var n = _this.spec.layers.length;\n\n      for (var i = 0; i < n; i++) {\n        _this.residualCounter += 1;\n\n        _this.residualSave(featuremaps);\n\n        var numPointwiseSplits = null;\n\n        if (_this.spec.interleaveSplitEveryNLayers && i > 0 && i < n - 2 && i % (_this.spec.interleaveSplitEveryNLayers + 1) === 0) {\n          numPointwiseSplits = _this.spec.numPointwiseSplits;\n        }\n\n        featuremaps = _this.applyConvolution(featuremaps, _this.spec.layers[i], i, i >= _this.spec.numRegularConvLayers, numPointwiseSplits);\n        featuremaps = _this.applyResidual(featuremaps, i === 0, i === n - 1, i);\n        featuremaps = _this.applyActivation(featuremaps, _this.spec.layers[i], i);\n        featuremaps = _this.applyPooling(featuremaps, _this.spec.layers[i], i);\n      }\n\n      return _this.computePredictions(featuremaps);\n    });\n  };\n\n  ConvNet.prototype.computePredictions = function (logits) {\n    if (this.spec.useSoftmaxLoss) {\n      return logits.transpose([0, 1, 3, 2]).softmax().transpose([0, 1, 3, 2]);\n    }\n\n    return logits.sigmoid();\n  };\n\n  ConvNet.prototype.residualReset = function () {\n    this.outputForResidual = null;\n    this.residualCounter = 0;\n  };\n\n  ConvNet.prototype.residualSave = function (x) {\n    if (this.residualCounter % this.residualPeriod === 1) {\n      this.outputForResidual = x;\n    }\n  };\n\n  ConvNet.prototype.applyResidual = function (x, isFirst, isLast, i) {\n    if (this.outputForResidual == null) {\n      return x;\n    }\n\n    if (this.outputForResidual.shape[this.outputForResidual.shape.length - 1] !== x.shape[x.shape.length - 1]) {\n      this.residualReset();\n      return x;\n    }\n\n    if (this.residualCounter % this.residualPeriod === 0) {\n      if (!isFirst && !isLast) {\n        x = x.add(this.outputForResidual);\n      }\n    }\n\n    return x;\n  };\n\n  ConvNet.prototype.getVar = function (name, layerNum) {\n    var varname = \"model/conv\" + layerNum + \"/\" + name;\n    return this.rawVars[varname];\n  };\n\n  ConvNet.prototype.getSepConvVar = function (name, layerNum) {\n    var varname = \"model/conv\" + layerNum + \"/SeparableConv2d/\" + name;\n    return this.rawVars[varname];\n  };\n\n  ConvNet.prototype.getPointwiseSplitVar = function (name, layerNum, splitNum) {\n    var varname = \"model/conv\" + layerNum + \"/split_\" + layerNum + \"_\" + splitNum + \"/\" + name;\n    return this.rawVars[varname];\n  };\n\n  ConvNet.prototype.applyConvolution = function (x, layer, i, depthwise, numPointwiseSplits) {\n    if (layer.filters == null) {\n      return x;\n    }\n\n    var filterShape = layer.filters;\n    var stride = layer.convStride || 1;\n    var padding = layer.convPad ? layer.convPad.toLowerCase() : 'same';\n    var conv = null;\n\n    if (depthwise) {\n      var dWeights = this.getSepConvVar('depthwise_weights', i);\n\n      if (!numPointwiseSplits) {\n        var pWeights = this.getSepConvVar('pointwise_weights', i);\n        var biases = this.getSepConvVar('biases', i);\n        var sepConv = tf.separableConv2d(x, dWeights, pWeights, [stride, stride], padding, layer.dilation, 'NHWC');\n        conv = sepConv.add(biases);\n      } else {\n        conv = tf.depthwiseConv2d(x, dWeights, [stride, stride], padding, 'NHWC', layer.dilation);\n        var splits = tf.split(conv, numPointwiseSplits, conv.rank - 1);\n        var pointwiseSplits = [];\n\n        for (var splitIdx = 0; splitIdx < numPointwiseSplits; splitIdx++) {\n          var outputShape = filterShape[3] / numPointwiseSplits;\n          var weights = this.getPointwiseSplitVar('kernel', i, splitIdx);\n          var biases = this.getPointwiseSplitVar('bias', i, splitIdx);\n          var dot = tf.matMul(splits[splitIdx].reshape([-1, outputShape]), weights, false, false);\n          var bias = tf.add(dot, biases);\n          pointwiseSplits.push(bias.reshape([splits[splitIdx].shape[0], splits[splitIdx].shape[1], splits[splitIdx].shape[2], outputShape]));\n        }\n\n        conv = tf.concat(pointwiseSplits, conv.rank - 1);\n      }\n    } else {\n      var weights = this.getVar('weights', i);\n      var stride_1 = layer.convStride || 1;\n      var padding_1 = layer.convPad ? layer.convPad.toLowerCase() : 'same';\n      conv = tf.conv2d(x, weights, [stride_1, stride_1], padding_1, 'NHWC', [1, 1]);\n    }\n\n    return this.applyBatchnorm(conv, i);\n  };\n\n  ConvNet.prototype.applyBatchnorm = function (x, i) {\n    var _this = this;\n\n    var gammas = this.getVar('gamma', i);\n    var betas = this.getVar('beta', i);\n    var mean = this.getVar('popmean', i);\n    var variance = this.getVar('popvariance', i);\n\n    if (coconet_utils_1.IS_IOS) {\n      var v = variance.arraySync()[0][0][0];\n      var stdevs = tf.tensor(v.map(function (x) {\n        return Math.sqrt(x + _this.spec.batchNormVarianceEpsilon);\n      }));\n      return x.sub(mean).mul(gammas.div(stdevs)).add(betas);\n    }\n\n    return tf.batchNorm(x, tf.squeeze(mean), tf.squeeze(variance), tf.squeeze(betas), tf.squeeze(gammas), this.spec.batchNormVarianceEpsilon);\n  };\n\n  ConvNet.prototype.applyActivation = function (x, layer, i) {\n    if (layer.activation === 'identity') {\n      return x;\n    }\n\n    return x.relu();\n  };\n\n  ConvNet.prototype.applyPooling = function (x, layer, i) {\n    if (layer.pooling == null) {\n      return x;\n    }\n\n    var pooling = layer.pooling;\n    var padding = layer.poolPad ? layer.poolPad.toLowerCase() : 'same';\n    return tf.maxPool(x, [pooling[0], pooling[1]], [pooling[0], pooling[1]], padding);\n  };\n\n  ConvNet.prototype.getConvnetInput = function (pianoroll, masks) {\n    pianoroll = tf.scalar(1, 'float32').sub(masks).mul(pianoroll);\n    masks = tf.scalar(1, 'float32').sub(masks);\n    return pianoroll.concat(masks, 3);\n  };\n\n  return ConvNet;\n}();\n\nvar Coconet = function () {\n  function Coconet(checkpointURL) {\n    this.spec = null;\n    this.initialized = false;\n    this.checkpointURL = checkpointURL;\n    this.spec = DEFAULT_SPEC;\n  }\n\n  Coconet.prototype.initialize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var startTime, vars;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.dispose();\n            startTime = performance.now();\n            this.instantiateFromSpec();\n            return [4, fetch(this.checkpointURL + \"/weights_manifest.json\").then(function (response) {\n              return response.json();\n            }).then(function (manifest) {\n              return tf.io.loadWeights(manifest, _this.checkpointURL);\n            })];\n\n          case 1:\n            vars = _a.sent();\n            this.convnet = new ConvNet(this.spec, vars);\n            this.initialized = true;\n\n            __1.logging.logWithDuration('Initialized model', startTime, 'Coconet');\n\n            return [2];\n        }\n      });\n    });\n  };\n\n  Coconet.prototype.dispose = function () {\n    if (this.convnet) {\n      this.convnet.dispose();\n    }\n\n    this.initialized = false;\n  };\n\n  Coconet.prototype.isInitialized = function () {\n    return this.initialized;\n  };\n\n  Coconet.prototype.instantiateFromSpec = function () {\n    var nonFinalLayerFilterOuterSizes = 3;\n    var finalTwoLayersFilterOuterSizes = 2;\n    this.spec.layers = [];\n    this.spec.layers.push({\n      filters: [nonFinalLayerFilterOuterSizes, nonFinalLayerFilterOuterSizes, this.spec.numInstruments * 2, this.spec.numFilters]\n    });\n\n    for (var i = 0; i < this.spec.numLayers - 3; i++) {\n      this.spec.layers.push({\n        filters: [nonFinalLayerFilterOuterSizes, nonFinalLayerFilterOuterSizes, this.spec.numFilters, this.spec.numFilters],\n        dilation: this.spec.dilation ? this.spec.dilation[i] : null\n      });\n    }\n\n    this.spec.layers.push({\n      filters: [finalTwoLayersFilterOuterSizes, finalTwoLayersFilterOuterSizes, this.spec.numFilters, this.spec.numFilters]\n    });\n    this.spec.layers.push({\n      filters: [finalTwoLayersFilterOuterSizes, finalTwoLayersFilterOuterSizes, this.spec.numFilters, this.spec.numInstruments],\n      activation: 'identity'\n    });\n  };\n\n  Coconet.prototype.infill = function (sequence, config) {\n    return __awaiter(this, void 0, void 0, function () {\n      var numSteps, pianoroll, temperature, numIterations, outerMasks, samples, outputSequence;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            __1.sequences.assertIsRelativeQuantizedSequence(sequence);\n\n            if (sequence.notes.length === 0) {\n              throw new Error(\"NoteSequence \" + sequence.id + \" does not have any notes to infill.\");\n            }\n\n            numSteps = sequence.totalQuantizedSteps || sequence.notes[sequence.notes.length - 1].quantizedEndStep;\n            pianoroll = coconet_utils_1.sequenceToPianoroll(sequence, numSteps);\n            temperature = 0.99;\n            numIterations = 96;\n\n            if (config) {\n              numIterations = config.numIterations || numIterations;\n              temperature = config.temperature || temperature;\n              outerMasks = this.getCompletionMaskFromInput(config.infillMask, pianoroll);\n            } else {\n              outerMasks = this.getCompletionMask(pianoroll);\n            }\n\n            return [4, this.run(pianoroll, numIterations, temperature, outerMasks)];\n\n          case 1:\n            samples = _a.sent();\n            outputSequence = coconet_utils_1.pianorollToSequence(samples, numSteps);\n            pianoroll.dispose();\n            samples.dispose();\n            outerMasks.dispose();\n            return [2, outputSequence];\n        }\n      });\n    });\n  };\n\n  Coconet.prototype.run = function (pianorolls, numSteps, temperature, outerMasks) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2, this.gibbs(pianorolls, numSteps, temperature, outerMasks)];\n      });\n    });\n  };\n\n  Coconet.prototype.getCompletionMaskFromInput = function (masks, pianorolls) {\n    if (!masks) {\n      return this.getCompletionMask(pianorolls);\n    } else {\n      var buffer_1 = tf.buffer([pianorolls.shape[1], 4]);\n\n      for (var i = 0; i < masks.length; i++) {\n        buffer_1.set(1, masks[i].step, masks[i].voice);\n      }\n\n      return tf.tidy(function () {\n        return buffer_1.toTensor().expandDims(1).tile([1, coconet_utils_1.NUM_PITCHES, 1]).expandDims(0);\n      });\n    }\n  };\n\n  Coconet.prototype.getCompletionMask = function (pianorolls) {\n    return tf.tidy(function () {\n      var isEmpty = pianorolls.sum(2, true).equal(tf.scalar(0, 'float32'));\n      return tf.cast(isEmpty, 'float32').add(tf.zerosLike(pianorolls));\n    });\n  };\n\n  Coconet.prototype.gibbs = function (pianorolls, numSteps, temperature, outerMasks) {\n    return __awaiter(this, void 0, void 0, function () {\n      var numStepsTensor, pianoroll, _loop_1, this_1, s;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            numStepsTensor = tf.scalar(numSteps, 'float32');\n            pianoroll = pianorolls.clone();\n\n            _loop_1 = function _loop_1(s) {\n              var pm, innerMasks, predictions;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    pm = this_1.yaoSchedule(s, numStepsTensor);\n                    innerMasks = this_1.bernoulliMask(pianoroll.shape, pm, outerMasks);\n                    return [4, tf.nextFrame()];\n\n                  case 1:\n                    _a.sent();\n\n                    predictions = tf.tidy(function () {\n                      return _this.convnet.predictFromPianoroll(pianoroll, innerMasks);\n                    });\n                    return [4, tf.nextFrame()];\n\n                  case 2:\n                    _a.sent();\n\n                    pianoroll = tf.tidy(function () {\n                      var samples = _this.samplePredictions(predictions, temperature);\n\n                      var updatedPianorolls = tf.where(tf.cast(innerMasks, 'bool'), samples, pianoroll);\n                      pianoroll.dispose();\n                      predictions.dispose();\n                      innerMasks.dispose();\n                      pm.dispose();\n                      return updatedPianorolls;\n                    });\n                    return [4, tf.nextFrame()];\n\n                  case 3:\n                    _a.sent();\n\n                    return [2];\n                }\n              });\n            };\n\n            this_1 = this;\n            s = 0;\n            _a.label = 1;\n\n          case 1:\n            if (!(s < numSteps)) return [3, 4];\n            return [5, _loop_1(s)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            s++;\n            return [3, 1];\n\n          case 4:\n            numStepsTensor.dispose();\n            return [2, pianoroll];\n        }\n      });\n    });\n  };\n\n  Coconet.prototype.yaoSchedule = function (i, n) {\n    return tf.tidy(function () {\n      var pmin = tf.scalar(0.1, 'float32');\n      var pmax = tf.scalar(0.9, 'float32');\n      var alpha = tf.scalar(0.7, 'float32');\n      var wat = pmax.sub(pmin).mul(tf.scalar(i, 'float32')).div(n);\n      var secondArg = pmax.sub(wat).div(alpha);\n      return pmin.reshape([1]).concat(secondArg.reshape([1])).max();\n    });\n  };\n\n  Coconet.prototype.bernoulliMask = function (shape, pm, outerMasks) {\n    return tf.tidy(function () {\n      var bb = shape[0],\n          tt = shape[1],\n          pp = shape[2],\n          ii = shape[3];\n      var probs = tf.tile(tf.randomUniform([bb, tt, 1, ii], 0, 1, 'float32'), [1, 1, pp, 1]);\n      var masks = probs.less(pm);\n      return tf.cast(masks, 'float32').mul(outerMasks);\n    });\n  };\n\n  Coconet.prototype.samplePredictions = function (predictions, temperature) {\n    return tf.tidy(function () {\n      predictions = tf.pow(predictions, tf.scalar(1 / temperature, 'float32'));\n      var cmf = tf.cumsum(predictions, 2, false, false);\n      var totalMasses = cmf.slice([0, 0, cmf.shape[2] - 1, 0], [cmf.shape[0], cmf.shape[1], 1, cmf.shape[3]]);\n      var u = tf.randomUniform(totalMasses.shape, 0, 1, 'float32');\n      var i = u.mul(totalMasses).less(cmf).argMax(2);\n      return tf.oneHot(i.flatten(), predictions.shape[2], 1, 0).reshape([predictions.shape[0], predictions.shape[1], predictions.shape[3], predictions.shape[2]]).transpose([0, 1, 3, 2]);\n    });\n  };\n\n  return Coconet;\n}();\n\nexports.Coconet = Coconet;","map":null,"metadata":{},"sourceType":"script"}