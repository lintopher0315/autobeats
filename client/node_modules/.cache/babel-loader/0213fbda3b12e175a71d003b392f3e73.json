{"ast":null,"code":"import { Midi } from './Midi';\nexport { instrumentByPatchID, instrumentFamilyByID, drumKitByPatchID } from './instrumentMaps';\n/**\n *  Parse all the data from the Midi file into this format:\n *  {\n *  \t// the transport and timing data\n *  \theader : {\n *  \t\tbpm : Number,                     // tempo, e.g. 120\n *  \t\ttimeSignature : [Number, Number], // time signature, e.g. [4, 4],\n *  \t\tPPQ : Number                  // PPQ of the midi file\n *  \t}\n *  \t// an array for each of the midi tracks\n *  \ttracks : [\n *  \t\t{\n *  \t\t\tname : String, // the track name if one was given\n *  \t\t\tnotes : [\n *  \t\t\t\t{\n *  \t\t\t\t\ttime : Number, // time in seconds\n *  \t\t\t\t\tname : String, // note name, e.g. 'C4'\n *  \t\t\t\t\tmidi : Number, // midi number, e.g. 60\n *  \t\t\t\t\tvelocity : Number,  // normalized velocity\n *  \t\t\t\t\tduration : Number   // duration between noteOn and noteOff\n *  \t\t\t\t}\n *  \t\t\t],\n *  \t\t\tcontrolChanges : { //all of the control changes\n *  \t\t\t\t64 : [ //array for each cc value\n *  \t\t\t\t\t{\n *  \t\t\t\t\t\tnumber : Number, //the cc number\n *  \t\t\t\t\t\ttime : Number, //the time of the event in seconds\n *  \t\t\t\t\t\tname : String, // if the cc value has a common name (e.g. 'sustain')\n *  \t\t\t\t\t\tvalue : Number, //the normalized value\n *  \t\t\t\t\t}\n *  \t\t\t\t]\n *  \t\t\t}\n *  \t\t}\n *  \t]\n *  }\n *  @param  {Binary String}  fileBlob  The output from fs.readFile or FileReader\n *  @returns {Object} All of the options parsed from the midi file.\n */\n\nexport function parse(fileBlob) {\n  return new Midi().decode(fileBlob);\n}\n/**\n *  Load and parse a midi file. See `parse` for what the results look like.\n *  @param  {String}    url\n *  @param {Function=} callback\n *  @returns {Promise} A promise which is invoked with the returned Midi object\n */\n\nexport function load(url, callback) {\n  var promise = new Midi().load(url);\n\n  if (callback) {\n    promise.then(callback);\n  }\n\n  return promise;\n}\n/**\n * Create an empty midi file\n * @return {Midi}\n */\n\nexport function create() {\n  return new Midi();\n}\n/**\n * Create midi object from json\n * @param {object} json\n * @returns {Midi} Deserialized midi object\n */\n\nexport function fromJSON(json) {\n  return Midi.fromJSON(json);\n}","map":null,"metadata":{},"sourceType":"module"}