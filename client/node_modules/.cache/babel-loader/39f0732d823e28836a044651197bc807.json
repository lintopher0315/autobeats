{"ast":null,"code":"// https://github.com/gasman/jasmid\n//\n//\nmodule.exports = function (file) {\n  return MidiFile(file);\n};\n\nfunction MidiFile(data) {\n  function readChunk(stream) {\n    var id = stream.read(4);\n    var length = stream.readInt32();\n    return {\n      'id': id,\n      'length': length,\n      'data': stream.read(length)\n    };\n  }\n\n  var lastEventTypeByte;\n\n  function readEvent(stream) {\n    var event = {};\n    event.deltaTime = stream.readVarInt();\n    var eventTypeByte = stream.readInt8();\n\n    if ((eventTypeByte & 0xf0) == 0xf0) {\n      /* system / meta event */\n      if (eventTypeByte == 0xff) {\n        /* meta event */\n        event.type = 'meta';\n        var subtypeByte = stream.readInt8();\n        var length = stream.readVarInt();\n\n        switch (subtypeByte) {\n          case 0x00:\n            event.subtype = 'sequenceNumber';\n            if (length != 2) throw \"Expected length for sequenceNumber event is 2, got \" + length;\n            event.number = stream.readInt16();\n            return event;\n\n          case 0x01:\n            event.subtype = 'text';\n            event.text = stream.read(length);\n            return event;\n\n          case 0x02:\n            event.subtype = 'copyrightNotice';\n            event.text = stream.read(length);\n            return event;\n\n          case 0x03:\n            event.subtype = 'trackName';\n            event.text = stream.read(length);\n            return event;\n\n          case 0x04:\n            event.subtype = 'instrumentName';\n            event.text = stream.read(length);\n            return event;\n\n          case 0x05:\n            event.subtype = 'lyrics';\n            event.text = stream.read(length);\n            return event;\n\n          case 0x06:\n            event.subtype = 'marker';\n            event.text = stream.read(length);\n            return event;\n\n          case 0x07:\n            event.subtype = 'cuePoint';\n            event.text = stream.read(length);\n            return event;\n\n          case 0x20:\n            event.subtype = 'midiChannelPrefix';\n            if (length != 1) throw \"Expected length for midiChannelPrefix event is 1, got \" + length;\n            event.channel = stream.readInt8();\n            return event;\n\n          case 0x2f:\n            event.subtype = 'endOfTrack';\n            if (length != 0) throw \"Expected length for endOfTrack event is 0, got \" + length;\n            return event;\n\n          case 0x51:\n            event.subtype = 'setTempo';\n            if (length != 3) throw \"Expected length for setTempo event is 3, got \" + length;\n            event.microsecondsPerBeat = (stream.readInt8() << 16) + (stream.readInt8() << 8) + stream.readInt8();\n            return event;\n\n          case 0x54:\n            event.subtype = 'smpteOffset';\n            if (length != 5) throw \"Expected length for smpteOffset event is 5, got \" + length;\n            var hourByte = stream.readInt8();\n            event.frameRate = {\n              0x00: 24,\n              0x20: 25,\n              0x40: 29,\n              0x60: 30\n            }[hourByte & 0x60];\n            event.hour = hourByte & 0x1f;\n            event.min = stream.readInt8();\n            event.sec = stream.readInt8();\n            event.frame = stream.readInt8();\n            event.subframe = stream.readInt8();\n            return event;\n\n          case 0x58:\n            event.subtype = 'timeSignature';\n            if (length != 4) throw \"Expected length for timeSignature event is 4, got \" + length;\n            event.numerator = stream.readInt8();\n            event.denominator = Math.pow(2, stream.readInt8());\n            event.metronome = stream.readInt8();\n            event.thirtyseconds = stream.readInt8();\n            return event;\n\n          case 0x59:\n            event.subtype = 'keySignature';\n            if (length != 2) throw \"Expected length for keySignature event is 2, got \" + length;\n            event.key = stream.readInt8(true);\n            event.scale = stream.readInt8();\n            return event;\n\n          case 0x7f:\n            event.subtype = 'sequencerSpecific';\n            event.data = stream.read(length);\n            return event;\n\n          default:\n            // console.log(\"Unrecognised meta event subtype: \" + subtypeByte);\n            event.subtype = 'unknown';\n            event.data = stream.read(length);\n            return event;\n        }\n\n        event.data = stream.read(length);\n        return event;\n      } else if (eventTypeByte == 0xf0) {\n        event.type = 'sysEx';\n        var length = stream.readVarInt();\n        event.data = stream.read(length);\n        return event;\n      } else if (eventTypeByte == 0xf7) {\n        event.type = 'dividedSysEx';\n        var length = stream.readVarInt();\n        event.data = stream.read(length);\n        return event;\n      } else {\n        throw \"Unrecognised MIDI event type byte: \" + eventTypeByte;\n      }\n    } else {\n      /* channel event */\n      var param1;\n\n      if ((eventTypeByte & 0x80) == 0) {\n        /* running status - reuse lastEventTypeByte as the event type.\n        \teventTypeByte is actually the first parameter\n        */\n        param1 = eventTypeByte;\n        eventTypeByte = lastEventTypeByte;\n      } else {\n        param1 = stream.readInt8();\n        lastEventTypeByte = eventTypeByte;\n      }\n\n      var eventType = eventTypeByte >> 4;\n      event.channel = eventTypeByte & 0x0f;\n      event.type = 'channel';\n\n      switch (eventType) {\n        case 0x08:\n          event.subtype = 'noteOff';\n          event.noteNumber = param1;\n          event.velocity = stream.readInt8();\n          return event;\n\n        case 0x09:\n          event.noteNumber = param1;\n          event.velocity = stream.readInt8();\n\n          if (event.velocity == 0) {\n            event.subtype = 'noteOff';\n          } else {\n            event.subtype = 'noteOn';\n          }\n\n          return event;\n\n        case 0x0a:\n          event.subtype = 'noteAftertouch';\n          event.noteNumber = param1;\n          event.amount = stream.readInt8();\n          return event;\n\n        case 0x0b:\n          event.subtype = 'controller';\n          event.controllerType = param1;\n          event.value = stream.readInt8();\n          return event;\n\n        case 0x0c:\n          event.subtype = 'programChange';\n          event.programNumber = param1;\n          return event;\n\n        case 0x0d:\n          event.subtype = 'channelAftertouch';\n          event.amount = param1;\n          return event;\n\n        case 0x0e:\n          event.subtype = 'pitchBend';\n          event.value = param1 + (stream.readInt8() << 7);\n          return event;\n\n        default:\n          throw \"Unrecognised MIDI event type: \" + eventType;\n\n        /* \n        console.log(\"Unrecognised MIDI event type: \" + eventType);\n        stream.readInt8();\n        event.subtype = 'unknown';\n        return event;\n        */\n      }\n    }\n  }\n\n  stream = Stream(data);\n  var headerChunk = readChunk(stream);\n\n  if (headerChunk.id != 'MThd' || headerChunk.length != 6) {\n    throw \"Bad .mid file - header not found\";\n  }\n\n  var headerStream = Stream(headerChunk.data);\n  var formatType = headerStream.readInt16();\n  var trackCount = headerStream.readInt16();\n  var timeDivision = headerStream.readInt16();\n\n  if (timeDivision & 0x8000) {\n    throw \"Expressing time division in SMTPE frames is not supported yet\";\n  } else {\n    ticksPerBeat = timeDivision;\n  }\n\n  var header = {\n    'formatType': formatType,\n    'trackCount': trackCount,\n    'ticksPerBeat': ticksPerBeat\n  };\n  var tracks = [];\n\n  for (var i = 0; i < header.trackCount; i++) {\n    tracks[i] = [];\n    var trackChunk = readChunk(stream);\n\n    if (trackChunk.id != 'MTrk') {\n      throw \"Unexpected chunk - expected MTrk, got \" + trackChunk.id;\n    }\n\n    var trackStream = Stream(trackChunk.data);\n\n    while (!trackStream.eof()) {\n      var event = readEvent(trackStream);\n      tracks[i].push(event); //console.log(event);\n    }\n  }\n\n  return {\n    'header': header,\n    'tracks': tracks\n  };\n}\n\n;\n/* Wrapper for accessing strings through sequential reads */\n\nfunction Stream(str) {\n  var position = 0;\n\n  function read(length) {\n    var result = str.substr(position, length);\n    position += length;\n    return result;\n  }\n  /* read a big-endian 32-bit integer */\n\n\n  function readInt32() {\n    var result = (str.charCodeAt(position) << 24) + (str.charCodeAt(position + 1) << 16) + (str.charCodeAt(position + 2) << 8) + str.charCodeAt(position + 3);\n    position += 4;\n    return result;\n  }\n  /* read a big-endian 16-bit integer */\n\n\n  function readInt16() {\n    var result = (str.charCodeAt(position) << 8) + str.charCodeAt(position + 1);\n    position += 2;\n    return result;\n  }\n  /* read an 8-bit integer */\n\n\n  function readInt8(signed) {\n    var result = str.charCodeAt(position);\n    if (signed && result > 127) result -= 256;\n    position += 1;\n    return result;\n  }\n\n  function eof() {\n    return position >= str.length;\n  }\n  /* read a MIDI-style variable-length integer\n  \t(big-endian value in groups of 7 bits,\n  \twith top bit set to signify that another byte follows)\n  */\n\n\n  function readVarInt() {\n    var result = 0;\n\n    while (true) {\n      var b = readInt8();\n\n      if (b & 0x80) {\n        result += b & 0x7f;\n        result <<= 7;\n      } else {\n        /* b is the last byte */\n        return result + b;\n      }\n    }\n  }\n\n  return {\n    'eof': eof,\n    'read': read,\n    'readInt32': readInt32,\n    'readInt16': readInt16,\n    'readInt8': readInt8,\n    'readVarInt': readVarInt\n  };\n}","map":null,"metadata":{},"sourceType":"script"}