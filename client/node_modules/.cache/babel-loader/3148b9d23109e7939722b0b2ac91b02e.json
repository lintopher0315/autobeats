{"ast":null,"code":"\"use strict\";\n\nvar ndarray = require(\"ndarray\");\n\nvar ops = require(\"ndarray-ops\");\n\nvar pool = require(\"typedarray-pool\");\n\nfunction clone(array) {\n  var dtype = array.dtype;\n\n  if (dtype === \"generic\" || dtype === \"array\") {\n    dtype = \"double\";\n  }\n\n  var data = pool.malloc(array.size, dtype);\n  var result = ndarray(data, array.shape);\n  ops.assign(result, array);\n  return result;\n}\n\nexports.clone = clone;\n\nfunction malloc(shape, dtype) {\n  if (!dtype) {\n    dtype = \"double\";\n  }\n\n  var sz = 1;\n  var stride = new Array(shape.length);\n\n  for (var i = shape.length - 1; i >= 0; --i) {\n    stride[i] = sz;\n    sz *= shape[i];\n  }\n\n  return ndarray(pool.malloc(sz, dtype), shape, stride, 0);\n}\n\nexports.malloc = malloc;\n\nfunction free(array) {\n  if (array.dtype === \"generic\" || array.dtype === \"array\") {\n    return;\n  }\n\n  pool.free(array.data);\n}\n\nexports.free = free;\n\nfunction zeros(shape, dtype) {\n  if (!dtype) {\n    dtype = \"double\";\n  }\n\n  var sz = 1;\n  var stride = new Array(shape.length);\n\n  for (var i = shape.length - 1; i >= 0; --i) {\n    stride[i] = sz;\n    sz *= shape[i];\n  }\n\n  var buf = pool.malloc(sz, dtype);\n\n  for (var i = 0; i < sz; ++i) {\n    buf[i] = 0;\n  }\n\n  return ndarray(buf, shape, stride, 0);\n}\n\nexports.zeros = zeros;\n\nfunction ones(shape, dtype) {\n  if (!dtype) {\n    dtype = \"double\";\n  }\n\n  var sz = 1;\n  var stride = new Array(shape.length);\n\n  for (var i = shape.length - 1; i >= 0; --i) {\n    stride[i] = sz;\n    sz *= shape[i];\n  }\n\n  var buf = pool.malloc(sz, dtype);\n\n  for (var i = 0; i < sz; ++i) {\n    buf[i] = 1;\n  }\n\n  return ndarray(buf, shape, stride, 0);\n}\n\nexports.ones = ones;\n\nfunction eye(shape, dtype) {\n  var i, offset;\n\n  if (!dtype) {\n    dtype = \"double\";\n  }\n\n  var sz = 1;\n  var stride = new Array(shape.length);\n\n  for (i = shape.length - 1; i >= 0; --i) {\n    stride[i] = sz;\n    sz *= shape[i];\n  }\n\n  var buf = pool.malloc(sz, dtype);\n\n  for (i = 0; i < sz; ++i) {\n    buf[i] = 0;\n  }\n\n  var mindim = Infinity;\n  var offsum = 0;\n\n  for (i = shape.length - 1; i >= 0; i--) {\n    offsum += stride[i];\n    mindim = Math.min(mindim, shape[i]);\n  }\n\n  for (i = 0, offset = 0; i < mindim; i++, offset += offsum) {\n    buf[offset] = 1;\n  }\n\n  return ndarray(buf, shape, stride, 0);\n}\n\nexports.eye = eye;","map":null,"metadata":{},"sourceType":"script"}