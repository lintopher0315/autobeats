{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs\");\n\nvar FFT = require(\"fft.js\");\n\nvar audio_utils_1 = require(\"../core/audio_utils\");\n\nvar constants_1 = require(\"./constants\");\n\nvar mel_sparse_coeffs_1 = require(\"./mel_sparse_coeffs\");\n\nfunction melToLinearMatrix() {\n  var m2l = tf.buffer([1024, 1024]);\n\n  for (var i = 0; i < mel_sparse_coeffs_1.MEL_SPARSE_COEFFS.length; i++) {\n    var x = mel_sparse_coeffs_1.MEL_SPARSE_COEFFS[i];\n    m2l.set(x[2], x[0], x[1]);\n  }\n\n  return m2l.toTensor();\n}\n\nexports.melToLinearMatrix = melToLinearMatrix;\n\nfunction descale(data, a, b) {\n  return tf.div(tf.sub(data, b), a);\n}\n\nfunction melToLinear(melLogPower) {\n  return tf.tidy(function () {\n    var m2l = melToLinearMatrix().expandDims(0);\n    var melLogPowerDb = descale(melLogPower, constants_1.MAG_DESCALE_A, constants_1.MAG_DESCALE_B);\n    var melPower = tf.exp(melLogPowerDb);\n    var powerLin = tf.matMul(melPower, m2l);\n    var magLin = tf.sqrt(powerLin);\n    return magLin;\n  });\n}\n\nexports.melToLinear = melToLinear;\n\nfunction ifreqToPhase(ifreq) {\n  return tf.tidy(function () {\n    var m2l = melToLinearMatrix().expandDims(0);\n    var ifreqDescale = descale(ifreq, constants_1.PHASE_DESCALE_A, constants_1.PHASE_DESCALE_B);\n    var phase = tf.cumsum(tf.mul(ifreqDescale, Math.PI), 1);\n    var phaseLin = tf.matMul(phase, m2l);\n    return phaseLin;\n  });\n}\n\nexports.ifreqToPhase = ifreqToPhase;\n\nfunction interleaveReIm(real, imag) {\n  var reImInterleave = tf.tidy(function () {\n    var reImBatch = tf.concat([real, imag], 0).expandDims(3);\n    reImBatch = tf.pad(reImBatch, [[0, 0], [0, 0], [1, 0], [0, 0]]);\n    var crops = [[0, 0], [0, 0]];\n    var reImInterleave = tf.batchToSpaceND(reImBatch, [1, 2], crops).reshape([128, 4096]);\n    return reImInterleave;\n  });\n  var reImArray = reImInterleave.dataSync();\n  var reIm = [];\n\n  for (var i = 0; i < 128; i++) {\n    reIm[i] = reImArray.slice(i * 4096, (i + 1) * 4096);\n  }\n\n  return reIm;\n}\n\nfunction reImToAudio(reIm) {\n  return __awaiter(this, void 0, void 0, function () {\n    var ispecParams;\n    return __generator(this, function (_a) {\n      ispecParams = {\n        nFFt: constants_1.N_FFT,\n        winLength: constants_1.N_FFT,\n        hopLength: constants_1.N_HOP,\n        sampleRate: constants_1.SAMPLE_RATE,\n        center: false\n      };\n      return [2, istft(reIm, ispecParams)];\n    });\n  });\n}\n\nfunction specgramsToAudio(specgrams) {\n  return __awaiter(this, void 0, void 0, function () {\n    var reImArray, reIm, audio;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          reImArray = tf.tidy(function () {\n            var magSlice = tf.slice(specgrams, [0, 0, 0, 0], [1, -1, -1, 1]).reshape([1, 128, 1024]);\n            var magMel = magSlice;\n            var mag = melToLinear(magMel);\n            var ifreqSlice = tf.slice(specgrams, [0, 0, 0, 1], [1, -1, -1, 1]).reshape([1, 128, 1024]);\n            var ifreq = ifreqSlice;\n            var phase = ifreqToPhase(ifreq);\n            var real = mag.mul(tf.cos(phase));\n            var mirrorReal = tf.reverse(real.slice([0, 0, 0], [1, 128, 1023]), 2);\n            real = tf.concat([real, mirrorReal], 2);\n            var imag = mag.mul(tf.sin(phase));\n            var mirrorImag = tf.reverse(imag.slice([0, 0, 0], [1, 128, 1023]), 2);\n            imag = tf.concat([imag, tf.mul(mirrorImag, -1.0)], 2);\n            return [real, imag];\n          });\n          return [4, interleaveReIm(reImArray[0], reImArray[1])];\n\n        case 1:\n          reIm = _a.sent();\n          return [4, reImToAudio(reIm)];\n\n        case 2:\n          audio = _a.sent();\n          return [2, audio];\n      }\n    });\n  });\n}\n\nexports.specgramsToAudio = specgramsToAudio;\n\nfunction ifft(reIm) {\n  var nFFT = reIm.length / 2;\n  var fft = new FFT(nFFT);\n  var recon = fft.createComplexArray();\n  fft.inverseTransform(recon, reIm);\n  var result = fft.fromComplexArray(recon);\n  return result;\n}\n\nexports.ifft = ifft;\n\nfunction istft(reIm, params) {\n  var nFrames = reIm.length;\n  var nReIm = reIm[0].length;\n  var nFft = nReIm / 2;\n  var winLength = params.winLength || nFft;\n  var hopLength = params.hopLength || Math.floor(winLength / 4);\n  var center = params.center || false;\n  var ifftWindow = audio_utils_1.hannWindow(winLength);\n\n  for (var i = 0; i < ifftWindow.length; i++) {\n    ifftWindow[i] = ifftWindow[i] / 1.5;\n  }\n\n  ifftWindow = audio_utils_1.padCenterToLength(ifftWindow, nFft);\n  var expectedSignalLen = nFft + hopLength * (nFrames - 1);\n  var y = new Float32Array(expectedSignalLen);\n\n  for (var i = 0; i < nFrames; i++) {\n    var sample = i * hopLength;\n    var yTmp = ifft(reIm[i]);\n    yTmp = audio_utils_1.applyWindow(yTmp, ifftWindow);\n    yTmp = add(yTmp, y.slice(sample, sample + nFft));\n    y.set(yTmp, sample);\n  }\n\n  var sliceStart = 0;\n  var sliceLength = expectedSignalLen;\n\n  if (center) {\n    sliceStart = nFft / 2;\n    sliceLength = y.length - nFft / 2;\n  } else {\n    sliceStart = expectedSignalLen - constants_1.SAMPLE_LENGTH;\n    sliceLength = y.length - sliceStart;\n  }\n\n  var yTrimmed = y.slice(sliceStart, sliceLength);\n  return yTrimmed;\n}\n\nexports.istft = istft;\n\nfunction add(arr0, arr1) {\n  if (arr0.length !== arr1.length) {\n    console.error(\"Array lengths must be equal to add: \" + arr0.length + \", \" + arr0.length);\n    return null;\n  }\n\n  var out = new Float32Array(arr0.length);\n\n  for (var i = 0; i < arr0.length; i++) {\n    out[i] = arr0[i] + arr1[i];\n  }\n\n  return out;\n}","map":null,"metadata":{},"sourceType":"script"}