{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs\");\n\nvar index_1 = require(\"../protobuf/index\");\n\nvar constants = require(\"./constants\");\n\nvar performance = require(\"./performance\");\n\nvar sequences = require(\"./sequences\");\n\nexports.DEFAULT_DRUM_PITCH_CLASSES = [[36, 35], [38, 27, 28, 31, 32, 33, 34, 37, 39, 40, 56, 65, 66, 75, 85], [42, 44, 54, 68, 69, 70, 71, 73, 78, 80], [46, 67, 72, 74, 79, 81], [45, 29, 41, 61, 64, 84], [48, 47, 60, 63, 77, 86, 87], [50, 30, 43, 62, 76, 83], [49, 55, 57, 58], [51, 52, 53, 59, 82]];\n\nfunction converterFromSpec(spec) {\n  switch (spec.type) {\n    case 'MelodyConverter':\n      return new MelodyConverter(spec.args);\n\n    case 'DrumsConverter':\n      return new DrumsConverter(spec.args);\n\n    case 'DrumRollConverter':\n      return new DrumRollConverter(spec.args);\n\n    case 'TrioConverter':\n      return new TrioConverter(spec.args);\n\n    case 'DrumsOneHotConverter':\n      return new DrumsOneHotConverter(spec.args);\n\n    case 'MultitrackConverter':\n      return new MultitrackConverter(spec.args);\n\n    case 'GrooveConverter':\n      return new GrooveConverter(spec.args);\n\n    default:\n      throw new Error(\"Unknown DataConverter type: \" + spec);\n  }\n}\n\nexports.converterFromSpec = converterFromSpec;\n\nvar DataConverter = function () {\n  function DataConverter(args) {\n    this.NUM_SPLITS = 0;\n    this.SEGMENTED_BY_TRACK = false;\n    this.numSteps = args.numSteps;\n    this.numSegments = args.numSegments;\n  }\n\n  DataConverter.prototype.tensorSteps = function (tensor) {\n    return tf.scalar(tensor.shape[0], 'int32');\n  };\n\n  return DataConverter;\n}();\n\nexports.DataConverter = DataConverter;\n\nvar DrumsConverter = function (_super) {\n  __extends(DrumsConverter, _super);\n\n  function DrumsConverter(args) {\n    var _this = _super.call(this, args) || this;\n\n    _this.pitchClasses = args.pitchClasses || exports.DEFAULT_DRUM_PITCH_CLASSES;\n    _this.pitchToClass = new Map();\n\n    var _loop_1 = function _loop_1(c) {\n      this_1.pitchClasses[c].forEach(function (p) {\n        _this.pitchToClass.set(p, c);\n      });\n    };\n\n    var this_1 = this;\n\n    for (var c = 0; c < _this.pitchClasses.length; ++c) {\n      _loop_1(c);\n    }\n\n    _this.depth = _this.pitchClasses.length;\n    return _this;\n  }\n\n  DrumsConverter.prototype.toTensor = function (noteSequence) {\n    var _this = this;\n\n    sequences.assertIsQuantizedSequence(noteSequence);\n    var numSteps = this.numSteps || noteSequence.totalQuantizedSteps;\n    var drumRoll = tf.buffer([numSteps, this.pitchClasses.length + 1], 'int32');\n\n    for (var i = 0; i < numSteps; ++i) {\n      drumRoll.set(1, i, -1);\n    }\n\n    noteSequence.notes.forEach(function (note) {\n      drumRoll.set(1, note.quantizedStartStep, _this.pitchToClass.get(note.pitch));\n      drumRoll.set(0, note.quantizedStartStep, -1);\n    });\n    return drumRoll.toTensor();\n  };\n\n  DrumsConverter.prototype.toNoteSequence = function (oh, stepsPerQuarter, qpm) {\n    return __awaiter(this, void 0, void 0, function () {\n      var noteSequence, labelsTensor, labels, s, p;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);\n            labelsTensor = oh.argMax(1);\n            return [4, labelsTensor.data()];\n\n          case 1:\n            labels = _a.sent();\n            labelsTensor.dispose();\n\n            for (s = 0; s < labels.length; ++s) {\n              for (p = 0; p < this.pitchClasses.length; p++) {\n                if (labels[s] >> p & 1) {\n                  noteSequence.notes.push(index_1.NoteSequence.Note.create({\n                    pitch: this.pitchClasses[p][0],\n                    quantizedStartStep: s,\n                    quantizedEndStep: s + 1,\n                    isDrum: true\n                  }));\n                }\n              }\n            }\n\n            noteSequence.totalQuantizedSteps = labels.length;\n            return [2, noteSequence];\n        }\n      });\n    });\n  };\n\n  return DrumsConverter;\n}(DataConverter);\n\nexports.DrumsConverter = DrumsConverter;\n\nvar DrumRollConverter = function (_super) {\n  __extends(DrumRollConverter, _super);\n\n  function DrumRollConverter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DrumRollConverter.prototype.toNoteSequence = function (roll, stepsPerQuarter, qpm) {\n    return __awaiter(this, void 0, void 0, function () {\n      var noteSequence, flatRoll, s, pitches, p;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);\n            return [4, roll.data()];\n\n          case 1:\n            flatRoll = _a.sent();\n\n            for (s = 0; s < roll.shape[0]; ++s) {\n              pitches = flatRoll.slice(s * this.depth, (s + 1) * this.depth);\n\n              for (p = 0; p < pitches.length; ++p) {\n                if (pitches[p]) {\n                  noteSequence.notes.push(index_1.NoteSequence.Note.create({\n                    pitch: this.pitchClasses[p][0],\n                    quantizedStartStep: s,\n                    quantizedEndStep: s + 1,\n                    isDrum: true\n                  }));\n                }\n              }\n            }\n\n            noteSequence.totalQuantizedSteps = roll.shape[0];\n            return [2, noteSequence];\n        }\n      });\n    });\n  };\n\n  return DrumRollConverter;\n}(DrumsConverter);\n\nexports.DrumRollConverter = DrumRollConverter;\n\nvar DrumsOneHotConverter = function (_super) {\n  __extends(DrumsOneHotConverter, _super);\n\n  function DrumsOneHotConverter(args) {\n    var _this = _super.call(this, args) || this;\n\n    _this.depth = Math.pow(2, _this.pitchClasses.length);\n    return _this;\n  }\n\n  DrumsOneHotConverter.prototype.toTensor = function (noteSequence) {\n    var _this = this;\n\n    sequences.assertIsRelativeQuantizedSequence(noteSequence);\n    var numSteps = this.numSteps || noteSequence.totalQuantizedSteps;\n    var labels = Array(numSteps).fill(0);\n\n    for (var _i = 0, _a = noteSequence.notes; _i < _a.length; _i++) {\n      var _b = _a[_i],\n          pitch = _b.pitch,\n          quantizedStartStep = _b.quantizedStartStep;\n      labels[quantizedStartStep] += Math.pow(2, this.pitchToClass.get(pitch));\n    }\n\n    return tf.tidy(function () {\n      return tf.oneHot(tf.tensor1d(labels, 'int32'), _this.depth);\n    });\n  };\n\n  return DrumsOneHotConverter;\n}(DrumsConverter);\n\nexports.DrumsOneHotConverter = DrumsOneHotConverter;\n\nvar MelodyConverter = function (_super) {\n  __extends(MelodyConverter, _super);\n\n  function MelodyConverter(args) {\n    var _this = _super.call(this, args) || this;\n\n    _this.NOTE_OFF = 1;\n    _this.FIRST_PITCH = 2;\n    _this.minPitch = args.minPitch;\n    _this.maxPitch = args.maxPitch;\n    _this.ignorePolyphony = args.ignorePolyphony === undefined ? true : args.ignorePolyphony;\n    _this.depth = args.maxPitch - args.minPitch + 1 + _this.FIRST_PITCH;\n    return _this;\n  }\n\n  MelodyConverter.prototype.toTensor = function (noteSequence) {\n    var _this = this;\n\n    sequences.assertIsQuantizedSequence(noteSequence);\n    var numSteps = this.numSteps || noteSequence.totalQuantizedSteps;\n    var sortedNotes = noteSequence.notes.sort(function (n1, n2) {\n      if (n1.quantizedStartStep === n2.quantizedStartStep) {\n        return n2.pitch - n1.pitch;\n      }\n\n      return n1.quantizedStartStep - n2.quantizedStartStep;\n    });\n    var mel = tf.buffer([numSteps], 'int32');\n    var lastStart = -1;\n    sortedNotes.forEach(function (n) {\n      if (n.quantizedStartStep === lastStart) {\n        if (!_this.ignorePolyphony) {\n          throw new Error('`NoteSequence` is not monophonic.');\n        } else {\n          return;\n        }\n      }\n\n      if (n.pitch < _this.minPitch || n.pitch > _this.maxPitch) {\n        throw Error('`NoteSequence` has a pitch outside of the valid range: ' + (\"\" + n.pitch));\n      }\n\n      mel.set(n.pitch - _this.minPitch + _this.FIRST_PITCH, n.quantizedStartStep);\n      mel.set(_this.NOTE_OFF, n.quantizedEndStep);\n      lastStart = n.quantizedStartStep;\n    });\n    return tf.tidy(function () {\n      return tf.oneHot(mel.toTensor(), _this.depth);\n    });\n  };\n\n  MelodyConverter.prototype.toNoteSequence = function (oh, stepsPerQuarter, qpm) {\n    return __awaiter(this, void 0, void 0, function () {\n      var noteSequence, labelsTensor, labels, currNote, s, label;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);\n            labelsTensor = oh.argMax(1);\n            return [4, labelsTensor.data()];\n\n          case 1:\n            labels = _a.sent();\n            labelsTensor.dispose();\n            currNote = null;\n\n            for (s = 0; s < labels.length; ++s) {\n              label = labels[s];\n\n              switch (label) {\n                case 0:\n                  break;\n\n                case 1:\n                  if (currNote) {\n                    currNote.quantizedEndStep = s;\n                    noteSequence.notes.push(currNote);\n                    currNote = null;\n                  }\n\n                  break;\n\n                default:\n                  if (currNote) {\n                    currNote.quantizedEndStep = s;\n                    noteSequence.notes.push(currNote);\n                  }\n\n                  currNote = index_1.NoteSequence.Note.create({\n                    pitch: label - this.FIRST_PITCH + this.minPitch,\n                    quantizedStartStep: s\n                  });\n              }\n            }\n\n            if (currNote) {\n              currNote.quantizedEndStep = labels.length;\n              noteSequence.notes.push(currNote);\n            }\n\n            noteSequence.totalQuantizedSteps = labels.length;\n            return [2, noteSequence];\n        }\n      });\n    });\n  };\n\n  return MelodyConverter;\n}(DataConverter);\n\nexports.MelodyConverter = MelodyConverter;\n\nvar TrioConverter = function (_super) {\n  __extends(TrioConverter, _super);\n\n  function TrioConverter(args) {\n    var _this = _super.call(this, args) || this;\n\n    _this.NUM_SPLITS = 3;\n    _this.MEL_PROG_RANGE = [0, 31];\n    _this.BASS_PROG_RANGE = [32, 39];\n    args.melArgs.numSteps = args.numSteps;\n    args.bassArgs.numSteps = args.numSteps;\n    args.drumsArgs.numSteps = args.numSteps;\n    _this.melConverter = new MelodyConverter(args.melArgs);\n    _this.bassConverter = new MelodyConverter(args.bassArgs);\n    _this.drumsConverter = new DrumsOneHotConverter(args.drumsArgs);\n    _this.depth = _this.melConverter.depth + _this.bassConverter.depth + _this.drumsConverter.depth;\n    return _this;\n  }\n\n  TrioConverter.prototype.toTensor = function (noteSequence) {\n    var _this = this;\n\n    sequences.assertIsQuantizedSequence(noteSequence);\n    var melSeq = sequences.clone(noteSequence);\n    var bassSeq = sequences.clone(noteSequence);\n    var drumsSeq = sequences.clone(noteSequence);\n    melSeq.notes = noteSequence.notes.filter(function (n) {\n      return !n.isDrum && n.program >= _this.MEL_PROG_RANGE[0] && n.program <= _this.MEL_PROG_RANGE[1];\n    });\n    bassSeq.notes = noteSequence.notes.filter(function (n) {\n      return !n.isDrum && n.program >= _this.BASS_PROG_RANGE[0] && n.program <= _this.BASS_PROG_RANGE[1];\n    });\n    drumsSeq.notes = noteSequence.notes.filter(function (n) {\n      return n.isDrum;\n    });\n    return tf.tidy(function () {\n      return tf.concat([_this.melConverter.toTensor(melSeq), _this.bassConverter.toTensor(bassSeq), _this.drumsConverter.toTensor(drumsSeq)], -1);\n    });\n  };\n\n  TrioConverter.prototype.toNoteSequence = function (th, stepsPerQuarter, qpm) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b, ohs, ns, bassNs, drumsNs;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            ohs = tf.split(th, [this.melConverter.depth, this.bassConverter.depth, this.drumsConverter.depth], -1);\n            return [4, this.melConverter.toNoteSequence(ohs[0], stepsPerQuarter, qpm)];\n\n          case 1:\n            ns = _c.sent();\n            ns.notes.forEach(function (n) {\n              n.instrument = 0;\n              n.program = 0;\n            });\n            return [4, this.bassConverter.toNoteSequence(ohs[1], stepsPerQuarter, qpm)];\n\n          case 2:\n            bassNs = _c.sent();\n\n            (_a = ns.notes).push.apply(_a, bassNs.notes.map(function (n) {\n              n.instrument = 1;\n              n.program = _this.BASS_PROG_RANGE[0];\n              return n;\n            }));\n\n            return [4, this.drumsConverter.toNoteSequence(ohs[2], stepsPerQuarter, qpm)];\n\n          case 3:\n            drumsNs = _c.sent();\n\n            (_b = ns.notes).push.apply(_b, drumsNs.notes.map(function (n) {\n              n.instrument = 2;\n              return n;\n            }));\n\n            ohs.forEach(function (oh) {\n              return oh.dispose();\n            });\n            return [2, ns];\n        }\n      });\n    });\n  };\n\n  return TrioConverter;\n}(DataConverter);\n\nexports.TrioConverter = TrioConverter;\n\nvar MultitrackConverter = function (_super) {\n  __extends(MultitrackConverter, _super);\n\n  function MultitrackConverter(args) {\n    var _this = _super.call(this, args) || this;\n\n    _this.SEGMENTED_BY_TRACK = true;\n    _this.stepsPerQuarter = args.stepsPerQuarter;\n    _this.totalSteps = args.totalSteps;\n    _this.numVelocityBins = args.numVelocityBins;\n    _this.minPitch = args.minPitch ? args.minPitch : constants.MIN_MIDI_PITCH;\n    _this.maxPitch = args.maxPitch ? args.maxPitch : constants.MAX_MIDI_PITCH;\n    _this.numPitches = _this.maxPitch - _this.minPitch + 1;\n    _this.performanceEventDepth = 2 * _this.numPitches + _this.totalSteps + _this.numVelocityBins;\n    _this.numPrograms = constants.MAX_MIDI_PROGRAM - constants.MIN_MIDI_PROGRAM + 2;\n    _this.endToken = _this.performanceEventDepth + _this.numPrograms;\n    _this.depth = _this.endToken + 1;\n    _this.endTensor = tf.tidy(function () {\n      return tf.oneHot(tf.tensor1d([_this.endToken], 'int32'), _this.depth).as1D();\n    });\n    return _this;\n  }\n\n  MultitrackConverter.prototype.trackToTensor = function (track) {\n    var _this = this;\n\n    var maxEventsPerTrack = this.numSteps / this.numSegments;\n    var tokens = undefined;\n\n    if (track) {\n      while (track.events.length > maxEventsPerTrack - 2) {\n        track.events.pop();\n      }\n\n      tokens = tf.buffer([track.events.length + 2], 'int32');\n      tokens.set(this.performanceEventDepth + (track.isDrum ? this.numPrograms - 1 : track.program), 0);\n      track.events.forEach(function (event, index) {\n        switch (event.type) {\n          case 'note-on':\n            tokens.set(event.pitch - _this.minPitch, index + 1);\n            break;\n\n          case 'note-off':\n            tokens.set(_this.numPitches + event.pitch - _this.minPitch, index + 1);\n            break;\n\n          case 'time-shift':\n            tokens.set(2 * _this.numPitches + event.steps - 1, index + 1);\n            break;\n\n          case 'velocity-change':\n            tokens.set(2 * _this.numPitches + _this.totalSteps + event.velocityBin - 1, index + 1);\n            break;\n\n          default:\n            throw new Error(\"Unrecognized performance event: \" + event);\n        }\n      });\n      tokens.set(this.endToken, track.events.length + 1);\n    } else {\n      tokens = tf.buffer([1], 'int32', new Int32Array([this.endToken]));\n    }\n\n    return tf.tidy(function () {\n      var oh = tf.oneHot(tokens.toTensor(), _this.depth);\n      return oh.pad([[0, maxEventsPerTrack - oh.shape[0]], [0, 0]]);\n    });\n  };\n\n  MultitrackConverter.prototype.toTensor = function (noteSequence) {\n    var _this = this;\n\n    sequences.assertIsRelativeQuantizedSequence(noteSequence);\n\n    if (noteSequence.quantizationInfo.stepsPerQuarter !== this.stepsPerQuarter) {\n      throw new Error(\"Steps per quarter note mismatch: \" + noteSequence.quantizationInfo.stepsPerQuarter + \" != \" + this.stepsPerQuarter);\n    }\n\n    var seq = sequences.clone(noteSequence);\n    seq.notes = noteSequence.notes.filter(function (note) {\n      return note.pitch >= _this.minPitch && note.pitch <= _this.maxPitch;\n    });\n    var instruments = new Set(seq.notes.map(function (note) {\n      return note.instrument;\n    }));\n    var tracks = Array.from(instruments).map(function (instrument) {\n      return performance.Performance.fromNoteSequence(seq, _this.totalSteps, _this.numVelocityBins, instrument);\n    });\n    var sortedTracks = tracks.sort(function (a, b) {\n      return b.isDrum ? -1 : a.isDrum ? 1 : a.program - b.program;\n    });\n\n    while (sortedTracks.length > this.numSegments) {\n      sortedTracks.pop();\n    }\n\n    sortedTracks.forEach(function (track) {\n      return track.setNumSteps(_this.totalSteps);\n    });\n\n    while (sortedTracks.length < this.numSegments) {\n      sortedTracks.push(undefined);\n    }\n\n    return tf.tidy(function () {\n      return tf.concat(sortedTracks.map(function (track) {\n        return _this.trackToTensor(track);\n      }), 0);\n    });\n  };\n\n  MultitrackConverter.prototype.tokensToTrack = function (tokens) {\n    var _this = this;\n\n    var idx = tokens.indexOf(this.endToken);\n    var endIndex = idx >= 0 ? idx : tokens.length;\n    var trackTokens = tokens.slice(0, endIndex);\n    var eventTokens = trackTokens.filter(function (token) {\n      return token < _this.performanceEventDepth;\n    });\n    var programTokens = trackTokens.filter(function (token) {\n      return token >= _this.performanceEventDepth;\n    });\n\n    var _a = programTokens.length ? programTokens[0] - this.performanceEventDepth < this.numPrograms - 1 ? [programTokens[0] - this.performanceEventDepth, false] : [0, true] : [0, false],\n        program = _a[0],\n        isDrum = _a[1];\n\n    var events = Array.from(eventTokens).map(function (token) {\n      if (token < _this.numPitches) {\n        return {\n          type: 'note-on',\n          pitch: _this.minPitch + token\n        };\n      } else if (token < 2 * _this.numPitches) {\n        return {\n          type: 'note-off',\n          pitch: _this.minPitch + token - _this.numPitches\n        };\n      } else if (token < 2 * _this.numPitches + _this.totalSteps) {\n        return {\n          type: 'time-shift',\n          steps: token - 2 * _this.numPitches + 1\n        };\n      } else if (token < 2 * _this.numPitches + _this.totalSteps + _this.numVelocityBins) {\n        return {\n          type: 'velocity-change',\n          velocityBin: token - 2 * _this.numPitches - _this.totalSteps + 1\n        };\n      } else {\n        throw new Error(\"Invalid performance event token: \" + token);\n      }\n    });\n    return new performance.Performance(events, this.totalSteps, this.numVelocityBins, program, isDrum);\n  };\n\n  MultitrackConverter.prototype.toNoteSequence = function (oh, stepsPerQuarter, qpm) {\n    if (stepsPerQuarter === void 0) {\n      stepsPerQuarter = this.stepsPerQuarter;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var noteSequence, tensors, tracks;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);\n            noteSequence.totalQuantizedSteps = this.totalSteps;\n            tensors = tf.tidy(function () {\n              return tf.split(oh.argMax(1), _this.numSegments);\n            });\n            return [4, Promise.all(tensors.map(function (tensor) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var tokens, track;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4, tensor.data()];\n\n                    case 1:\n                      tokens = _a.sent();\n                      track = this.tokensToTrack(tokens);\n                      tensor.dispose();\n                      return [2, track];\n                  }\n                });\n              });\n            }))];\n\n          case 1:\n            tracks = _a.sent();\n            tracks.forEach(function (track, instrument) {\n              var _a;\n\n              track.setNumSteps(_this.totalSteps);\n\n              (_a = noteSequence.notes).push.apply(_a, track.toNoteSequence(instrument).notes);\n            });\n            return [2, noteSequence];\n        }\n      });\n    });\n  };\n\n  return MultitrackConverter;\n}(DataConverter);\n\nexports.MultitrackConverter = MultitrackConverter;\n\nvar GrooveConverter = function (_super) {\n  __extends(GrooveConverter, _super);\n\n  function GrooveConverter(args) {\n    var _this = _super.call(this, args) || this;\n\n    _this.TAPIFY_CHANNEL = 3;\n    _this.stepsPerQuarter = args.stepsPerQuarter || constants.DEFAULT_STEPS_PER_QUARTER;\n    _this.pitchClasses = args.pitchClasses || exports.DEFAULT_DRUM_PITCH_CLASSES;\n    _this.pitchToClass = new Map();\n\n    var _loop_2 = function _loop_2(c) {\n      this_2.pitchClasses[c].forEach(function (p) {\n        _this.pitchToClass.set(p, c);\n      });\n    };\n\n    var this_2 = this;\n\n    for (var c = 0; c < _this.pitchClasses.length; ++c) {\n      _loop_2(c);\n    }\n\n    _this.humanize = args.humanize || false;\n    _this.tapify = args.tapify || false;\n    _this.splitInstruments = args.splitInstruments || false;\n    _this.depth = 3;\n    return _this;\n  }\n\n  GrooveConverter.prototype.toTensor = function (ns) {\n    var _this = this;\n\n    var qns = sequences.isRelativeQuantizedSequence(ns) ? ns : sequences.quantizeNoteSequence(ns, this.stepsPerQuarter);\n    var numSteps = this.numSteps;\n    var qpm = qns.tempos && qns.tempos.length ? qns.tempos[0].qpm : constants.DEFAULT_QUARTERS_PER_MINUTE;\n    var stepLength = 60. / qpm / this.stepsPerQuarter;\n    var stepNotes = [];\n\n    for (var i = 0; i < numSteps; ++i) {\n      stepNotes.push(new Map());\n    }\n\n    qns.notes.forEach(function (n) {\n      if (!(_this.tapify || _this.pitchToClass.has(n.pitch))) {\n        return;\n      }\n\n      var s = n.quantizedStartStep;\n\n      if (s >= stepNotes.length) {\n        throw Error(\"Model does not support sequences with more than \" + numSteps + \" steps (\" + numSteps * stepLength + \" seconds at qpm \" + qpm + \").\");\n      }\n\n      var d = _this.tapify ? _this.TAPIFY_CHANNEL : _this.pitchToClass.get(n.pitch);\n\n      if (!stepNotes[s].has(d) || stepNotes[s].get(d).velocity < n.velocity) {\n        stepNotes[s].set(d, n);\n      }\n    });\n    var numDrums = this.pitchClasses.length;\n    var hitVectors = tf.buffer([numSteps, numDrums]);\n    var velocityVectors = tf.buffer([numSteps, numDrums]);\n    var offsetVectors = tf.buffer([numSteps, numDrums]);\n\n    function getOffset(n) {\n      if (n.startTime === undefined) {\n        return 0;\n      }\n\n      var tOnset = n.startTime;\n      var qOnset = n.quantizedStartStep * stepLength;\n      return 2 * (qOnset - tOnset) / stepLength;\n    }\n\n    for (var s = 0; s < numSteps; ++s) {\n      for (var d = 0; d < numDrums; ++d) {\n        var note = stepNotes[s].get(d);\n        hitVectors.set(note ? 1 : 0, s, d);\n\n        if (!this.humanize && !this.tapify) {\n          velocityVectors.set(note ? note.velocity / constants.MAX_MIDI_VELOCITY : 0, s, d);\n        }\n\n        if (!this.humanize) {\n          offsetVectors.set(note ? getOffset(note) : 0, s, d);\n        }\n      }\n    }\n\n    return tf.tidy(function () {\n      var hits = hitVectors.toTensor();\n      var velocities = velocityVectors.toTensor();\n      var offsets = offsetVectors.toTensor();\n      var outLength = _this.splitInstruments ? numSteps * numDrums : numSteps;\n      return tf.concat([hits.as2D(outLength, -1), velocities.as2D(outLength, -1), offsets.as2D(outLength, -1)], 1);\n    });\n  };\n\n  GrooveConverter.prototype.toNoteSequence = function (t, stepsPerQuarter, qpm) {\n    if (qpm === void 0) {\n      qpm = constants.DEFAULT_QUARTERS_PER_MINUTE;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      function clip(v, min, max) {\n        return Math.min(Math.max(v, min), max);\n      }\n\n      var numSteps, stepLength, ns, results, numDrums, s, stepResults, d, hitOutput, velI, velOutput, offsetI, offsetOutput, velocity, offset;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (stepsPerQuarter && stepsPerQuarter !== this.stepsPerQuarter) {\n              throw Error('`stepsPerQuarter` is set by the model.');\n            }\n\n            stepsPerQuarter = this.stepsPerQuarter;\n            numSteps = this.splitInstruments ? t.shape[0] / this.pitchClasses.length : t.shape[0];\n            stepLength = 60. / qpm / this.stepsPerQuarter;\n            ns = index_1.NoteSequence.create({\n              totalTime: numSteps * stepLength,\n              tempos: [{\n                qpm: qpm\n              }]\n            });\n            return [4, t.data()];\n\n          case 1:\n            results = _a.sent();\n            numDrums = this.pitchClasses.length;\n\n            for (s = 0; s < numSteps; ++s) {\n              stepResults = results.slice(s * numDrums * this.depth, (s + 1) * numDrums * this.depth);\n\n              for (d = 0; d < numDrums; ++d) {\n                hitOutput = stepResults[this.splitInstruments ? d * this.depth : d];\n                velI = this.splitInstruments ? d * this.depth + 1 : numDrums + d;\n                velOutput = stepResults[velI];\n                offsetI = this.splitInstruments ? d * this.depth + 2 : 2 * numDrums + d;\n                offsetOutput = stepResults[offsetI];\n\n                if (hitOutput > 0.5) {\n                  velocity = clip(Math.round(velOutput * constants.MAX_MIDI_VELOCITY), constants.MIN_MIDI_VELOCITY, constants.MAX_MIDI_VELOCITY);\n                  offset = clip(offsetOutput / 2, -0.5, 0.5);\n                  ns.notes.push(index_1.NoteSequence.Note.create({\n                    pitch: this.pitchClasses[d][0],\n                    startTime: (s - offset) * stepLength,\n                    endTime: (s - offset + 1) * stepLength,\n                    velocity: velocity,\n                    isDrum: true\n                  }));\n                }\n              }\n            }\n\n            return [2, ns];\n        }\n      });\n    });\n  };\n\n  return GrooveConverter;\n}(DataConverter);\n\nexports.GrooveConverter = GrooveConverter;\n\nfunction createQuantizedNoteSequence(stepsPerQuarter, qpm) {\n  if (stepsPerQuarter === void 0) {\n    stepsPerQuarter = constants.DEFAULT_STEPS_PER_QUARTER;\n  }\n\n  if (qpm === void 0) {\n    qpm = constants.DEFAULT_QUARTERS_PER_MINUTE;\n  }\n\n  return index_1.NoteSequence.create({\n    quantizationInfo: {\n      stepsPerQuarter: stepsPerQuarter\n    },\n    tempos: [{\n      qpm: qpm\n    }]\n  });\n}","map":null,"metadata":{},"sourceType":"script"}