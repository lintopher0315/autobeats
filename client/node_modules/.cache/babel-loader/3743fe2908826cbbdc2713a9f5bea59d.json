{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar index_1 = require(\"../protobuf/index\");\n\nvar constants = require(\"./constants\");\n\nvar QUANTIZE_CUTOFF = 0.5;\n\nvar MultipleTimeSignatureException = function (_super) {\n  __extends(MultipleTimeSignatureException, _super);\n\n  function MultipleTimeSignatureException(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, _newTarget.prototype);\n    return _this;\n  }\n\n  return MultipleTimeSignatureException;\n}(Error);\n\nexports.MultipleTimeSignatureException = MultipleTimeSignatureException;\n\nvar BadTimeSignatureException = function (_super) {\n  __extends(BadTimeSignatureException, _super);\n\n  function BadTimeSignatureException(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, _newTarget.prototype);\n    return _this;\n  }\n\n  return BadTimeSignatureException;\n}(Error);\n\nexports.BadTimeSignatureException = BadTimeSignatureException;\n\nvar NegativeTimeException = function (_super) {\n  __extends(NegativeTimeException, _super);\n\n  function NegativeTimeException(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, _newTarget.prototype);\n    return _this;\n  }\n\n  return NegativeTimeException;\n}(Error);\n\nexports.NegativeTimeException = NegativeTimeException;\n\nvar MultipleTempoException = function (_super) {\n  __extends(MultipleTempoException, _super);\n\n  function MultipleTempoException(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, _newTarget.prototype);\n    return _this;\n  }\n\n  return MultipleTempoException;\n}(Error);\n\nexports.MultipleTempoException = MultipleTempoException;\n\nvar QuantizationStatusException = function (_super) {\n  __extends(QuantizationStatusException, _super);\n\n  function QuantizationStatusException(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, _newTarget.prototype);\n    return _this;\n  }\n\n  return QuantizationStatusException;\n}(Error);\n\nexports.QuantizationStatusException = QuantizationStatusException;\n\nfunction isPowerOf2(n) {\n  return n && (n & n - 1) === 0;\n}\n\nfunction clone(ns) {\n  return index_1.NoteSequence.decode(index_1.NoteSequence.encode(ns).finish());\n}\n\nexports.clone = clone;\n\nfunction stepsPerQuarterToStepsPerSecond(stepsPerQuarter, qpm) {\n  return stepsPerQuarter * qpm / 60.0;\n}\n\nexports.stepsPerQuarterToStepsPerSecond = stepsPerQuarterToStepsPerSecond;\n\nfunction quantizeToStep(unquantizedSeconds, stepsPerSecond, quantizeCutoff) {\n  if (quantizeCutoff === void 0) {\n    quantizeCutoff = QUANTIZE_CUTOFF;\n  }\n\n  var unquantizedSteps = unquantizedSeconds * stepsPerSecond;\n  return Math.floor(unquantizedSteps + (1 - quantizeCutoff));\n}\n\nexports.quantizeToStep = quantizeToStep;\n\nfunction getQuantizedTimeEvents(ns) {\n  return ns.controlChanges.concat(ns.textAnnotations);\n}\n\nfunction quantizeNotesAndEvents(ns, stepsPerSecond) {\n  for (var _i = 0, _a = ns.notes; _i < _a.length; _i++) {\n    var note = _a[_i];\n    note.quantizedStartStep = quantizeToStep(note.startTime, stepsPerSecond);\n    note.quantizedEndStep = quantizeToStep(note.endTime, stepsPerSecond);\n\n    if (note.quantizedEndStep === note.quantizedStartStep) {\n      note.quantizedEndStep += 1;\n    }\n\n    if (note.quantizedStartStep < 0 || note.quantizedEndStep < 0) {\n      throw new NegativeTimeException(\"Got negative note time: start_step = \" + (note.quantizedStartStep + \", end_step = \") + (\"\" + note.quantizedEndStep));\n    }\n\n    if (note.quantizedEndStep > ns.totalQuantizedSteps) {\n      ns.totalQuantizedSteps = note.quantizedEndStep;\n    }\n  }\n\n  getQuantizedTimeEvents(ns).forEach(function (event) {\n    event.quantizedStep = quantizeToStep(event.time, stepsPerSecond);\n\n    if (event.quantizedStep < 0) {\n      throw new NegativeTimeException(\"Got negative event time: step = \" + event.quantizedStep);\n    }\n  });\n}\n\nfunction assertSingleTempo(ns) {\n  if (!ns.tempos || ns.tempos.length === 0) {\n    return;\n  }\n\n  ns.tempos.sort(function (a, b) {\n    return a.time - b.time;\n  });\n\n  if (ns.tempos[0].time !== 0 && ns.tempos[0].qpm !== constants.DEFAULT_QUARTERS_PER_MINUTE) {\n    throw new MultipleTempoException('NoteSequence has an implicit tempo change from initial ' + (constants.DEFAULT_QUARTERS_PER_MINUTE + \" qpm to \") + (ns.tempos[0].qpm + \" qpm at \" + ns.tempos[0].time + \" seconds.\"));\n  }\n\n  for (var i = 1; i < ns.tempos.length; i++) {\n    if (ns.tempos[i].qpm !== ns.tempos[0].qpm) {\n      throw new MultipleTempoException('NoteSequence has at least one tempo change from ' + (ns.tempos[0].qpm + \" qpm to \" + ns.tempos[i].qpm) + (\"qpm at \" + ns.tempos[i].time + \" seconds.\"));\n    }\n  }\n}\n\nfunction quantizeNoteSequence(ns, stepsPerQuarter) {\n  var qns = clone(ns);\n  qns.quantizationInfo = index_1.NoteSequence.QuantizationInfo.create({\n    stepsPerQuarter: stepsPerQuarter\n  });\n\n  if (qns.timeSignatures.length > 0) {\n    qns.timeSignatures.sort(function (a, b) {\n      return a.time - b.time;\n    });\n\n    if (qns.timeSignatures[0].time !== 0 && !(qns.timeSignatures[0].numerator === 4 && qns.timeSignatures[0].denominator === 4)) {\n      throw new MultipleTimeSignatureException('NoteSequence has an implicit change from initial 4/4 time ' + (\"signature to \" + qns.timeSignatures[0].numerator + \"/\") + (qns.timeSignatures[0].denominator + \" at \") + (qns.timeSignatures[0].time + \" seconds.\"));\n    }\n\n    for (var i = 1; i < qns.timeSignatures.length; i++) {\n      var timeSignature = qns.timeSignatures[i];\n\n      if (timeSignature.numerator !== qns.timeSignatures[0].numerator || timeSignature.denominator !== qns.timeSignatures[0].denominator) {\n        throw new MultipleTimeSignatureException('NoteSequence has at least one time signature change from ' + (qns.timeSignatures[0].numerator + \"/\") + (qns.timeSignatures[0].denominator + \" to \") + (timeSignature.numerator + \"/\" + timeSignature.denominator + \" \") + (\"at \" + timeSignature.time + \" seconds\"));\n      }\n    }\n\n    qns.timeSignatures[0].time = 0;\n    qns.timeSignatures = [qns.timeSignatures[0]];\n  } else {\n    var timeSignature = index_1.NoteSequence.TimeSignature.create({\n      numerator: 4,\n      denominator: 4,\n      time: 0\n    });\n    qns.timeSignatures.push(timeSignature);\n  }\n\n  var firstTS = qns.timeSignatures[0];\n\n  if (!isPowerOf2(firstTS.denominator)) {\n    throw new BadTimeSignatureException('Denominator is not a power of 2. Time signature: ' + (firstTS.numerator + \"/\" + firstTS.denominator));\n  }\n\n  if (firstTS.numerator === 0) {\n    throw new BadTimeSignatureException('Numerator is 0. Time signature: ' + (firstTS.numerator + \"/\" + firstTS.denominator));\n  }\n\n  if (qns.tempos.length > 0) {\n    assertSingleTempo(qns);\n    qns.tempos[0].time = 0;\n    qns.tempos = [qns.tempos[0]];\n  } else {\n    var tempo = index_1.NoteSequence.Tempo.create({\n      qpm: constants.DEFAULT_QUARTERS_PER_MINUTE,\n      time: 0\n    });\n    qns.tempos.push(tempo);\n  }\n\n  var stepsPerSecond = stepsPerQuarterToStepsPerSecond(stepsPerQuarter, qns.tempos[0].qpm);\n  qns.totalQuantizedSteps = quantizeToStep(ns.totalTime, stepsPerSecond);\n  quantizeNotesAndEvents(qns, stepsPerSecond);\n  return qns;\n}\n\nexports.quantizeNoteSequence = quantizeNoteSequence;\n\nfunction isQuantizedSequence(ns) {\n  return ns.quantizationInfo && (ns.quantizationInfo.stepsPerQuarter > 0 || ns.quantizationInfo.stepsPerSecond > 0);\n}\n\nexports.isQuantizedSequence = isQuantizedSequence;\n\nfunction assertIsQuantizedSequence(ns) {\n  if (!isQuantizedSequence(ns)) {\n    throw new QuantizationStatusException(\"NoteSequence \" + ns.id + \" is not quantized (missing quantizationInfo)\");\n  }\n}\n\nexports.assertIsQuantizedSequence = assertIsQuantizedSequence;\n\nfunction isRelativeQuantizedSequence(ns) {\n  return ns.quantizationInfo && ns.quantizationInfo.stepsPerQuarter > 0;\n}\n\nexports.isRelativeQuantizedSequence = isRelativeQuantizedSequence;\n\nfunction assertIsRelativeQuantizedSequence(ns) {\n  if (!isRelativeQuantizedSequence(ns)) {\n    throw new QuantizationStatusException(\"NoteSequence \" + ns.id + \" is not quantized or is quantized based on absolute timing\");\n  }\n}\n\nexports.assertIsRelativeQuantizedSequence = assertIsRelativeQuantizedSequence;\n\nfunction isAbsoluteQuantizedSequence(ns) {\n  return ns.quantizationInfo && ns.quantizationInfo.stepsPerSecond > 0;\n}\n\nexports.isAbsoluteQuantizedSequence = isAbsoluteQuantizedSequence;\n\nfunction assertIsAbsoluteQuantizedSequence(ns) {\n  if (!isAbsoluteQuantizedSequence(ns)) {\n    throw new QuantizationStatusException(\"NoteSequence \" + ns.id + \" is not quantized or is quantized based on relative timing\");\n  }\n}\n\nexports.assertIsAbsoluteQuantizedSequence = assertIsAbsoluteQuantizedSequence;\n\nfunction unquantizeSequence(qns, qpm) {\n  assertIsRelativeQuantizedSequence(qns);\n  assertSingleTempo(qns);\n  var ns = clone(qns);\n\n  if (qpm) {\n    if (ns.tempos && ns.tempos.length > 0) {\n      ns.tempos[0].qpm = qpm;\n    } else {\n      ns.tempos.push(index_1.NoteSequence.Tempo.create({\n        time: 0,\n        qpm: qpm\n      }));\n    }\n  } else {\n    qpm = qns.tempos && qns.tempos.length > 0 ? ns.tempos[0].qpm : constants.DEFAULT_QUARTERS_PER_MINUTE;\n  }\n\n  var stepToSeconds = function stepToSeconds(step) {\n    return step / ns.quantizationInfo.stepsPerQuarter * (60 / qpm);\n  };\n\n  ns.totalTime = stepToSeconds(ns.totalQuantizedSteps);\n  ns.notes.forEach(function (n) {\n    n.startTime = stepToSeconds(n.quantizedStartStep);\n    n.endTime = stepToSeconds(n.quantizedEndStep);\n    ns.totalTime = Math.max(ns.totalTime, n.endTime);\n  });\n  getQuantizedTimeEvents(ns).forEach(function (event) {\n    event.time = stepToSeconds(event.time);\n  });\n  return ns;\n}\n\nexports.unquantizeSequence = unquantizeSequence;\n\nfunction mergeInstruments(ns) {\n  var result = clone(ns);\n  var events = result.notes.concat(result.pitchBends).concat(result.controlChanges);\n  var programs = Array.from(new Set(events.filter(function (e) {\n    return !e.isDrum;\n  }).map(function (e) {\n    return e.program;\n  })));\n  events.forEach(function (e) {\n    if (e.isDrum) {\n      e.program = 0;\n      e.instrument = programs.length;\n    } else {\n      e.instrument = programs.indexOf(e.program);\n    }\n  });\n  return result;\n}\n\nexports.mergeInstruments = mergeInstruments;\n\nfunction replaceInstruments(originalSequence, replaceSequence) {\n  var instrumentsInOriginal = new Set(originalSequence.notes.map(function (n) {\n    return n.instrument;\n  }));\n  var instrumentsInReplace = new Set(replaceSequence.notes.map(function (n) {\n    return n.instrument;\n  }));\n  var newNotes = [];\n  originalSequence.notes.forEach(function (n) {\n    if (!instrumentsInReplace.has(n.instrument)) {\n      newNotes.push(index_1.NoteSequence.Note.create(n));\n    }\n  });\n  replaceSequence.notes.forEach(function (n) {\n    if (instrumentsInOriginal.has(n.instrument)) {\n      newNotes.push(index_1.NoteSequence.Note.create(n));\n    }\n  });\n  var output = clone(originalSequence);\n  output.notes = newNotes.sort(function (a, b) {\n    var voiceCompare = a.instrument - b.instrument;\n\n    if (voiceCompare) {\n      return voiceCompare;\n    }\n\n    return a.quantizedStartStep - b.quantizedStartStep;\n  });\n  return output;\n}\n\nexports.replaceInstruments = replaceInstruments;\n\nfunction mergeConsecutiveNotes(sequence) {\n  assertIsQuantizedSequence(sequence);\n  var output = clone(sequence);\n  output.notes = [];\n  var newNotes = sequence.notes.sort(function (a, b) {\n    var voiceCompare = a.instrument - b.instrument;\n\n    if (voiceCompare) {\n      return voiceCompare;\n    }\n\n    return a.quantizedStartStep - b.quantizedStartStep;\n  });\n  var note = new index_1.NoteSequence.Note();\n  note.pitch = newNotes[0].pitch;\n  note.instrument = newNotes[0].instrument;\n  note.quantizedStartStep = newNotes[0].quantizedStartStep;\n  note.quantizedEndStep = newNotes[0].quantizedEndStep;\n  output.notes.push(note);\n  var o = 0;\n\n  for (var i = 1; i < newNotes.length; i++) {\n    var thisNote = newNotes[i];\n    var previousNote = output.notes[o];\n\n    if (previousNote.instrument === thisNote.instrument && previousNote.pitch === thisNote.pitch && thisNote.quantizedStartStep === previousNote.quantizedEndStep && thisNote.quantizedStartStep % 16 !== 0) {\n      output.notes[o].quantizedEndStep += thisNote.quantizedEndStep - thisNote.quantizedStartStep;\n    } else {\n      var note_1 = new index_1.NoteSequence.Note();\n      note_1.pitch = newNotes[i].pitch;\n      note_1.instrument = newNotes[i].instrument;\n      note_1.quantizedStartStep = newNotes[i].quantizedStartStep;\n      note_1.quantizedEndStep = newNotes[i].quantizedEndStep;\n      output.notes.push(note_1);\n      o++;\n    }\n  }\n\n  return output;\n}\n\nexports.mergeConsecutiveNotes = mergeConsecutiveNotes;\n\nfunction concatenate(concatenateSequences, sequenceDurations) {\n  if (sequenceDurations && sequenceDurations.length !== concatenateSequences.length) {\n    throw new Error(\"Number of sequences to concatenate and their individual\\n durations does not match.\");\n  }\n\n  if (isQuantizedSequence(concatenateSequences[0])) {\n    for (var i = 0; i < concatenateSequences.length; ++i) {\n      assertIsQuantizedSequence(concatenateSequences[i]);\n\n      if (concatenateSequences[i].quantizationInfo.stepsPerQuarter !== concatenateSequences[0].quantizationInfo.stepsPerQuarter) {\n        throw new Error('Not all sequences have the same quantizationInfo');\n      }\n    }\n\n    return concatenateHelper(concatenateSequences, 'totalQuantizedSteps', 'quantizedStartStep', 'quantizedEndStep', sequenceDurations);\n  } else {\n    return concatenateHelper(concatenateSequences, 'totalTime', 'startTime', 'endTime', sequenceDurations);\n  }\n}\n\nexports.concatenate = concatenate;\n\nfunction trim(ns, start, end, truncateEndNotes) {\n  return isQuantizedSequence(ns) ? trimHelper(ns, start, end, 'totalQuantizedSteps', 'quantizedStartStep', 'quantizedEndStep', truncateEndNotes) : trimHelper(ns, start, end, 'totalTime', 'startTime', 'endTime', truncateEndNotes);\n}\n\nexports.trim = trim;\n\nfunction concatenateHelper(seqs, totalKey, startKey, endKey, sequenceDurations) {\n  var concatSeq;\n  var totalDuration = 0;\n\n  for (var i = 0; i < seqs.length; ++i) {\n    var seqDuration = sequenceDurations ? sequenceDurations[i] : seqs[i][totalKey];\n\n    if (seqDuration === 0) {\n      throw Error(\"Sequence \" + seqs[i].id + \" has no \" + totalKey + \", and no individual duration was provided.\");\n    }\n\n    if (i === 0) {\n      concatSeq = clone(seqs[0]);\n    } else {\n      Array.prototype.push.apply(concatSeq.notes, seqs[i].notes.map(function (n) {\n        var newN = index_1.NoteSequence.Note.create(n);\n        newN[startKey] += totalDuration;\n        newN[endKey] += totalDuration;\n        return newN;\n      }));\n    }\n\n    totalDuration += seqDuration;\n  }\n\n  concatSeq[totalKey] = totalDuration;\n  return concatSeq;\n}\n\nfunction trimHelper(ns, start, end, totalKey, startKey, endKey, truncateEndNotes) {\n  var result = clone(ns);\n  result[totalKey] = end;\n  result.notes = result.notes.filter(function (n) {\n    return n[startKey] >= start && n[startKey] <= end && (truncateEndNotes || n[endKey] <= end);\n  });\n\n  for (var i = 0; i < result.notes.length; i++) {\n    result.notes[i][startKey] -= start;\n    result.notes[i][endKey] -= start;\n\n    if (truncateEndNotes) {\n      result.notes[i][endKey] = Math.min(result.notes[i][endKey], end);\n    }\n  }\n\n  result[totalKey] = Math.min(ns[totalKey] - start, end);\n  return result;\n}\n\nfunction split(seq, chunkSize) {\n  assertIsQuantizedSequence(seq);\n  var ns = clone(seq);\n  var notesBystartStep = ns.notes.sort(function (a, b) {\n    return a.quantizedStartStep - b.quantizedStartStep;\n  });\n  var chunks = [];\n  var startStep = 0;\n  var currentNotes = [];\n\n  for (var i = 0; i < notesBystartStep.length; i++) {\n    var note = notesBystartStep[i];\n    var originalStartStep = note.quantizedStartStep;\n    var originalEndStep = note.quantizedEndStep;\n    note.quantizedStartStep -= startStep;\n    note.quantizedEndStep -= startStep;\n\n    if (note.quantizedStartStep < 0) {\n      continue;\n    }\n\n    if (note.quantizedEndStep <= chunkSize) {\n      currentNotes.push(note);\n    } else {\n      if (note.quantizedStartStep < chunkSize) {\n        var newNote = index_1.NoteSequence.Note.create(note);\n        newNote.quantizedEndStep = chunkSize;\n        newNote.startTime = newNote.endTime = undefined;\n        currentNotes.push(newNote);\n        note.quantizedStartStep = startStep + chunkSize;\n        note.quantizedEndStep = originalEndStep;\n      } else {\n        note.quantizedStartStep = originalStartStep;\n        note.quantizedEndStep = originalEndStep;\n      }\n\n      if (note.quantizedEndStep > chunkSize || note.quantizedStartStep > chunkSize) {\n        i = i - 1;\n      }\n\n      if (currentNotes.length !== 0) {\n        var newSequence = clone(ns);\n        newSequence.notes = currentNotes;\n        newSequence.totalQuantizedSteps = chunkSize;\n        chunks.push(newSequence);\n      }\n\n      currentNotes = [];\n      startStep += chunkSize;\n    }\n  }\n\n  if (currentNotes.length !== 0) {\n    var newSequence = clone(ns);\n    newSequence.notes = currentNotes;\n    newSequence.totalQuantizedSteps = chunkSize;\n    chunks.push(newSequence);\n  }\n\n  return chunks;\n}\n\nexports.split = split;","map":null,"metadata":{},"sourceType":"script"}