{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar index_1 = require(\"../protobuf/index\");\n\nvar constants = require(\"./constants\");\n\nvar sequences = require(\"./sequences\");\n\nvar Performance = function () {\n  function Performance(events, maxShiftSteps, numVelocityBins, program, isDrum) {\n    this.events = events;\n    this.maxShiftSteps = maxShiftSteps;\n    this.numVelocityBins = numVelocityBins;\n    this.program = program;\n    this.isDrum = isDrum;\n  }\n\n  Performance.fromNoteSequence = function (noteSequence, maxShiftSteps, numVelocityBins, instrument) {\n    sequences.assertIsQuantizedSequence(noteSequence);\n    var notes = noteSequence.notes.filter(function (note, _) {\n      return instrument !== undefined ? note.instrument === instrument : true;\n    });\n    var sortedNotes = notes.sort(function (a, b) {\n      return a.startTime === b.startTime ? a.pitch - b.pitch : a.startTime - b.startTime;\n    });\n    var onsets = sortedNotes.map(function (note, i) {\n      return {\n        step: note.quantizedStartStep,\n        index: i,\n        isOffset: 0\n      };\n    });\n    var offsets = sortedNotes.map(function (note, i) {\n      return {\n        step: note.quantizedEndStep,\n        index: i,\n        isOffset: 1\n      };\n    });\n    var noteEvents = onsets.concat(offsets).sort(function (a, b) {\n      return a.step === b.step ? a.index === b.index ? a.isOffset - b.isOffset : a.index - b.index : a.step - b.step;\n    });\n    var velocityBinSize = numVelocityBins ? Math.ceil((constants.MIDI_VELOCITIES - 1) / numVelocityBins) : undefined;\n    var events = [];\n    var currentStep = 0;\n    var currentVelocityBin = numVelocityBins;\n\n    for (var _i = 0, noteEvents_1 = noteEvents; _i < noteEvents_1.length; _i++) {\n      var e = noteEvents_1[_i];\n\n      if (e.step > currentStep) {\n        while (e.step > currentStep + maxShiftSteps) {\n          events.push({\n            type: 'time-shift',\n            steps: maxShiftSteps\n          });\n          currentStep += maxShiftSteps;\n        }\n\n        events.push({\n          type: 'time-shift',\n          steps: e.step - currentStep\n        });\n        currentStep = e.step;\n      }\n\n      if (e.isOffset) {\n        events.push({\n          type: 'note-off',\n          pitch: sortedNotes[e.index].pitch\n        });\n      } else {\n        if (velocityBinSize) {\n          var velocityBin = Math.floor((sortedNotes[e.index].velocity - constants.MIN_MIDI_VELOCITY - 1) / velocityBinSize) + 1;\n\n          if (velocityBin !== currentVelocityBin) {\n            events.push({\n              type: 'velocity-change',\n              velocityBin: velocityBin\n            });\n            currentVelocityBin = velocityBin;\n          }\n        }\n\n        events.push({\n          type: 'note-on',\n          pitch: sortedNotes[e.index].pitch\n        });\n      }\n    }\n\n    var isDrum = notes.some(function (note) {\n      return note.isDrum;\n    }) ? notes.some(function (note) {\n      return !note.isDrum;\n    }) ? undefined : true : false;\n    var programs = Array.from(new Set(notes.map(function (note) {\n      return note.program;\n    })));\n    var program = !isDrum && programs.length === 1 ? programs[0] : undefined;\n    var performance = new Performance(events, maxShiftSteps, numVelocityBins, program, isDrum);\n    performance.setNumSteps(noteSequence.totalQuantizedSteps);\n    return performance;\n  };\n\n  Performance.prototype.getNumSteps = function () {\n    return this.events.filter(function (event) {\n      return event.type === 'time-shift';\n    }).map(function (event) {\n      return event.steps;\n    }).reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  };\n\n  Performance.prototype.setNumSteps = function (numSteps) {\n    var currentNumSteps = this.getNumSteps();\n\n    if (currentNumSteps < numSteps) {\n      if (this.events.length) {\n        var event_1 = this.events[this.events.length - 1];\n\n        if (event_1.type === 'time-shift') {\n          var steps = Math.min(numSteps - currentNumSteps, this.maxShiftSteps - event_1.steps);\n          event_1.steps += steps;\n          currentNumSteps += steps;\n        }\n      }\n\n      while (currentNumSteps < numSteps) {\n        if (currentNumSteps + this.maxShiftSteps > numSteps) {\n          this.events.push({\n            type: 'time-shift',\n            steps: numSteps - currentNumSteps\n          });\n          currentNumSteps = numSteps;\n        } else {\n          this.events.push({\n            type: 'time-shift',\n            steps: this.maxShiftSteps\n          });\n          currentNumSteps += this.maxShiftSteps;\n        }\n      }\n    } else if (currentNumSteps > numSteps) {\n      while (this.events.length && currentNumSteps > numSteps) {\n        var event_2 = this.events[this.events.length - 1];\n\n        if (event_2.type === 'time-shift') {\n          if (currentNumSteps - event_2.steps < numSteps) {\n            event_2.steps -= currentNumSteps - numSteps;\n            currentNumSteps = numSteps;\n          } else {\n            this.events.pop();\n            currentNumSteps -= event_2.steps;\n          }\n        } else {\n          this.events.pop();\n        }\n      }\n    }\n  };\n\n  Performance.prototype.toNoteSequence = function (instrument) {\n    var _this = this;\n\n    var velocityBinSize = this.numVelocityBins ? Math.ceil((constants.MIDI_VELOCITIES - 1) / this.numVelocityBins) : undefined;\n    var noteSequence = index_1.NoteSequence.create();\n    var currentStep = 0;\n    var currentVelocity = undefined;\n    var pitchStartStepsAndVelocities = new Map();\n\n    for (var i = constants.MIN_MIDI_PITCH; i <= constants.MAX_MIDI_PITCH; ++i) {\n      pitchStartStepsAndVelocities.set(i, []);\n    }\n\n    for (var _i = 0, _a = this.events; _i < _a.length; _i++) {\n      var event_3 = _a[_i];\n\n      switch (event_3.type) {\n        case 'note-on':\n          pitchStartStepsAndVelocities.get(event_3.pitch).push([currentStep, currentVelocity]);\n          break;\n\n        case 'note-off':\n          var startStepsAndVelocities = pitchStartStepsAndVelocities.get(event_3.pitch);\n\n          if (startStepsAndVelocities.length) {\n            var _b = startStepsAndVelocities.shift(),\n                startStep = _b[0],\n                velocity = _b[1];\n\n            if (currentStep > startStep) {\n              noteSequence.notes.push(index_1.NoteSequence.Note.create({\n                pitch: event_3.pitch,\n                velocity: velocity,\n                instrument: instrument,\n                quantizedStartStep: startStep,\n                quantizedEndStep: currentStep,\n                program: this.program,\n                isDrum: this.isDrum\n              }));\n            } else {\n              console.log('Ignoring zero-length note: ' + (\"(pitch = \" + event_3.pitch + \", step = \" + currentStep + \")\"));\n            }\n          } else {\n            console.log('Ignoring note-off with no previous note-on:' + (\"(pitch = \" + event_3.pitch + \", step = \" + currentStep + \")\"));\n          }\n\n          break;\n\n        case 'time-shift':\n          currentStep += event_3.steps;\n          break;\n\n        case 'velocity-change':\n          if (velocityBinSize) {\n            currentVelocity = constants.MIN_MIDI_VELOCITY + (event_3.velocityBin - 1) * velocityBinSize + 1;\n          } else {\n            throw new Error(\"Unexpected velocity change event: \" + event_3);\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unrecognized performance event: \" + event_3);\n      }\n    }\n\n    pitchStartStepsAndVelocities.forEach(function (startStepsAndVelocities, pitch) {\n      for (var _i = 0, startStepsAndVelocities_1 = startStepsAndVelocities; _i < startStepsAndVelocities_1.length; _i++) {\n        var _a = startStepsAndVelocities_1[_i],\n            startStep = _a[0],\n            velocity = _a[1];\n\n        if (currentStep > startStep) {\n          noteSequence.notes.push(index_1.NoteSequence.Note.create({\n            pitch: pitch,\n            velocity: velocity,\n            instrument: instrument,\n            quantizedStartStep: startStep,\n            quantizedEndStep: currentStep,\n            program: _this.program,\n            isDrum: _this.isDrum\n          }));\n        } else {\n          console.log('Ignoring zero-length note: ' + (\"(pitch = \" + pitch + \", step = \" + currentStep + \")\"));\n        }\n      }\n    });\n    noteSequence.totalQuantizedSteps = currentStep;\n    return noteSequence;\n  };\n\n  return Performance;\n}();\n\nexports.Performance = Performance;","map":null,"metadata":{},"sourceType":"script"}