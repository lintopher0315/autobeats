{"ast":null,"code":"function hasMoreValues(arrays, positions) {\n  for (var i = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    var pos = positions[i];\n\n    if (arr.length > pos) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getLowestAtPosition(arrays, positions, encoders) {\n  var lowestIndex = 0;\n  var lowestValue = Infinity;\n\n  for (var i = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    var pos = positions[i];\n\n    if (arr[pos] && arr[pos].time < lowestValue) {\n      lowestIndex = i;\n      lowestValue = arr[pos].time;\n    }\n  }\n\n  encoders[lowestIndex](arrays[lowestIndex][positions[lowestIndex]]); // increment array\n\n  positions[lowestIndex] += 1;\n}\n/**\n * Combine multiple arrays keeping the timing in order\n * The arguments should alternate between the array and the encoder callback\n * @param {...Array|Function} args\n */\n\n\nfunction Merge() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var arrays = args.filter(function (v, i) {\n    return i % 2 === 0;\n  });\n  var positions = new Uint32Array(arrays.length);\n  var encoders = args.filter(function (v, i) {\n    return i % 2 === 1;\n  });\n  var output = [];\n\n  while (hasMoreValues(arrays, positions)) {\n    getLowestAtPosition(arrays, positions, encoders);\n  }\n}\n\nexport { Merge };","map":null,"metadata":{},"sourceType":"module"}