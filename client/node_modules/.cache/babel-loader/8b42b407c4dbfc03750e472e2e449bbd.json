{"ast":null,"code":"var Midi = {};\n\n(function (exported) {\n  var DEFAULT_VOLUME = exported.DEFAULT_VOLUME = 90;\n  var DEFAULT_DURATION = exported.DEFAULT_DURATION = 128;\n  var DEFAULT_CHANNEL = exported.DEFAULT_CHANNEL = 0;\n  /* ******************************************************************\n   * Utility functions\n   ****************************************************************** */\n\n  var Util = {\n    midi_letter_pitches: {\n      a: 21,\n      b: 23,\n      c: 12,\n      d: 14,\n      e: 16,\n      f: 17,\n      g: 19\n    },\n\n    /**\n     * Convert a symbolic note name (e.g. \"c4\") to a numeric MIDI pitch (e.g.\n     * 60, middle C).\n     *\n     * @param {string} n - The symbolic note name to parse.\n     * @returns {number} The MIDI pitch that corresponds to the symbolic note\n     * name.\n     */\n    midiPitchFromNote: function midiPitchFromNote(n) {\n      var matches = /([a-g])(#+|b+)?([0-9]+)$/i.exec(n);\n      var note = matches[1].toLowerCase(),\n          accidental = matches[2] || '',\n          octave = parseInt(matches[3], 10);\n      return 12 * octave + Util.midi_letter_pitches[note] + (accidental.substr(0, 1) == '#' ? 1 : -1) * accidental.length;\n    },\n\n    /**\n     * Ensure that the given argument is converted to a MIDI pitch. Note that\n     * it may already be one (including a purely numeric string).\n     *\n     * @param {string|number} p - The pitch to convert.\n     * @returns {number} The resulting numeric MIDI pitch.\n     */\n    ensureMidiPitch: function ensureMidiPitch(p) {\n      if (typeof p == 'number' || !/[^0-9]/.test(p)) {\n        // numeric pitch\n        return parseInt(p, 10);\n      } else {\n        // assume it's a note name\n        return Util.midiPitchFromNote(p);\n      }\n    },\n    midi_pitches_letter: {\n      '12': 'c',\n      '13': 'c#',\n      '14': 'd',\n      '15': 'd#',\n      '16': 'e',\n      '17': 'f',\n      '18': 'f#',\n      '19': 'g',\n      '20': 'g#',\n      '21': 'a',\n      '22': 'a#',\n      '23': 'b'\n    },\n    midi_flattened_notes: {\n      'a#': 'bb',\n      'c#': 'db',\n      'd#': 'eb',\n      'f#': 'gb',\n      'g#': 'ab'\n    },\n\n    /**\n     * Convert a numeric MIDI pitch value (e.g. 60) to a symbolic note name\n     * (e.g. \"c4\").\n     *\n     * @param {number} n - The numeric MIDI pitch value to convert.\n     * @param {boolean} [returnFlattened=false] - Whether to prefer flattened\n     * notes to sharpened ones. Optional, default false.\n     * @returns {string} The resulting symbolic note name.\n     */\n    noteFromMidiPitch: function noteFromMidiPitch(n, returnFlattened) {\n      var octave = 0,\n          noteNum = n,\n          noteName,\n          returnFlattened = returnFlattened || false;\n\n      if (n > 23) {\n        // noteNum is on octave 1 or more\n        octave = Math.floor(n / 12) - 1; // subtract number of octaves from noteNum\n\n        noteNum = n - octave * 12;\n      } // get note name (c#, d, f# etc)\n\n\n      noteName = Util.midi_pitches_letter[noteNum]; // Use flattened notes if requested (e.g. f# should be output as gb)\n\n      if (returnFlattened && noteName.indexOf('#') > 0) {\n        noteName = Util.midi_flattened_notes[noteName];\n      }\n\n      return noteName + octave;\n    },\n\n    /**\n     * Convert beats per minute (BPM) to microseconds per quarter note (MPQN).\n     *\n     * @param {number} bpm - A number in beats per minute.\n     * @returns {number} The number of microseconds per quarter note.\n     */\n    mpqnFromBpm: function mpqnFromBpm(bpm) {\n      var mpqn = Math.floor(60000000 / bpm);\n      var ret = [];\n\n      do {\n        ret.unshift(mpqn & 0xFF);\n        mpqn >>= 8;\n      } while (mpqn);\n\n      while (ret.length < 3) {\n        ret.push(0);\n      }\n\n      return ret;\n    },\n\n    /**\n     * Convert microseconds per quarter note (MPQN) to beats per minute (BPM).\n     *\n     * @param {number} mpqn - The number of microseconds per quarter note.\n     * @returns {number} A number in beats per minute.\n     */\n    bpmFromMpqn: function bpmFromMpqn(mpqn) {\n      var m = mpqn;\n\n      if (typeof mpqn[0] != 'undefined') {\n        m = 0;\n\n        for (var i = 0, l = mpqn.length - 1; l >= 0; ++i, --l) {\n          m |= mpqn[i] << l;\n        }\n      }\n\n      return Math.floor(60000000 / mpqn);\n    },\n\n    /**\n     * Converts an array of bytes to a string of hexadecimal characters. Prepares\n     * it to be converted into a base64 string.\n     *\n     * @param {Array} byteArray - Array of bytes to be converted.\n     * @returns {string} Hexadecimal string, e.g. \"097B8A\".\n     */\n    codes2Str: function codes2Str(byteArray) {\n      return String.fromCharCode.apply(null, byteArray);\n    },\n\n    /**\n     * Converts a string of hexadecimal values to an array of bytes. It can also\n     * add remaining \"0\" nibbles in order to have enough bytes in the array as the\n     * `finalBytes` parameter.\n     *\n     * @param {string} str - string of hexadecimal values e.g. \"097B8A\"\n     * @param {number} [finalBytes] - Optional. The desired number of bytes\n     * (not nibbles) that the returned array should contain.\n     * @returns {Array} An array of nibbles.\n     */\n    str2Bytes: function str2Bytes(str, finalBytes) {\n      if (finalBytes) {\n        while (str.length / 2 < finalBytes) {\n          str = \"0\" + str;\n        }\n      }\n\n      var bytes = [];\n\n      for (var i = str.length - 1; i >= 0; i = i - 2) {\n        var chars = i === 0 ? str[i] : str[i - 1] + str[i];\n        bytes.unshift(parseInt(chars, 16));\n      }\n\n      return bytes;\n    },\n\n    /**\n     * Translates number of ticks to MIDI timestamp format, returning an array\n     * of bytes with the time values. MIDI has a very particular way to express\n     * time; take a good look at the spec before ever touching this function.\n     *\n     * @param {number} ticks - Number of ticks to be translated.\n     * @returns {number} Array of bytes that form the MIDI time value.\n     */\n    translateTickTime: function translateTickTime(ticks) {\n      var buffer = ticks & 0x7F;\n\n      while (ticks = ticks >> 7) {\n        buffer <<= 8;\n        buffer |= ticks & 0x7F | 0x80;\n      }\n\n      var bList = [];\n\n      while (true) {\n        bList.push(buffer & 0xff);\n\n        if (buffer & 0x80) {\n          buffer >>= 8;\n        } else {\n          break;\n        }\n      }\n\n      return bList;\n    }\n  };\n  /* ******************************************************************\n   * Event class\n   ****************************************************************** */\n\n  /**\n   * Construct a MIDI event.\n   *\n   * Parameters include:\n   *  - time [optional number] - Ticks since previous event.\n   *  - type [required number] - Type of event.\n   *  - channel [required number] - Channel for the event.\n   *  - param1 [required number] - First event parameter.\n   *  - param2 [optional number] - Second event parameter.\n   */\n\n  var MidiEvent = function MidiEvent(params) {\n    if (!this) return new MidiEvent(params);\n\n    if (params && (params.type !== null || params.type !== undefined) && (params.channel !== null || params.channel !== undefined) && (params.param1 !== null || params.param1 !== undefined)) {\n      this.setTime(params.time);\n      this.setType(params.type);\n      this.setChannel(params.channel);\n      this.setParam1(params.param1);\n      this.setParam2(params.param2);\n    }\n  }; // event codes\n\n\n  MidiEvent.NOTE_OFF = 0x80;\n  MidiEvent.NOTE_ON = 0x90;\n  MidiEvent.AFTER_TOUCH = 0xA0;\n  MidiEvent.CONTROLLER = 0xB0;\n  MidiEvent.PROGRAM_CHANGE = 0xC0;\n  MidiEvent.CHANNEL_AFTERTOUCH = 0xD0;\n  MidiEvent.PITCH_BEND = 0xE0;\n  /**\n   * Set the time for the event in ticks since the previous event.\n   *\n   * @param {number} ticks - The number of ticks since the previous event. May\n   * be zero.\n   */\n\n  MidiEvent.prototype.setTime = function (ticks) {\n    this.time = Util.translateTickTime(ticks || 0);\n  };\n  /**\n   * Set the type of the event. Must be one of the event codes on MidiEvent.\n   *\n   * @param {number} type - Event type.\n   */\n\n\n  MidiEvent.prototype.setType = function (type) {\n    if (type < MidiEvent.NOTE_OFF || type > MidiEvent.PITCH_BEND) {\n      throw new Error(\"Trying to set an unknown event: \" + type);\n    }\n\n    this.type = type;\n  };\n  /**\n   * Set the channel for the event. Must be between 0 and 15, inclusive.\n   *\n   * @param {number} channel - The event channel.\n   */\n\n\n  MidiEvent.prototype.setChannel = function (channel) {\n    if (channel < 0 || channel > 15) {\n      throw new Error(\"Channel is out of bounds.\");\n    }\n\n    this.channel = channel;\n  };\n  /**\n   * Set the first parameter for the event. Must be between 0 and 255,\n   * inclusive.\n   *\n   * @param {number} p - The first event parameter value.\n   */\n\n\n  MidiEvent.prototype.setParam1 = function (p) {\n    this.param1 = p;\n  };\n  /**\n   * Set the second parameter for the event. Must be between 0 and 255,\n   * inclusive.\n   *\n   * @param {number} p - The second event parameter value.\n   */\n\n\n  MidiEvent.prototype.setParam2 = function (p) {\n    this.param2 = p;\n  };\n  /**\n   * Serialize the event to an array of bytes.\n   *\n   * @returns {Array} The array of serialized bytes.\n   */\n\n\n  MidiEvent.prototype.toBytes = function () {\n    var byteArray = [];\n    var typeChannelByte = this.type | this.channel & 0xF;\n    byteArray.push.apply(byteArray, this.time);\n    byteArray.push(typeChannelByte);\n    byteArray.push(this.param1); // Some events don't have a second parameter\n\n    if (this.param2 !== undefined && this.param2 !== null) {\n      byteArray.push(this.param2);\n    }\n\n    return byteArray;\n  };\n  /* ******************************************************************\n   * MetaEvent class\n   ****************************************************************** */\n\n  /**\n   * Construct a meta event.\n   *\n   * Parameters include:\n   *  - time [optional number] - Ticks since previous event.\n   *  - type [required number] - Type of event.\n   *  - data [optional array|string] - Event data.\n   */\n\n\n  var MetaEvent = function MetaEvent(params) {\n    if (!this) return new MetaEvent(params);\n    var p = params || {};\n    this.setTime(params.time);\n    this.setType(params.type);\n    this.setData(params.data);\n  };\n\n  MetaEvent.SEQUENCE = 0x00;\n  MetaEvent.TEXT = 0x01;\n  MetaEvent.COPYRIGHT = 0x02;\n  MetaEvent.TRACK_NAME = 0x03;\n  MetaEvent.INSTRUMENT = 0x04;\n  MetaEvent.LYRIC = 0x05;\n  MetaEvent.MARKER = 0x06;\n  MetaEvent.CUE_POINT = 0x07;\n  MetaEvent.CHANNEL_PREFIX = 0x20;\n  MetaEvent.END_OF_TRACK = 0x2f;\n  MetaEvent.TEMPO = 0x51;\n  MetaEvent.SMPTE = 0x54;\n  MetaEvent.TIME_SIG = 0x58;\n  MetaEvent.KEY_SIG = 0x59;\n  MetaEvent.SEQ_EVENT = 0x7f;\n  /**\n   * Set the time for the event in ticks since the previous event.\n   *\n   * @param {number} ticks - The number of ticks since the previous event. May\n   * be zero.\n   */\n\n  MetaEvent.prototype.setTime = function (ticks) {\n    this.time = Util.translateTickTime(ticks || 0);\n  };\n  /**\n   * Set the type of the event. Must be one of the event codes on MetaEvent.\n   *\n   * @param {number} t - Event type.\n   */\n\n\n  MetaEvent.prototype.setType = function (t) {\n    this.type = t;\n  };\n  /**\n   * Set the data associated with the event. May be a string or array of byte\n   * values.\n   *\n   * @param {string|Array} d - Event data.\n   */\n\n\n  MetaEvent.prototype.setData = function (d) {\n    this.data = d;\n  };\n  /**\n   * Serialize the event to an array of bytes.\n   *\n   * @returns {Array} The array of serialized bytes.\n   */\n\n\n  MetaEvent.prototype.toBytes = function () {\n    if (!this.type) {\n      throw new Error(\"Type for meta-event not specified.\");\n    }\n\n    var byteArray = [];\n    byteArray.push.apply(byteArray, this.time);\n    byteArray.push(0xFF, this.type); // If data is an array, we assume that it contains several bytes. We\n    // apend them to byteArray.\n\n    if (Array.isArray(this.data)) {\n      byteArray.push(this.data.length);\n      byteArray.push.apply(byteArray, this.data);\n    } else if (typeof this.data == 'number') {\n      byteArray.push(1, this.data);\n    } else if (this.data !== null && this.data !== undefined) {\n      // assume string; may be a bad assumption\n      byteArray.push(this.data.length);\n      var dataBytes = this.data.split('').map(function (x) {\n        return x.charCodeAt(0);\n      });\n      byteArray.push.apply(byteArray, dataBytes);\n    } else {\n      byteArray.push(0);\n    }\n\n    return byteArray;\n  };\n  /* ******************************************************************\n   * Track class\n   ****************************************************************** */\n\n  /**\n   * Construct a MIDI track.\n   *\n   * Parameters include:\n   *  - events [optional array] - Array of events for the track.\n   */\n\n\n  var Track = function Track(config) {\n    if (!this) return new Track(config);\n    var c = config || {};\n    this.events = c.events || [];\n  };\n\n  Track.START_BYTES = [0x4d, 0x54, 0x72, 0x6b];\n  Track.END_BYTES = [0x00, 0xFF, 0x2F, 0x00];\n  /**\n   * Add an event to the track.\n   *\n   * @param {MidiEvent|MetaEvent} event - The event to add.\n   * @returns {Track} The current track.\n   */\n\n  Track.prototype.addEvent = function (event) {\n    this.events.push(event);\n    return this;\n  };\n  /**\n   * Add a note-on event to the track.\n   *\n   * @param {number} channel - The channel to add the event to.\n   * @param {number|string} pitch - The pitch of the note, either numeric or\n   * symbolic.\n   * @param {number} [time=0] - The number of ticks since the previous event,\n   * defaults to 0.\n   * @param {number} [velocity=90] - The volume for the note, defaults to\n   * DEFAULT_VOLUME.\n   * @returns {Track} The current track.\n   */\n\n\n  Track.prototype.addNoteOn = Track.prototype.noteOn = function (channel, pitch, time, velocity) {\n    this.events.push(new MidiEvent({\n      type: MidiEvent.NOTE_ON,\n      channel: channel,\n      param1: Util.ensureMidiPitch(pitch),\n      param2: velocity || DEFAULT_VOLUME,\n      time: time || 0\n    }));\n    return this;\n  };\n  /**\n   * Add a note-off event to the track.\n   *\n   * @param {number} channel - The channel to add the event to.\n   * @param {number|string} pitch - The pitch of the note, either numeric or\n   * symbolic.\n   * @param {number} [time=0] - The number of ticks since the previous event,\n   * defaults to 0.\n   * @param {number} [velocity=90] - The velocity the note was released,\n   * defaults to DEFAULT_VOLUME.\n   * @returns {Track} The current track.\n   */\n\n\n  Track.prototype.addNoteOff = Track.prototype.noteOff = function (channel, pitch, time, velocity) {\n    this.events.push(new MidiEvent({\n      type: MidiEvent.NOTE_OFF,\n      channel: channel,\n      param1: Util.ensureMidiPitch(pitch),\n      param2: velocity || DEFAULT_VOLUME,\n      time: time || 0\n    }));\n    return this;\n  };\n  /**\n   * Add a note-on and -off event to the track.\n   *\n   * @param {number} channel - The channel to add the event to.\n   * @param {number|string} pitch - The pitch of the note, either numeric or\n   * symbolic.\n   * @param {number} dur - The duration of the note, in ticks.\n   * @param {number} [time=0] - The number of ticks since the previous event,\n   * defaults to 0.\n   * @param {number} [velocity=90] - The velocity the note was released,\n   * defaults to DEFAULT_VOLUME.\n   * @returns {Track} The current track.\n   */\n\n\n  Track.prototype.addNote = Track.prototype.note = function (channel, pitch, dur, time, velocity) {\n    this.noteOn(channel, pitch, time, velocity);\n\n    if (dur) {\n      this.noteOff(channel, pitch, dur, velocity);\n    }\n\n    return this;\n  };\n  /**\n   * Add a note-on and -off event to the track for each pitch in an array of pitches.\n   *\n   * @param {number} channel - The channel to add the event to.\n   * @param {array} chord - An array of pitches, either numeric or\n   * symbolic.\n   * @param {number} dur - The duration of the chord, in ticks.\n   * @param {number} [velocity=90] - The velocity of the chord,\n   * defaults to DEFAULT_VOLUME.\n   * @returns {Track} The current track.\n   */\n\n\n  Track.prototype.addChord = Track.prototype.chord = function (channel, chord, dur, velocity) {\n    if (!Array.isArray(chord) && !chord.length) {\n      throw new Error('Chord must be an array of pitches');\n    }\n\n    chord.forEach(function (note) {\n      this.noteOn(channel, note, 0, velocity);\n    }, this);\n    chord.forEach(function (note, index) {\n      if (index === 0) {\n        this.noteOff(channel, note, dur);\n      } else {\n        this.noteOff(channel, note);\n      }\n    }, this);\n    return this;\n  };\n  /**\n   * Set instrument for the track.\n   *\n   * @param {number} channel - The channel to set the instrument on.\n   * @param {number} instrument - The instrument to set it to.\n   * @param {number} [time=0] - The number of ticks since the previous event,\n   * defaults to 0.\n   * @returns {Track} The current track.\n   */\n\n\n  Track.prototype.setInstrument = Track.prototype.instrument = function (channel, instrument, time) {\n    this.events.push(new MidiEvent({\n      type: MidiEvent.PROGRAM_CHANGE,\n      channel: channel,\n      param1: instrument,\n      time: time || 0\n    }));\n    return this;\n  };\n  /**\n   * Set the tempo for the track.\n   *\n   * @param {number} bpm - The new number of beats per minute.\n   * @param {number} [time=0] - The number of ticks since the previous event,\n   * defaults to 0.\n   * @returns {Track} The current track.\n   */\n\n\n  Track.prototype.setTempo = Track.prototype.tempo = function (bpm, time) {\n    this.events.push(new MetaEvent({\n      type: MetaEvent.TEMPO,\n      data: Util.mpqnFromBpm(bpm),\n      time: time || 0\n    }));\n    return this;\n  };\n  /**\n   * Serialize the track to an array of bytes.\n   *\n   * @returns {Array} The array of serialized bytes.\n   */\n\n\n  Track.prototype.toBytes = function () {\n    var trackLength = 0;\n    var eventBytes = [];\n    var startBytes = Track.START_BYTES;\n    var endBytes = Track.END_BYTES;\n\n    var addEventBytes = function addEventBytes(event) {\n      var bytes = event.toBytes();\n      trackLength += bytes.length;\n      eventBytes.push.apply(eventBytes, bytes);\n    };\n\n    this.events.forEach(addEventBytes); // Add the end-of-track bytes to the sum of bytes for the track, since\n    // they are counted (unlike the start-of-track ones).\n\n    trackLength += endBytes.length; // Makes sure that track length will fill up 4 bytes with 0s in case\n    // the length is less than that (the usual case).\n\n    var lengthBytes = Util.str2Bytes(trackLength.toString(16), 4);\n    return startBytes.concat(lengthBytes, eventBytes, endBytes);\n  };\n  /* ******************************************************************\n   * File class\n   ****************************************************************** */\n\n  /**\n   * Construct a file object.\n   *\n   * Parameters include:\n   *  - ticks [optional number] - Number of ticks per beat, defaults to 128.\n   *    Must be 1-32767.\n   *  - tracks [optional array] - Track data.\n   */\n\n\n  var File = function File(config) {\n    if (!this) return new File(config);\n    var c = config || {};\n\n    if (c.ticks) {\n      if (typeof c.ticks !== 'number') {\n        throw new Error('Ticks per beat must be a number!');\n        return;\n      }\n\n      if (c.ticks <= 0 || c.ticks >= 1 << 15 || c.ticks % 1 !== 0) {\n        throw new Error('Ticks per beat must be an integer between 1 and 32767!');\n        return;\n      }\n    }\n\n    this.ticks = c.ticks || 128;\n    this.tracks = c.tracks || [];\n  };\n\n  File.HDR_CHUNKID = \"MThd\"; // File magic cookie\n\n  File.HDR_CHUNK_SIZE = \"\\x00\\x00\\x00\\x06\"; // Header length for SMF\n\n  File.HDR_TYPE0 = \"\\x00\\x00\"; // Midi Type 0 id\n\n  File.HDR_TYPE1 = \"\\x00\\x01\"; // Midi Type 1 id\n\n  /**\n   * Add a track to the file.\n   *\n   * @param {Track} track - The track to add.\n   */\n\n  File.prototype.addTrack = function (track) {\n    if (track) {\n      this.tracks.push(track);\n      return this;\n    } else {\n      track = new Track();\n      this.tracks.push(track);\n      return track;\n    }\n  };\n  /**\n   * Serialize the MIDI file to an array of bytes.\n   *\n   * @returns {Array} The array of serialized bytes.\n   */\n\n\n  File.prototype.toBytes = function () {\n    var trackCount = this.tracks.length.toString(16); // prepare the file header\n\n    var bytes = File.HDR_CHUNKID + File.HDR_CHUNK_SIZE; // set Midi type based on number of tracks\n\n    if (parseInt(trackCount, 16) > 1) {\n      bytes += File.HDR_TYPE1;\n    } else {\n      bytes += File.HDR_TYPE0;\n    } // add the number of tracks (2 bytes)\n\n\n    bytes += Util.codes2Str(Util.str2Bytes(trackCount, 2)); // add the number of ticks per beat (currently hardcoded)\n\n    bytes += String.fromCharCode(this.ticks / 256, this.ticks % 256);\n    ; // iterate over the tracks, converting to bytes too\n\n    this.tracks.forEach(function (track) {\n      bytes += Util.codes2Str(track.toBytes());\n    });\n    return bytes;\n  };\n  /* ******************************************************************\n   * Exports\n   ****************************************************************** */\n\n\n  exported.Util = Util;\n  exported.File = File;\n  exported.Track = Track;\n  exported.Event = MidiEvent;\n  exported.MetaEvent = MetaEvent;\n})(Midi);\n\nif (typeof module != 'undefined' && module !== null) {\n  module.exports = Midi;\n} else if (typeof exports != 'undefined' && exports !== null) {\n  exports = Midi;\n} else {\n  this.Midi = Midi;\n}","map":null,"metadata":{},"sourceType":"script"}