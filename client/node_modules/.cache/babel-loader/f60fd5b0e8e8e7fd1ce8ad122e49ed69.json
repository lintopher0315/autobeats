{"ast":null,"code":"import _classCallCheck from \"/home/christopher/Documents/autobeats/autobeats/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/christopher/Documents/autobeats/autobeats/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as Decoder from 'midi-file-parser';\nimport * as Encoder from 'jsmidgen';\nimport * as Util from './Util';\nimport { Track } from './Track';\nimport { parseHeader } from './Header';\n/**\n * @class The Midi object. Contains tracks and the header info.\n */\n\nvar Midi =\n/*#__PURE__*/\nfunction () {\n  _createClass(Midi, null, [{\n    key: \"fromJSON\",\n\n    /**\n     * Convert JSON to Midi object\n     * @param {object} json\n     * @static\n     * @returns {Midi}\n     */\n    value: function fromJSON(json) {\n      var midi = new Midi();\n      midi.header = json.header;\n      json.tracks.forEach(function (track) {\n        var newTrack = Track.fromJSON(track);\n        midi.tracks.push(newTrack);\n      });\n      return midi;\n    }\n  }]);\n\n  function Midi() {\n    _classCallCheck(this, Midi);\n\n    this.header = {\n      //defaults\n      bpm: 120,\n      timeSignature: [4, 4],\n      PPQ: 480\n    };\n    this.tracks = [];\n  }\n  /**\n   * Load the given url and parse the midi at that url\n   * @param  {String}   url\n   * @param {*} data Anything that should be sent in the XHR\n   * @param {String} method Either GET or POST\n   * @return {Promise}\n   */\n\n\n  _createClass(Midi, [{\n    key: \"load\",\n    value: function load(url) {\n      var _this = this;\n\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'GET';\n      return new Promise(function (success, fail) {\n        var request = new XMLHttpRequest();\n        request.open(method, url);\n        request.responseType = 'arraybuffer'; // decode asynchronously\n\n        request.addEventListener('load', function () {\n          if (request.readyState === 4 && request.status === 200) {\n            success(_this.decode(request.response));\n          } else {\n            fail(request.status);\n          }\n        });\n        request.addEventListener('error', fail);\n        request.send(data);\n      }).catch(function (error) {\n        console.log(error);\n      });\n    }\n    /**\n     * Decode the bytes\n     * @param  {String|ArrayBuffer} bytes The midi file encoded as a string or ArrayBuffer\n     * @return {Midi}       this\n     */\n\n  }, {\n    key: \"decode\",\n    value: function decode(bytes) {\n      var _this2 = this;\n\n      if (bytes instanceof ArrayBuffer) {\n        var byteArray = new Uint8Array(bytes);\n        bytes = String.fromCharCode.apply(null, byteArray);\n      }\n\n      var midiData = Decoder(bytes);\n      this.header = parseHeader(midiData); //replace the previous tracks\n\n      this.tracks = [];\n      midiData.tracks.forEach(function (trackData, i) {\n        var track = new Track();\n        track.id = i;\n\n        _this2.tracks.push(track);\n\n        var absoluteTime = 0;\n        trackData.forEach(function (event) {\n          absoluteTime += Util.ticksToSeconds(event.deltaTime, _this2.header);\n\n          if (event.type === 'meta' && event.subtype === 'trackName') {\n            track.name = Util.cleanName(event.text);\n          } else if (event.subtype === 'noteOn') {\n            track.noteOn(event.noteNumber, absoluteTime, event.velocity / 127);\n\n            if (track.channelNumber === -1) {\n              track.channelNumber = event.channel;\n            }\n          } else if (event.subtype === 'noteOff') {\n            track.noteOff(event.noteNumber, absoluteTime);\n          } else if (event.subtype === 'controller' && event.controllerType) {\n            track.cc(event.controllerType, absoluteTime, event.value / 127);\n          } else if (event.type === 'meta' && event.subtype === 'instrumentName') {\n            track.instrument = event.text;\n          } else if (event.type === 'channel' && event.subtype === 'programChange') {\n            track.patch(event.programNumber);\n            track.channelNumber = event.channel;\n          }\n        }); //if the track is empty, then it is the file name\n\n        if (!_this2.header.name && !track.length && track.name) {\n          _this2.header.name = track.name;\n        }\n      });\n      return this;\n    }\n    /**\n     * Encode the Midi object as a Buffer String\n     * @returns {String}\n     */\n\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      var _this3 = this;\n\n      var output = new Encoder.File({\n        ticks: this.header.PPQ\n      });\n      var firstEmptyTrack = this.tracks.filter(function (track) {\n        return !track.length;\n      })[0];\n\n      if (this.header.name && !(firstEmptyTrack && firstEmptyTrack.name === this.header.name)) {\n        var track = output.addTrack();\n        track.addEvent(new Encoder.MetaEvent({\n          time: 0,\n          type: Encoder.MetaEvent.TRACK_NAME,\n          data: this.header.name\n        }));\n      }\n\n      this.tracks.forEach(function (track) {\n        var trackEncoder = output.addTrack();\n        trackEncoder.setTempo(_this3.bpm);\n\n        if (track.name) {\n          trackEncoder.addEvent(new Encoder.MetaEvent({\n            time: 0,\n            type: Encoder.MetaEvent.TRACK_NAME,\n            data: track.name\n          }));\n        }\n\n        track.encode(trackEncoder, _this3.header);\n      });\n      return output.toBytes();\n    }\n    /**\n     * Convert the output encoding into an Array\n     * @return {Array}\n     */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var encodedStr = this.encode();\n      var buffer = new Array(encodedStr.length);\n\n      for (var i = 0; i < encodedStr.length; i++) {\n        buffer[i] = encodedStr.charCodeAt(i);\n      }\n\n      return buffer;\n    }\n    /**\n     *  Convert all of the fields to JSON\n     *  @return  {Object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var ret = {\n        header: this.header,\n        startTime: this.startTime,\n        duration: this.duration,\n        tracks: (this.tracks || []).map(function (track) {\n          return track.toJSON();\n        })\n      };\n      if (!ret.header.name) ret.header.name = '';\n      return ret;\n    }\n    /**\n     * Add a new track.\n     * @param {String=} name Optionally include the name of the track\n     * @returns {Track}\n     */\n\n  }, {\n    key: \"track\",\n    value: function track(name) {\n      var track = new Track(name);\n      this.tracks.push(track);\n      return track;\n    }\n    /**\n     * Get a track either by it's name or track index\n     * @param  {Number|String} trackName\n     * @return {Track}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(trackName) {\n      if (Util.isNumber(trackName)) {\n        return this.tracks[trackName];\n      } else {\n        return this.tracks.find(function (t) {\n          return t.name === trackName;\n        });\n      }\n    }\n    /**\n     * Slice the midi file between the startTime and endTime. Returns a copy of the\n     * midi\n     * @param {Number} startTime\n     * @param {Number} endTime\n     * @returns {Midi} this\n     */\n\n  }, {\n    key: \"slice\",\n    value: function slice() {\n      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var endTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n      var midi = new Midi();\n      midi.header = this.header;\n      midi.tracks = this.tracks.map(function (t) {\n        return t.slice(startTime, endTime);\n      });\n      return midi;\n    }\n    /**\n     * the time of the first event\n     * @type {Number}\n     */\n\n  }, {\n    key: \"startTime\",\n    get: function get() {\n      var startTimes = this.tracks.map(function (t) {\n        return t.startTime;\n      });\n      if (!startTimes.length) return 0;\n      return Math.min.apply(Math, startTimes) || 0;\n    }\n    /**\n     * The bpm of the midi file in beats per minute\n     * @type {Number}\n     */\n\n  }, {\n    key: \"bpm\",\n    get: function get() {\n      return this.header.bpm;\n    },\n    set: function set(bpm) {\n      var prevTempo = this.header.bpm;\n      this.header.bpm = bpm; //adjust the timing of all the notes\n\n      var ratio = prevTempo / bpm;\n      this.tracks.forEach(function (track) {\n        return track.scale(ratio);\n      });\n    }\n    /**\n     * The timeSignature of the midi file\n     * @type {Array}\n     */\n\n  }, {\n    key: \"timeSignature\",\n    get: function get() {\n      return this.header.timeSignature;\n    },\n    set: function set(timeSig) {\n      this.header.timeSignature = timeSig;\n    }\n    /**\n     * The duration is the end time of the longest track\n     * @type {Number}\n     */\n\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var durations = this.tracks.map(function (t) {\n        return t.duration;\n      });\n      if (!durations.length) return 0;\n      return Math.max.apply(Math, durations) || 0;\n    }\n  }]);\n\n  return Midi;\n}();\n\nexport { Midi };","map":null,"metadata":{},"sourceType":"module"}