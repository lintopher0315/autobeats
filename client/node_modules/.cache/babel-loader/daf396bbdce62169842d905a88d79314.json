{"ast":null,"code":"\"use strict\";\n\nvar compile = require(\"cwise-compiler\");\n\nvar EmptyProc = {\n  body: \"\",\n  args: [],\n  thisVars: [],\n  localVars: []\n};\n\nfunction fixup(x) {\n  if (!x) {\n    return EmptyProc;\n  }\n\n  for (var i = 0; i < x.args.length; ++i) {\n    var a = x.args[i];\n\n    if (i === 0) {\n      x.args[i] = {\n        name: a,\n        lvalue: true,\n        rvalue: !!x.rvalue,\n        count: x.count || 1\n      };\n    } else {\n      x.args[i] = {\n        name: a,\n        lvalue: false,\n        rvalue: true,\n        count: 1\n      };\n    }\n  }\n\n  if (!x.thisVars) {\n    x.thisVars = [];\n  }\n\n  if (!x.localVars) {\n    x.localVars = [];\n  }\n\n  return x;\n}\n\nfunction pcompile(user_args) {\n  return compile({\n    args: user_args.args,\n    pre: fixup(user_args.pre),\n    body: fixup(user_args.body),\n    post: fixup(user_args.proc),\n    funcName: user_args.funcName\n  });\n}\n\nfunction makeOp(user_args) {\n  var args = [];\n\n  for (var i = 0; i < user_args.args.length; ++i) {\n    args.push(\"a\" + i);\n  }\n\n  var wrapper = new Function(\"P\", [\"return function \", user_args.funcName, \"_ndarrayops(\", args.join(\",\"), \") {P(\", args.join(\",\"), \");return a0}\"].join(\"\"));\n  return wrapper(pcompile(user_args));\n}\n\nvar assign_ops = {\n  add: \"+\",\n  sub: \"-\",\n  mul: \"*\",\n  div: \"/\",\n  mod: \"%\",\n  band: \"&\",\n  bor: \"|\",\n  bxor: \"^\",\n  lshift: \"<<\",\n  rshift: \">>\",\n  rrshift: \">>>\"\n};\n\n(function () {\n  for (var id in assign_ops) {\n    var op = assign_ops[id];\n    exports[id] = makeOp({\n      args: [\"array\", \"array\", \"array\"],\n      body: {\n        args: [\"a\", \"b\", \"c\"],\n        body: \"a=b\" + op + \"c\"\n      },\n      funcName: id\n    });\n    exports[id + \"eq\"] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a\" + op + \"=b\"\n      },\n      rvalue: true,\n      funcName: id + \"eq\"\n    });\n    exports[id + \"s\"] = makeOp({\n      args: [\"array\", \"array\", \"scalar\"],\n      body: {\n        args: [\"a\", \"b\", \"s\"],\n        body: \"a=b\" + op + \"s\"\n      },\n      funcName: id + \"s\"\n    });\n    exports[id + \"seq\"] = makeOp({\n      args: [\"array\", \"scalar\"],\n      body: {\n        args: [\"a\", \"s\"],\n        body: \"a\" + op + \"=s\"\n      },\n      rvalue: true,\n      funcName: id + \"seq\"\n    });\n  }\n})();\n\nvar unary_ops = {\n  not: \"!\",\n  bnot: \"~\",\n  neg: \"-\",\n  recip: \"1.0/\"\n};\n\n(function () {\n  for (var id in unary_ops) {\n    var op = unary_ops[id];\n    exports[id] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a=\" + op + \"b\"\n      },\n      funcName: id\n    });\n    exports[id + \"eq\"] = makeOp({\n      args: [\"array\"],\n      body: {\n        args: [\"a\"],\n        body: \"a=\" + op + \"a\"\n      },\n      rvalue: true,\n      count: 2,\n      funcName: id + \"eq\"\n    });\n  }\n})();\n\nvar binary_ops = {\n  and: \"&&\",\n  or: \"||\",\n  eq: \"===\",\n  neq: \"!==\",\n  lt: \"<\",\n  gt: \">\",\n  leq: \"<=\",\n  geq: \">=\"\n};\n\n(function () {\n  for (var id in binary_ops) {\n    var op = binary_ops[id];\n    exports[id] = makeOp({\n      args: [\"array\", \"array\", \"array\"],\n      body: {\n        args: [\"a\", \"b\", \"c\"],\n        body: \"a=b\" + op + \"c\"\n      },\n      funcName: id\n    });\n    exports[id + \"s\"] = makeOp({\n      args: [\"array\", \"array\", \"scalar\"],\n      body: {\n        args: [\"a\", \"b\", \"s\"],\n        body: \"a=b\" + op + \"s\"\n      },\n      funcName: id + \"s\"\n    });\n    exports[id + \"eq\"] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a=a\" + op + \"b\"\n      },\n      rvalue: true,\n      count: 2,\n      funcName: id + \"eq\"\n    });\n    exports[id + \"seq\"] = makeOp({\n      args: [\"array\", \"scalar\"],\n      body: {\n        args: [\"a\", \"s\"],\n        body: \"a=a\" + op + \"s\"\n      },\n      rvalue: true,\n      count: 2,\n      funcName: id + \"seq\"\n    });\n  }\n})();\n\nvar math_unary = [\"abs\", \"acos\", \"asin\", \"atan\", \"ceil\", \"cos\", \"exp\", \"floor\", \"log\", \"round\", \"sin\", \"sqrt\", \"tan\"];\n\n(function () {\n  for (var i = 0; i < math_unary.length; ++i) {\n    var f = math_unary[i];\n    exports[f] = makeOp({\n      args: [\"array\", \"array\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a=this_f(b)\",\n        thisVars: [\"this_f\"]\n      },\n      funcName: f\n    });\n    exports[f + \"eq\"] = makeOp({\n      args: [\"array\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\"],\n        body: \"a=this_f(a)\",\n        thisVars: [\"this_f\"]\n      },\n      rvalue: true,\n      count: 2,\n      funcName: f + \"eq\"\n    });\n  }\n})();\n\nvar math_comm = [\"max\", \"min\", \"atan2\", \"pow\"];\n\n(function () {\n  for (var i = 0; i < math_comm.length; ++i) {\n    var f = math_comm[i];\n    exports[f] = makeOp({\n      args: [\"array\", \"array\", \"array\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\", \"b\", \"c\"],\n        body: \"a=this_f(b,c)\",\n        thisVars: [\"this_f\"]\n      },\n      funcName: f\n    });\n    exports[f + \"s\"] = makeOp({\n      args: [\"array\", \"array\", \"scalar\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\", \"b\", \"c\"],\n        body: \"a=this_f(b,c)\",\n        thisVars: [\"this_f\"]\n      },\n      funcName: f + \"s\"\n    });\n    exports[f + \"eq\"] = makeOp({\n      args: [\"array\", \"array\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a=this_f(a,b)\",\n        thisVars: [\"this_f\"]\n      },\n      rvalue: true,\n      count: 2,\n      funcName: f + \"eq\"\n    });\n    exports[f + \"seq\"] = makeOp({\n      args: [\"array\", \"scalar\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a=this_f(a,b)\",\n        thisVars: [\"this_f\"]\n      },\n      rvalue: true,\n      count: 2,\n      funcName: f + \"seq\"\n    });\n  }\n})();\n\nvar math_noncomm = [\"atan2\", \"pow\"];\n\n(function () {\n  for (var i = 0; i < math_noncomm.length; ++i) {\n    var f = math_noncomm[i];\n    exports[f + \"op\"] = makeOp({\n      args: [\"array\", \"array\", \"array\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\", \"b\", \"c\"],\n        body: \"a=this_f(c,b)\",\n        thisVars: [\"this_f\"]\n      },\n      funcName: f + \"op\"\n    });\n    exports[f + \"ops\"] = makeOp({\n      args: [\"array\", \"array\", \"scalar\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\", \"b\", \"c\"],\n        body: \"a=this_f(c,b)\",\n        thisVars: [\"this_f\"]\n      },\n      funcName: f + \"ops\"\n    });\n    exports[f + \"opeq\"] = makeOp({\n      args: [\"array\", \"array\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a=this_f(b,a)\",\n        thisVars: [\"this_f\"]\n      },\n      rvalue: true,\n      count: 2,\n      funcName: f + \"opeq\"\n    });\n    exports[f + \"opseq\"] = makeOp({\n      args: [\"array\", \"scalar\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.\" + f,\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a=this_f(b,a)\",\n        thisVars: [\"this_f\"]\n      },\n      rvalue: true,\n      count: 2,\n      funcName: f + \"opseq\"\n    });\n  }\n})();\n\nexports.any = compile({\n  args: [\"array\"],\n  pre: EmptyProc,\n  body: {\n    args: [{\n      name: \"a\",\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }],\n    body: \"if(a){return true}\",\n    localVars: [],\n    thisVars: []\n  },\n  post: {\n    args: [],\n    localVars: [],\n    thisVars: [],\n    body: \"return false\"\n  },\n  funcName: \"any\"\n});\nexports.all = compile({\n  args: [\"array\"],\n  pre: EmptyProc,\n  body: {\n    args: [{\n      name: \"x\",\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }],\n    body: \"if(!x){return false}\",\n    localVars: [],\n    thisVars: []\n  },\n  post: {\n    args: [],\n    localVars: [],\n    thisVars: [],\n    body: \"return true\"\n  },\n  funcName: \"all\"\n});\nexports.sum = compile({\n  args: [\"array\"],\n  pre: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"this_s=0\"\n  },\n  body: {\n    args: [{\n      name: \"a\",\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }],\n    body: \"this_s+=a\",\n    localVars: [],\n    thisVars: [\"this_s\"]\n  },\n  post: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"return this_s\"\n  },\n  funcName: \"sum\"\n});\nexports.prod = compile({\n  args: [\"array\"],\n  pre: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"this_s=1\"\n  },\n  body: {\n    args: [{\n      name: \"a\",\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }],\n    body: \"this_s*=a\",\n    localVars: [],\n    thisVars: [\"this_s\"]\n  },\n  post: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"return this_s\"\n  },\n  funcName: \"prod\"\n});\nexports.norm2squared = compile({\n  args: [\"array\"],\n  pre: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"this_s=0\"\n  },\n  body: {\n    args: [{\n      name: \"a\",\n      lvalue: false,\n      rvalue: true,\n      count: 2\n    }],\n    body: \"this_s+=a*a\",\n    localVars: [],\n    thisVars: [\"this_s\"]\n  },\n  post: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"return this_s\"\n  },\n  funcName: \"norm2squared\"\n});\nexports.norm2 = compile({\n  args: [\"array\"],\n  pre: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"this_s=0\"\n  },\n  body: {\n    args: [{\n      name: \"a\",\n      lvalue: false,\n      rvalue: true,\n      count: 2\n    }],\n    body: \"this_s+=a*a\",\n    localVars: [],\n    thisVars: [\"this_s\"]\n  },\n  post: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"return Math.sqrt(this_s)\"\n  },\n  funcName: \"norm2\"\n});\nexports.norminf = compile({\n  args: [\"array\"],\n  pre: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"this_s=0\"\n  },\n  body: {\n    args: [{\n      name: \"a\",\n      lvalue: false,\n      rvalue: true,\n      count: 4\n    }],\n    body: \"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}\",\n    localVars: [],\n    thisVars: [\"this_s\"]\n  },\n  post: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"return this_s\"\n  },\n  funcName: \"norminf\"\n});\nexports.norm1 = compile({\n  args: [\"array\"],\n  pre: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"this_s=0\"\n  },\n  body: {\n    args: [{\n      name: \"a\",\n      lvalue: false,\n      rvalue: true,\n      count: 3\n    }],\n    body: \"this_s+=a<0?-a:a\",\n    localVars: [],\n    thisVars: [\"this_s\"]\n  },\n  post: {\n    args: [],\n    localVars: [],\n    thisVars: [\"this_s\"],\n    body: \"return this_s\"\n  },\n  funcName: \"norm1\"\n});\nexports.sup = compile({\n  args: [\"array\"],\n  pre: {\n    body: \"this_h=-Infinity\",\n    args: [],\n    thisVars: [\"this_h\"],\n    localVars: []\n  },\n  body: {\n    body: \"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_\",\n    args: [{\n      \"name\": \"_inline_1_arg0_\",\n      \"lvalue\": false,\n      \"rvalue\": true,\n      \"count\": 2\n    }],\n    thisVars: [\"this_h\"],\n    localVars: []\n  },\n  post: {\n    body: \"return this_h\",\n    args: [],\n    thisVars: [\"this_h\"],\n    localVars: []\n  }\n});\nexports.inf = compile({\n  args: [\"array\"],\n  pre: {\n    body: \"this_h=Infinity\",\n    args: [],\n    thisVars: [\"this_h\"],\n    localVars: []\n  },\n  body: {\n    body: \"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_\",\n    args: [{\n      \"name\": \"_inline_1_arg0_\",\n      \"lvalue\": false,\n      \"rvalue\": true,\n      \"count\": 2\n    }],\n    thisVars: [\"this_h\"],\n    localVars: []\n  },\n  post: {\n    body: \"return this_h\",\n    args: [],\n    thisVars: [\"this_h\"],\n    localVars: []\n  }\n});\nexports.argmin = compile({\n  args: [\"index\", \"array\", \"shape\"],\n  pre: {\n    body: \"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args: [{\n      name: \"_inline_0_arg0_\",\n      lvalue: false,\n      rvalue: false,\n      count: 0\n    }, {\n      name: \"_inline_0_arg1_\",\n      lvalue: false,\n      rvalue: false,\n      count: 0\n    }, {\n      name: \"_inline_0_arg2_\",\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }],\n    thisVars: [\"this_i\", \"this_v\"],\n    localVars: []\n  },\n  body: {\n    body: \"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args: [{\n      name: \"_inline_1_arg0_\",\n      lvalue: false,\n      rvalue: true,\n      count: 2\n    }, {\n      name: \"_inline_1_arg1_\",\n      lvalue: false,\n      rvalue: true,\n      count: 2\n    }],\n    thisVars: [\"this_i\", \"this_v\"],\n    localVars: [\"_inline_1_k\"]\n  },\n  post: {\n    body: \"{return this_i}\",\n    args: [],\n    thisVars: [\"this_i\"],\n    localVars: []\n  }\n});\nexports.argmax = compile({\n  args: [\"index\", \"array\", \"shape\"],\n  pre: {\n    body: \"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args: [{\n      name: \"_inline_0_arg0_\",\n      lvalue: false,\n      rvalue: false,\n      count: 0\n    }, {\n      name: \"_inline_0_arg1_\",\n      lvalue: false,\n      rvalue: false,\n      count: 0\n    }, {\n      name: \"_inline_0_arg2_\",\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }],\n    thisVars: [\"this_i\", \"this_v\"],\n    localVars: []\n  },\n  body: {\n    body: \"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args: [{\n      name: \"_inline_1_arg0_\",\n      lvalue: false,\n      rvalue: true,\n      count: 2\n    }, {\n      name: \"_inline_1_arg1_\",\n      lvalue: false,\n      rvalue: true,\n      count: 2\n    }],\n    thisVars: [\"this_i\", \"this_v\"],\n    localVars: [\"_inline_1_k\"]\n  },\n  post: {\n    body: \"{return this_i}\",\n    args: [],\n    thisVars: [\"this_i\"],\n    localVars: []\n  }\n});\nexports.random = makeOp({\n  args: [\"array\"],\n  pre: {\n    args: [],\n    body: \"this_f=Math.random\",\n    thisVars: [\"this_f\"]\n  },\n  body: {\n    args: [\"a\"],\n    body: \"a=this_f()\",\n    thisVars: [\"this_f\"]\n  },\n  funcName: \"random\"\n});\nexports.assign = makeOp({\n  args: [\"array\", \"array\"],\n  body: {\n    args: [\"a\", \"b\"],\n    body: \"a=b\"\n  },\n  funcName: \"assign\"\n});\nexports.assigns = makeOp({\n  args: [\"array\", \"scalar\"],\n  body: {\n    args: [\"a\", \"b\"],\n    body: \"a=b\"\n  },\n  funcName: \"assigns\"\n});\nexports.equals = compile({\n  args: [\"array\", \"array\"],\n  pre: EmptyProc,\n  body: {\n    args: [{\n      name: \"x\",\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }, {\n      name: \"y\",\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }],\n    body: \"if(x!==y){return false}\",\n    localVars: [],\n    thisVars: []\n  },\n  post: {\n    args: [],\n    localVars: [],\n    thisVars: [],\n    body: \"return true\"\n  },\n  funcName: \"equals\"\n});","map":null,"metadata":{},"sourceType":"script"}