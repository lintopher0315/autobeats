{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar midiconvert = require(\"midiconvert\");\n\nvar protobuf_1 = require(\"../protobuf\");\n\nvar constants = require(\"./constants\");\n\nvar sequences = require(\"./sequences\");\n\nvar MidiConversionError = function (_super) {\n  __extends(MidiConversionError, _super);\n\n  function MidiConversionError(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, _newTarget.prototype);\n    return _this;\n  }\n\n  return MidiConversionError;\n}(Error);\n\nexports.MidiConversionError = MidiConversionError;\n\nfunction midiToSequenceProto(midi) {\n  var parsedMidi = midiconvert.parse(midi);\n  var ns = protobuf_1.NoteSequence.create();\n  ns.ticksPerQuarter = parsedMidi.header.PPQ;\n  ns.sourceInfo = protobuf_1.NoteSequence.SourceInfo.create({\n    parser: protobuf_1.NoteSequence.SourceInfo.Parser.TONEJS_MIDI_CONVERT,\n    encodingType: protobuf_1.NoteSequence.SourceInfo.EncodingType.MIDI\n  });\n\n  if (parsedMidi.header.timeSignature) {\n    ns.timeSignatures.push(protobuf_1.NoteSequence.TimeSignature.create({\n      time: 0,\n      numerator: parsedMidi.header.timeSignature[0],\n      denominator: parsedMidi.header.timeSignature[1]\n    }));\n  } else {\n    ns.timeSignatures.push(protobuf_1.NoteSequence.TimeSignature.create({\n      time: 0,\n      numerator: 4,\n      denominator: 4\n    }));\n  }\n\n  ns.tempos.push(protobuf_1.NoteSequence.Tempo.create({\n    time: 0,\n    qpm: parsedMidi.header.bpm\n  }));\n  var instrumentNumber = -1;\n\n  for (var _i = 0, _a = parsedMidi.tracks; _i < _a.length; _i++) {\n    var track = _a[_i];\n\n    if (track.notes.length > 0) {\n      instrumentNumber += 1;\n    }\n\n    for (var _b = 0, _c = track.notes; _b < _c.length; _b++) {\n      var note = _c[_b];\n      var startTime = note.time;\n      var duration = note.duration;\n      var endTime = startTime + duration;\n      ns.notes.push(protobuf_1.NoteSequence.Note.create({\n        instrument: instrumentNumber,\n        program: track.instrumentNumber,\n        startTime: startTime,\n        endTime: endTime,\n        pitch: note.midi,\n        velocity: Math.floor(note.velocity * constants.MIDI_VELOCITIES),\n        isDrum: track.isPercussion\n      }));\n\n      if (endTime > ns.totalTime) {\n        ns.totalTime = endTime;\n      }\n    }\n  }\n\n  return ns;\n}\n\nexports.midiToSequenceProto = midiToSequenceProto;\n\nfunction sequenceProtoToMidi(ns) {\n  if (sequences.isQuantizedSequence(ns)) {\n    ns = sequences.unquantizeSequence(ns);\n  }\n\n  if (!ns.tempos || ns.tempos.length === 0) {\n    ns.tempos = [{\n      time: 0,\n      qpm: constants.DEFAULT_QUARTERS_PER_MINUTE\n    }];\n  }\n\n  if (!ns.timeSignatures || ns.timeSignatures.length === 0) {\n    ns.timeSignatures = [{\n      time: 0,\n      numerator: 4,\n      denominator: 4\n    }];\n  }\n\n  if (ns.tempos.length !== 1 || ns.tempos[0].time !== 0) {\n    throw new MidiConversionError('NoteSequence must have exactly 1 tempo at time 0');\n  }\n\n  if (ns.timeSignatures.length !== 1 || ns.timeSignatures[0].time !== 0) {\n    throw new MidiConversionError('NoteSequence must have exactly 1 time signature at time 0');\n  }\n\n  var json = {\n    header: {\n      bpm: ns.tempos[0].qpm,\n      PPQ: ns.ticksPerQuarter ? ns.ticksPerQuarter : constants.DEFAULT_TICKS_PER_QUARTER,\n      timeSignature: [ns.timeSignatures[0].numerator, ns.timeSignatures[0].denominator]\n    },\n    tracks: []\n  };\n  var tracks = new Map();\n\n  for (var _i = 0, _a = ns.notes; _i < _a.length; _i++) {\n    var note = _a[_i];\n    var instrument = note.instrument ? note.instrument : 0;\n\n    if (!tracks.has(instrument)) {\n      tracks.set(instrument, []);\n    }\n\n    tracks.get(instrument).push(note);\n  }\n\n  var instruments = Array.from(tracks.keys()).sort(function (a, b) {\n    return a - b;\n  });\n\n  for (var i = 0; i < instruments.length; i++) {\n    if (i !== instruments[i]) {\n      throw new MidiConversionError('Instrument list must be continuous and start at 0');\n    }\n\n    var notes = tracks.get(i);\n    var track = {\n      id: i,\n      notes: [],\n      isPercussion: notes[0].isDrum === undefined ? false : notes[0].isDrum,\n      channelNumber: notes[0].isDrum ? constants.DRUM_CHANNEL : constants.DEFAULT_CHANNEL,\n      instrumentNumber: notes[0].program === undefined ? constants.DEFAULT_PROGRAM : notes[0].program\n    };\n    track.notes = notes.map(function (note) {\n      var velocity = note.velocity === undefined ? constants.DEFAULT_VELOCITY : note.velocity;\n      return {\n        midi: note.pitch,\n        time: note.startTime,\n        duration: note.endTime - note.startTime,\n        velocity: (velocity + 1) / constants.MIDI_VELOCITIES\n      };\n    });\n    json['tracks'].push(track);\n  }\n\n  return new Uint8Array(midiconvert.fromJSON(json).toArray());\n}\n\nexports.sequenceProtoToMidi = sequenceProtoToMidi;\n\nfunction urlToBlob(url) {\n  return new Promise(function (resolve, reject) {\n    fetch(url).then(function (response) {\n      return response.blob();\n    }).then(function (blob) {\n      resolve(blob);\n    }).catch(function (error) {\n      return reject(error);\n    });\n  });\n}\n\nexports.urlToBlob = urlToBlob;\n\nfunction blobToNoteSequence(blob) {\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader();\n\n    reader.onload = function (e) {\n      resolve(midiToSequenceProto(reader.result));\n    };\n\n    reader.onerror = function (e) {\n      return reject(e);\n    };\n\n    reader.readAsBinaryString(blob);\n  });\n}\n\nexports.blobToNoteSequence = blobToNoteSequence;\n\nfunction urlToNoteSequence(url) {\n  return urlToBlob(url).then(blobToNoteSequence);\n}\n\nexports.urlToNoteSequence = urlToNoteSequence;","map":null,"metadata":{},"sourceType":"script"}