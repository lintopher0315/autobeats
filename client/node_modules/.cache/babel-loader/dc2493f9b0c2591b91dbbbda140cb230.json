{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\"); // Extends EventEmitter\n\n\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n/**\r\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\r\n *\r\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\r\n * @typedef rpc.ServiceMethodCallback\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {TRes} [response] Response message\r\n * @returns {undefined}\r\n */\n\n/**\r\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\r\n * @typedef rpc.ServiceMethod\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\r\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\r\n */\n\n/**\r\n * Constructs a new RPC service instance.\r\n * @classdesc An RPC service as returned by {@link Service#create}.\r\n * @exports rpc.Service\r\n * @extends util.EventEmitter\r\n * @constructor\r\n * @param {RPCImpl} rpcImpl RPC implementation\r\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\r\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\r\n */\n\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n  if (typeof rpcImpl !== \"function\") throw TypeError(\"rpcImpl must be a function\");\n  util.EventEmitter.call(this);\n  /**\r\n   * RPC implementation. Becomes `null` once the service is ended.\r\n   * @type {RPCImpl|null}\r\n   */\n\n  this.rpcImpl = rpcImpl;\n  /**\r\n   * Whether requests are length-delimited.\r\n   * @type {boolean}\r\n   */\n\n  this.requestDelimited = Boolean(requestDelimited);\n  /**\r\n   * Whether responses are length-delimited.\r\n   * @type {boolean}\r\n   */\n\n  this.responseDelimited = Boolean(responseDelimited);\n}\n/**\r\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\r\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\r\n * @param {Constructor<TReq>} requestCtor Request constructor\r\n * @param {Constructor<TRes>} responseCtor Response constructor\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\r\n * @returns {undefined}\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n */\n\n\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n  if (!request) throw TypeError(\"request must be specified\");\n  var self = this;\n  if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n  if (!self.rpcImpl) {\n    setTimeout(function () {\n      callback(Error(\"already ended\"));\n    }, 0);\n    return undefined;\n  }\n\n  try {\n    return self.rpcImpl(method, requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(), function rpcCallback(err, response) {\n      if (err) {\n        self.emit(\"error\", err, method);\n        return callback(err);\n      }\n\n      if (response === null) {\n        self.end(\n        /* endedByRPC */\n        true);\n        return undefined;\n      }\n\n      if (!(response instanceof responseCtor)) {\n        try {\n          response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n        } catch (err) {\n          self.emit(\"error\", err, method);\n          return callback(err);\n        }\n      }\n\n      self.emit(\"data\", response, method);\n      return callback(null, response);\n    });\n  } catch (err) {\n    self.emit(\"error\", err, method);\n    setTimeout(function () {\n      callback(err);\n    }, 0);\n    return undefined;\n  }\n};\n/**\r\n * Ends this service and emits the `end` event.\r\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\r\n * @returns {rpc.Service} `this`\r\n */\n\n\nService.prototype.end = function end(endedByRPC) {\n  if (this.rpcImpl) {\n    if (!endedByRPC) // signal end to rpcImpl\n      this.rpcImpl(null, null, null);\n    this.rpcImpl = null;\n    this.emit(\"end\").off();\n  }\n\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}