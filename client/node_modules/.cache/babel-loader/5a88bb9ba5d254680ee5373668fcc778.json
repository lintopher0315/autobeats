{"ast":null,"code":"\"use strict\";\n\nvar fft = require(\"ndarray-fft\");\n\nvar pool = require(\"ndarray-scratch\");\n\nvar ops = require(\"ndarray-ops\");\n\nvar cwise = require(\"cwise\");\n\nvar clampScale = cwise({\n  args: [\"array\", \"array\", \"scalar\", \"scalar\", \"scalar\"],\n  body: function clampScale(out, inp, s, l, h) {\n    var x = inp * s;\n\n    if (x < l) {\n      x = l;\n    }\n\n    if (x > h) {\n      x = h;\n    }\n\n    out = x;\n  }\n});\n\nfunction resample(out, inp, clamp_lo, clamp_hi) {\n  if (typeof clamp_lo === \"undefined\") {\n    clamp_lo = -Infinity;\n  }\n\n  if (typeof clamp_hi === \"undefined\") {\n    clamp_hi = Infinity;\n  }\n\n  var ishp = inp.shape;\n  var oshp = out.shape;\n  if (inp.shape.length !== out.shape.length) throw new Error(\"ndarray-resample: input and output arrays should have the same dimensions\");\n  var v,\n      zeroInds = ishp.map(function () {\n    return 0;\n  });\n\n  if (out.size === 1) {\n    v = ops.sum(inp) / inp.size;\n\n    if (v < clamp_lo) {\n      v = clamp_lo;\n    }\n\n    if (v > clamp_hi) {\n      v = clamp_hi;\n    }\n\n    out.set.apply(out, zeroInds.concat(v));\n    return;\n  } else if (inp.size === 1) {\n    v = inp.get.apply(inp, zeroInds);\n\n    if (v < clamp_lo) {\n      v = clamp_lo;\n    }\n\n    if (v > clamp_hi) {\n      v = clamp_hi;\n    }\n\n    ops.assigns(out, v);\n    return;\n  }\n\n  var d = ishp.length;\n  var mshp = new Array(d),\n      initToZero = false;\n\n  for (var i = 0; i < d; i++) {\n    mshp[i] = Math.min(oshp[i], ishp[i]);\n    if (oshp[i] > ishp[i]) initToZero = true; // When upsampling, initialize the Fourier components of the output to zero\n  }\n\n  var x = pool.malloc(ishp),\n      y = pool.malloc(ishp);\n  ops.assign(x, inp);\n  ops.assigns(y, 0.0);\n  fft(1, x, y);\n  var lo = x.lo,\n      hi = x.hi;\n  var s = pool.malloc(oshp),\n      t = pool.malloc(oshp);\n\n  if (initToZero) {\n    ops.assigns(s, 0.0);\n    ops.assigns(t, 0.0);\n  }\n\n  var nr = new Array(d),\n      a = new Array(d),\n      b = new Array(d),\n      io = new Array(d);\n\n  for (var i = 0; i < 1 << d; ++i) {\n    // Iterate over the 2^d regions resulting from splitting up the indices in low frequencies above zero and low frequencies below zero (which turn up at the end of the arrays)\n    for (var j = 0; j < d; ++j) {\n      // Iterate over dimensions to determine correct starting indices and lengths\n      if (!(i & 1 << j)) {\n        // Take the positive frequencies for this dimension\n        nr[j] = mshp[j] + 1 >>> 1; // Take ceil(mshp[j]/2)) low frequencies (for example [0,1] for both mshp[j]==3 and mshp[j]==4)\n\n        a[j] = 0;\n        b[j] = 0;\n        io[j] = 0;\n      } else {\n        // Take the negative frequencies for this dimension\n        nr[j] = mshp[j] - (mshp[j] + 1 >>> 1); // Take the rest ([-1] for mshp[j]==3, and [-2,-1] for mshp[j]==4)\n\n        if (nr[j] === 0) {\n          continue;\n        }\n\n        a[j] = oshp[j] - nr[j];\n        b[j] = ishp[j] - nr[j]; // If mshp[j] is even, set the first imaginary values (along this dimension) to zero.\n        // For example, if mshp[j]==4, 2 and -2 correspond to the same frequency, and should be the average of the amplitudes for 2 and -2.\n        // Since the input is real, the Fourier transform has Hermitian symmetry, and we can simply take one or the other and set the corresponding imaginary coefficient(s) to zero.\n        // Note that when upsampling, this means that we get a asymmetric response (for example, -2, but not 2 has a non-zero weight), but this does not matter, since the weight is real anyway (again, given Hermitian symmetry).  \n\n        io[j] = mshp[j] & 1 ? 0 : 1;\n      }\n    }\n\n    ops.assign(hi.apply(lo.apply(s, a), nr), hi.apply(lo.apply(x, b), nr));\n    ops.assign(lo.apply(hi.apply(lo.apply(t, a), nr), io), lo.apply(hi.apply(lo.apply(y, b), nr), io));\n    ops.assigns(hi.apply(hi.apply(lo.apply(t, a), nr), io), 0.0);\n  }\n\n  fft(-1, s, t);\n  clampScale(out, s, out.size / inp.size, clamp_lo, clamp_hi);\n  pool.free(x);\n  pool.free(y);\n  pool.free(s);\n  pool.free(t);\n}\n\nmodule.exports = resample;","map":null,"metadata":{},"sourceType":"script"}