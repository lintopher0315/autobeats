{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs\");\n\nvar tonal_1 = require(\"tonal\");\n\nvar constants = require(\"./constants\");\n\nvar CHORD_QUALITY_INTERVALS = [['1P', '3M', '5P'], ['1P', '3m', '5P'], ['1P', '3M', '5A'], ['1P', '3m', '5d']];\nvar ChordQuality;\n\n(function (ChordQuality) {\n  ChordQuality[ChordQuality[\"Major\"] = 0] = \"Major\";\n  ChordQuality[ChordQuality[\"Minor\"] = 1] = \"Minor\";\n  ChordQuality[ChordQuality[\"Augmented\"] = 2] = \"Augmented\";\n  ChordQuality[ChordQuality[\"Diminished\"] = 3] = \"Diminished\";\n  ChordQuality[ChordQuality[\"Other\"] = 4] = \"Other\";\n})(ChordQuality = exports.ChordQuality || (exports.ChordQuality = {}));\n\nvar ChordSymbolException = function (_super) {\n  __extends(ChordSymbolException, _super);\n\n  function ChordSymbolException(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, _newTarget.prototype);\n    return _this;\n  }\n\n  return ChordSymbolException;\n}(Error);\n\nexports.ChordSymbolException = ChordSymbolException;\n\nvar ChordEncodingException = function (_super) {\n  __extends(ChordEncodingException, _super);\n\n  function ChordEncodingException(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, _newTarget.prototype);\n    return _this;\n  }\n\n  return ChordEncodingException;\n}(Error);\n\nexports.ChordEncodingException = ChordEncodingException;\n\nvar ChordSymbols = function () {\n  function ChordSymbols() {}\n\n  ChordSymbols.pitches = function (chord) {\n    var root = tonal_1.Chord.tokenize(chord)[0];\n\n    if (!root || !tonal_1.Chord.exists(chord)) {\n      throw new ChordSymbolException(\"Unrecognized chord symbol: \" + chord);\n    }\n\n    var notes = tonal_1.Chord.notes(chord);\n    return notes.map(tonal_1.Note.chroma);\n  };\n\n  ChordSymbols.root = function (chord) {\n    var root = tonal_1.Chord.tokenize(chord)[0];\n\n    if (!root) {\n      throw new ChordSymbolException(\"Chord symbol has unknown root: \" + chord);\n    }\n\n    return tonal_1.Note.chroma(root);\n  };\n\n  ChordSymbols.quality = function (chord) {\n    if (!tonal_1.Chord.exists(chord)) {\n      throw new ChordSymbolException(\"Unrecognized chord symbol: \" + chord);\n    }\n\n    var intervals = tonal_1.Chord.intervals(chord);\n    var qualities = CHORD_QUALITY_INTERVALS.map(function (cqis) {\n      return cqis.every(function (cqi) {\n        return intervals.includes(cqi);\n      });\n    });\n    var i = qualities.indexOf(true);\n    var j = qualities.lastIndexOf(true);\n\n    if (i >= 0 && i === j) {\n      return i;\n    } else {\n      return ChordQuality.Other;\n    }\n  };\n\n  return ChordSymbols;\n}();\n\nexports.ChordSymbols = ChordSymbols;\n\nvar ChordEncoder = function () {\n  function ChordEncoder() {}\n\n  ChordEncoder.prototype.encodeProgression = function (chords, numSteps) {\n    var _this = this;\n\n    var encodedChords = chords.map(function (chord) {\n      return _this.encode(chord);\n    });\n    var indices = Array.from(Array(numSteps).keys()).map(function (step) {\n      return Math.floor(step * encodedChords.length / numSteps);\n    });\n    return tf.stack(indices.map(function (i) {\n      return encodedChords[i];\n    }));\n  };\n\n  return ChordEncoder;\n}();\n\nexports.ChordEncoder = ChordEncoder;\n\nfunction chordEncoderFromType(type) {\n  switch (type) {\n    case 'MajorMinorChordEncoder':\n      return new MajorMinorChordEncoder();\n\n    case 'TriadChordEncoder':\n      return new TriadChordEncoder();\n\n    case 'PitchChordEncoder':\n      return new PitchChordEncoder();\n\n    default:\n      throw new Error(\"Unknown chord encoder type: \" + type);\n  }\n}\n\nexports.chordEncoderFromType = chordEncoderFromType;\n\nvar MajorMinorChordEncoder = function (_super) {\n  __extends(MajorMinorChordEncoder, _super);\n\n  function MajorMinorChordEncoder() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.depth = 1 + 2 * constants.NUM_PITCH_CLASSES;\n    return _this;\n  }\n\n  MajorMinorChordEncoder.prototype.index = function (chord) {\n    if (chord === constants.NO_CHORD) {\n      return 0;\n    }\n\n    var root = ChordSymbols.root(chord);\n    var quality = ChordSymbols.quality(chord);\n    var index = 1 + quality * constants.NUM_PITCH_CLASSES + root;\n\n    if (index >= this.depth) {\n      throw new ChordEncodingException(\"Chord is neither major nor minor: \" + chord);\n    }\n\n    return index;\n  };\n\n  MajorMinorChordEncoder.prototype.encode = function (chord) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      return tf.oneHot(tf.tensor1d([_this.index(chord)], 'int32'), _this.depth).as1D();\n    });\n  };\n\n  return MajorMinorChordEncoder;\n}(ChordEncoder);\n\nexports.MajorMinorChordEncoder = MajorMinorChordEncoder;\n\nvar TriadChordEncoder = function (_super) {\n  __extends(TriadChordEncoder, _super);\n\n  function TriadChordEncoder() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.depth = 1 + 4 * constants.NUM_PITCH_CLASSES;\n    return _this;\n  }\n\n  TriadChordEncoder.prototype.index = function (chord) {\n    if (chord === constants.NO_CHORD) {\n      return 0;\n    }\n\n    var root = ChordSymbols.root(chord);\n    var quality = ChordSymbols.quality(chord);\n    var index = 1 + quality * constants.NUM_PITCH_CLASSES + root;\n\n    if (index >= this.depth) {\n      throw new ChordEncodingException(\"Chord is not a standard triad: \" + chord);\n    }\n\n    return index;\n  };\n\n  TriadChordEncoder.prototype.encode = function (chord) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      return tf.oneHot(tf.tensor1d([_this.index(chord)], 'int32'), _this.depth).as1D();\n    });\n  };\n\n  return TriadChordEncoder;\n}(ChordEncoder);\n\nexports.TriadChordEncoder = TriadChordEncoder;\n\nvar PitchChordEncoder = function (_super) {\n  __extends(PitchChordEncoder, _super);\n\n  function PitchChordEncoder() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.depth = 1 + 3 * constants.NUM_PITCH_CLASSES;\n    return _this;\n  }\n\n  PitchChordEncoder.prototype.encode = function (chord) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      if (chord === constants.NO_CHORD) {\n        return tf.oneHot(tf.tensor1d([0], 'int32'), _this.depth).as1D();\n      }\n\n      var root = ChordSymbols.root(chord);\n      var rootEncoding = tf.oneHot(tf.tensor1d([root], 'int32'), constants.NUM_PITCH_CLASSES).as1D();\n      var pitchBuffer = tf.buffer([constants.NUM_PITCH_CLASSES]);\n      ChordSymbols.pitches(chord).forEach(function (pitch) {\n        return pitchBuffer.set(1.0, pitch);\n      });\n      var pitchEncoding = pitchBuffer.toTensor().as1D();\n      var bassEncoding = rootEncoding;\n      return tf.concat1d([tf.tensor1d([0.0]), rootEncoding, pitchEncoding, bassEncoding]);\n    });\n  };\n\n  return PitchChordEncoder;\n}(ChordEncoder);\n\nexports.PitchChordEncoder = PitchChordEncoder;","map":null,"metadata":{},"sourceType":"script"}