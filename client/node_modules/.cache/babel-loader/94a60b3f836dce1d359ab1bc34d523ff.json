{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar FFT = require(\"fft.js\");\n\nvar ndarray = require(\"ndarray\");\n\nvar resample = require(\"ndarray-resample\");\n\nvar logging = require(\"./logging\");\n\nvar WEBKIT_SAMPLE_RATE = 44100;\nvar SAMPLE_RATE = 16000;\nvar appeaseTsLintWindow = window;\nvar isSafari = appeaseTsLintWindow.webkitOfflineAudioContext;\nvar offlineCtx = isSafari ? new appeaseTsLintWindow.webkitOfflineAudioContext(1, WEBKIT_SAMPLE_RATE, WEBKIT_SAMPLE_RATE) : new appeaseTsLintWindow.OfflineAudioContext(1, SAMPLE_RATE, SAMPLE_RATE);\n\nfunction loadAudioFromUrl(url) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2, fetch(url).then(function (body) {\n        return body.arrayBuffer();\n      }).then(function (buffer) {\n        return offlineCtx.decodeAudioData(buffer);\n      })];\n    });\n  });\n}\n\nexports.loadAudioFromUrl = loadAudioFromUrl;\n\nfunction loadAudioFromFile(blob) {\n  return __awaiter(this, void 0, void 0, function () {\n    var fileReader, loadFile;\n    return __generator(this, function (_a) {\n      fileReader = new FileReader();\n      loadFile = new Promise(function (resolve, reject) {\n        fileReader.onerror = function () {\n          fileReader.abort();\n          reject(new DOMException('Something went wrong reading that file.'));\n        };\n\n        fileReader.onload = function () {\n          resolve(fileReader.result);\n        };\n\n        fileReader.readAsArrayBuffer(blob);\n      });\n      return [2, loadFile.then(function (arrayBuffer) {\n        return offlineCtx.decodeAudioData(arrayBuffer);\n      })];\n    });\n  });\n}\n\nexports.loadAudioFromFile = loadAudioFromFile;\n\nfunction melSpectrogram(y, params) {\n  if (!params.power) {\n    params.power = 2.0;\n  }\n\n  var stftMatrix = stft(y, params);\n\n  var _a = magSpectrogram(stftMatrix, params.power),\n      spec = _a[0],\n      nFft = _a[1];\n\n  params.nFft = nFft;\n  var melBasis = createMelFilterbank(params);\n  return applyWholeFilterbank(spec, melBasis);\n}\n\nexports.melSpectrogram = melSpectrogram;\n\nfunction powerToDb(spec, amin, topDb) {\n  if (amin === void 0) {\n    amin = 1e-10;\n  }\n\n  if (topDb === void 0) {\n    topDb = 80.0;\n  }\n\n  var width = spec.length;\n  var height = spec[0].length;\n  var logSpec = [];\n\n  for (var i = 0; i < width; i++) {\n    logSpec[i] = new Float32Array(height);\n  }\n\n  for (var i = 0; i < width; i++) {\n    for (var j = 0; j < height; j++) {\n      var val = spec[i][j];\n      logSpec[i][j] = 10.0 * Math.log10(Math.max(amin, val));\n    }\n  }\n\n  if (topDb) {\n    if (topDb < 0) {\n      throw new Error(\"topDb must be non-negative.\");\n    }\n\n    for (var i = 0; i < width; i++) {\n      var maxVal = max(logSpec[i]);\n\n      for (var j = 0; j < height; j++) {\n        logSpec[i][j] = Math.max(logSpec[i][j], maxVal - topDb);\n      }\n    }\n  }\n\n  return logSpec;\n}\n\nexports.powerToDb = powerToDb;\n\nfunction getMonoAudio(audioBuffer) {\n  if (audioBuffer.numberOfChannels === 1) {\n    return audioBuffer.getChannelData(0);\n  }\n\n  if (audioBuffer.numberOfChannels !== 2) {\n    throw Error(audioBuffer.numberOfChannels + \" channel audio is not supported.\");\n  }\n\n  var ch0 = audioBuffer.getChannelData(0);\n  var ch1 = audioBuffer.getChannelData(1);\n  var mono = new Float32Array(audioBuffer.length);\n\n  for (var i = 0; i < audioBuffer.length; ++i) {\n    mono[i] = (ch0[i] + ch1[i]) / 2;\n  }\n\n  return mono;\n}\n\nfunction resampleAndMakeMono(audioBuffer, targetSr) {\n  if (targetSr === void 0) {\n    targetSr = SAMPLE_RATE;\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var sourceSr, lengthRes, bufferSource, originalAudio, resampledAudio;\n    return __generator(this, function (_a) {\n      if (audioBuffer.sampleRate === targetSr) {\n        return [2, getMonoAudio(audioBuffer)];\n      }\n\n      sourceSr = audioBuffer.sampleRate;\n      lengthRes = audioBuffer.length * targetSr / sourceSr;\n\n      if (!isSafari) {\n        bufferSource = offlineCtx.createBufferSource();\n        bufferSource.buffer = audioBuffer;\n        bufferSource.connect(offlineCtx.destination);\n        bufferSource.start();\n        return [2, offlineCtx.startRendering().then(function (buffer) {\n          return buffer.getChannelData(0);\n        })];\n      } else {\n        logging.log('Safari does not support WebAudio resampling, so this may be slow.', 'O&F', 5);\n        originalAudio = getMonoAudio(audioBuffer);\n        resampledAudio = new Float32Array(lengthRes);\n        resample(ndarray(resampledAudio, [lengthRes]), ndarray(originalAudio, [originalAudio.length]));\n        return [2, resampledAudio];\n      }\n\n      return [2];\n    });\n  });\n}\n\nexports.resampleAndMakeMono = resampleAndMakeMono;\n\nfunction magSpectrogram(stft, power) {\n  var spec = stft.map(function (fft) {\n    return pow(mag(fft), power);\n  });\n  var nFft = stft[0].length - 1;\n  return [spec, nFft];\n}\n\nfunction stft(y, params) {\n  var nFft = params.nFft || 2048;\n  var winLength = params.winLength || nFft;\n  var hopLength = params.hopLength || Math.floor(winLength / 4);\n  var fftWindow = hannWindow(winLength);\n  fftWindow = padCenterToLength(fftWindow, nFft);\n  y = padReflect(y, Math.floor(nFft / 2));\n  var yFrames = frame(y, nFft, hopLength);\n  var stftMatrix = [];\n  var width = yFrames.length;\n  var height = nFft + 2;\n\n  for (var i = 0; i < width; i++) {\n    var col = new Float32Array(height);\n    stftMatrix[i] = col;\n  }\n\n  for (var i = 0; i < width; i++) {\n    var winBuffer = applyWindow(yFrames[i], fftWindow);\n    var col = fft(winBuffer);\n    stftMatrix[i].set(col.slice(0, height));\n  }\n\n  return stftMatrix;\n}\n\nfunction applyWholeFilterbank(spec, filterbank) {\n  var out = [];\n\n  for (var i = 0; i < spec.length; i++) {\n    out[i] = applyFilterbank(spec[i], filterbank);\n  }\n\n  return out;\n}\n\nfunction applyFilterbank(mags, filterbank) {\n  if (mags.length !== filterbank[0].length) {\n    throw new Error(\"Each entry in filterbank should have dimensions \" + (\"matching FFT. |mags| = \" + mags.length + \", \") + (\"|filterbank[0]| = \" + filterbank[0].length + \".\"));\n  }\n\n  var out = new Float32Array(filterbank.length);\n\n  for (var i = 0; i < filterbank.length; i++) {\n    var win = applyWindow(mags, filterbank[i]);\n    out[i] = win.reduce(function (a, b) {\n      return a + b;\n    });\n  }\n\n  return out;\n}\n\nfunction applyWindow(buffer, win) {\n  if (buffer.length !== win.length) {\n    console.error(\"Buffer length \" + buffer.length + \" != window length \" + win.length + \".\");\n    return null;\n  }\n\n  var out = new Float32Array(buffer.length);\n\n  for (var i = 0; i < buffer.length; i++) {\n    out[i] = win[i] * buffer[i];\n  }\n\n  return out;\n}\n\nexports.applyWindow = applyWindow;\n\nfunction padCenterToLength(data, length) {\n  if (data.length > length) {\n    throw new Error('Data is longer than length.');\n  }\n\n  var paddingLeft = Math.floor((length - data.length) / 2);\n  var paddingRight = length - data.length - paddingLeft;\n  return padConstant(data, [paddingLeft, paddingRight]);\n}\n\nexports.padCenterToLength = padCenterToLength;\n\nfunction padConstant(data, padding) {\n  var padLeft, padRight;\n\n  if (typeof padding === 'object') {\n    padLeft = padding[0], padRight = padding[1];\n  } else {\n    padLeft = padRight = padding;\n  }\n\n  var out = new Float32Array(data.length + padLeft + padRight);\n  out.set(data, padLeft);\n  return out;\n}\n\nexports.padConstant = padConstant;\n\nfunction padReflect(data, padding) {\n  var out = padConstant(data, padding);\n\n  for (var i = 0; i < padding; i++) {\n    out[i] = out[2 * padding - i];\n    out[out.length - i - 1] = out[out.length - 2 * padding + i - 1];\n  }\n\n  return out;\n}\n\nfunction frame(data, frameLength, hopLength) {\n  var bufferCount = Math.floor((data.length - frameLength) / hopLength) + 1;\n  var buffers = Array.from({\n    length: bufferCount\n  }, function (x, i) {\n    return new Float32Array(frameLength);\n  });\n\n  for (var i = 0; i < bufferCount; i++) {\n    var ind = i * hopLength;\n    var buffer = data.slice(ind, ind + frameLength);\n    buffers[i].set(buffer);\n\n    if (buffer.length !== frameLength) {\n      continue;\n    }\n  }\n\n  return buffers;\n}\n\nexports.frame = frame;\n\nfunction createMelFilterbank(params) {\n  var fMin = params.fMin || 0;\n  var fMax = params.fMax || params.sampleRate / 2;\n  var nMels = params.nMels || 128;\n  var nFft = params.nFft || 2048;\n  var fftFreqs = calculateFftFreqs(params.sampleRate, nFft);\n  var melFreqs = calculateMelFreqs(nMels + 2, fMin, fMax);\n  var melDiff = internalDiff(melFreqs);\n  var ramps = outerSubtract(melFreqs, fftFreqs);\n  var filterSize = ramps[0].length;\n  var weights = [];\n\n  for (var i = 0; i < nMels; i++) {\n    weights[i] = new Float32Array(filterSize);\n\n    for (var j = 0; j < ramps[i].length; j++) {\n      var lower = -ramps[i][j] / melDiff[i];\n      var upper = ramps[i + 2][j] / melDiff[i + 1];\n      var weight = Math.max(0, Math.min(lower, upper));\n      weights[i][j] = weight;\n    }\n  }\n\n  var _loop_1 = function _loop_1(i) {\n    var enorm = 2.0 / (melFreqs[2 + i] - melFreqs[i]);\n    weights[i] = weights[i].map(function (val) {\n      return val * enorm;\n    });\n  };\n\n  for (var i = 0; i < weights.length; i++) {\n    _loop_1(i);\n  }\n\n  return weights;\n}\n\nfunction fft(y) {\n  var fft = new FFT(y.length);\n  var out = fft.createComplexArray();\n  var data = fft.toComplexArray(y);\n  fft.transform(out, data);\n  return out;\n}\n\nfunction hannWindow(length) {\n  var win = new Float32Array(length);\n\n  for (var i = 0; i < length; i++) {\n    win[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1)));\n  }\n\n  return win;\n}\n\nexports.hannWindow = hannWindow;\n\nfunction linearSpace(start, end, count) {\n  var delta = (end - start) / (count - 1);\n  var out = new Float32Array(count);\n\n  for (var i = 0; i < count; i++) {\n    out[i] = start + delta * i;\n  }\n\n  return out;\n}\n\nfunction mag(y) {\n  var out = new Float32Array(y.length / 2);\n\n  for (var i = 0; i < y.length / 2; i++) {\n    out[i] = Math.sqrt(y[i * 2] * y[i * 2] + y[i * 2 + 1] * y[i * 2 + 1]);\n  }\n\n  return out;\n}\n\nfunction hzToMel(hz) {\n  return 1125.0 * Math.log(1 + hz / 700.0);\n}\n\nfunction melToHz(mel) {\n  return 700.0 * (Math.exp(mel / 1125.0) - 1);\n}\n\nfunction calculateFftFreqs(sampleRate, nFft) {\n  return linearSpace(0, sampleRate / 2, Math.floor(1 + nFft / 2));\n}\n\nfunction calculateMelFreqs(nMels, fMin, fMax) {\n  var melMin = hzToMel(fMin);\n  var melMax = hzToMel(fMax);\n  var mels = linearSpace(melMin, melMax, nMels);\n  var hzs = mels.map(function (mel) {\n    return melToHz(mel);\n  });\n  return hzs;\n}\n\nfunction internalDiff(arr) {\n  var out = new Float32Array(arr.length - 1);\n\n  for (var i = 0; i < arr.length; i++) {\n    out[i] = arr[i + 1] - arr[i];\n  }\n\n  return out;\n}\n\nfunction outerSubtract(arr, arr2) {\n  var out = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    out[i] = new Float32Array(arr2.length);\n  }\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = 0; j < arr2.length; j++) {\n      out[i][j] = arr[i] - arr2[j];\n    }\n  }\n\n  return out;\n}\n\nfunction pow(arr, power) {\n  return arr.map(function (v) {\n    return Math.pow(v, power);\n  });\n}\n\nfunction max(arr) {\n  return arr.reduce(function (a, b) {\n    return Math.max(a, b);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}