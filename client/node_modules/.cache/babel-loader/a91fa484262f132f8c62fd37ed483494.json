{"ast":null,"code":"/**\n * [![npm version](https://img.shields.io/npm/v/tonal-distance.svg)](https://www.npmjs.com/package/tonal-distance)\n * [![tonal](https://img.shields.io/badge/tonal-distance-yellow.svg)](https://github.com/danigb/tonal/tree/master/packages/tonal/distance)\n *\n * Transpose notes by intervals and find distances between notes\n *\n * @example\n * // es6\n * import * as Distance from \"tonal-distance\"\n * Distance.interval(\"C3\", \"C4\") // => \"1P\"\n *\n * @example\n * // es6 import selected functions\n * import { interval, semitones, transpose } from \"tonal-distance\"\n *\n * semitones(\"C\" ,\"D\") // => 2\n * interval(\"C4\", \"G4\") // => \"5P\"\n * transpose(\"C4\", \"P5\") // => \"G4\"\n *\n * @example\n * // included in tonal facade\n * const Tonal = require(\"tonal\");\n * Tonal.Distance.transpose(\"C4\", \"P5\")\n * Tonal.Distance.transposeBy(\"P5\", \"C4\")\n *\n * @module Distance\n */\nimport { props as noteProps, build as fromNote } from \"tonal-note\";\nimport { props as iprops, build as ibuild } from \"tonal-interval\"; // Map from letter step to number of fifths starting from \"C\":\n// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }\n\nvar FIFTHS = [0, 2, 4, -1, 1, 3, 5]; // Given a number of fifths, return the octaves they span\n\nvar fOcts = function fOcts(f) {\n  return Math.floor(f * 7 / 12);\n}; // Get the number of octaves it span each step\n\n\nvar FIFTH_OCTS = FIFTHS.map(fOcts);\n\nvar encode = function encode(ref) {\n  var step = ref.step;\n  var alt = ref.alt;\n  var oct = ref.oct;\n  var dir = ref.dir;\n  if (dir === void 0) dir = 1;\n  var f = FIFTHS[step] + 7 * alt;\n\n  if (oct === null) {\n    return [dir * f];\n  }\n\n  var o = oct - FIFTH_OCTS[step] - 4 * alt;\n  return [dir * f, dir * o];\n}; // We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for [\"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\"] we have:\n\n\nvar STEPS = [3, 0, 4, 1, 5, 2, 6]; // Return the number of fifths as if it were unaltered\n\nfunction unaltered(f) {\n  var i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n\nvar decode = function decode(f, o, dir) {\n  var step = STEPS[unaltered(f)];\n  var alt = Math.floor((f + 1) / 7);\n\n  if (o === undefined) {\n    return {\n      step: step,\n      alt: alt,\n      dir: dir\n    };\n  }\n\n  var oct = o + 4 * alt + FIFTH_OCTS[step];\n  return {\n    step: step,\n    alt: alt,\n    oct: oct,\n    dir: dir\n  };\n};\n\nvar memo = function memo(fn, cache) {\n  if (cache === void 0) cache = {};\n  return function (str) {\n    return cache[str] || (cache[str] = fn(str));\n  };\n};\n\nvar encoder = function encoder(props) {\n  return memo(function (str) {\n    var p = props(str);\n    return p.name === null ? null : encode(p);\n  });\n};\n\nvar encodeNote = encoder(noteProps);\nvar encodeIvl = encoder(iprops);\n/**\n * Transpose a note by an interval. The note can be a pitch class.\n *\n * This function can be partially applied.\n *\n * @param {string} note\n * @param {string} interval\n * @return {string} the transposed note\n * @example\n * import { tranpose } from \"tonal-distance\"\n * transpose(\"d3\", \"3M\") // => \"F#3\"\n * // it works with pitch classes\n * transpose(\"D\", \"3M\") // => \"F#\"\n * // can be partially applied\n * [\"C\", \"D\", \"E\", \"F\", \"G\"].map(transpose(\"M3)) // => [\"E\", \"F#\", \"G#\", \"A\", \"B\"]\n */\n\nexport function transpose(note, interval) {\n  if (arguments.length === 1) {\n    return function (i) {\n      return transpose(note, i);\n    };\n  }\n\n  var n = encodeNote(note);\n  var i = encodeIvl(interval);\n\n  if (n === null || i === null) {\n    return null;\n  }\n\n  var tr = n.length === 1 ? [n[0] + i[0]] : [n[0] + i[0], n[1] + i[1]];\n  return fromNote(decode(tr[0], tr[1]));\n}\n/**\n * Transpose a pitch class by a number of perfect fifths.\n *\n * It can be partially applied.\n *\n * @function\n * @param {string} pitchClass - the pitch class\n * @param {Integer} fifhts - the number of fifths\n * @return {string} the transposed pitch class\n *\n * @example\n * import { trFifths } from \"tonal-transpose\"\n * [0, 1, 2, 3, 4].map(trFifths(\"C\")) // => [\"C\", \"G\", \"D\", \"A\", \"E\"]\n * // or using tonal\n * Distance.trFifths(\"G4\", 1) // => \"D\"\n */\n\nexport function trFifths(note, fifths) {\n  if (arguments.length === 1) {\n    return function (f) {\n      return trFifths(note, f);\n    };\n  }\n\n  var n = encodeNote(note);\n\n  if (n === null) {\n    return null;\n  }\n\n  return fromNote(decode(n[0] + fifths));\n}\n/**\n * Get the distance in fifths between pitch classes\n *\n * Can be partially applied.\n *\n * @param {string} to - note or pitch class\n * @param {string} from - note or pitch class\n */\n\nexport function fifths(from, to) {\n  if (arguments.length === 1) {\n    return function (to) {\n      return fifths(from, to);\n    };\n  }\n\n  var f = encodeNote(from);\n  var t = encodeNote(to);\n\n  if (t === null || f === null) {\n    return null;\n  }\n\n  return t[0] - f[0];\n}\n/**\n * The same as transpose with the arguments inverted.\n *\n * Can be partially applied.\n *\n * @param {string} note\n * @param {string} interval\n * @return {string} the transposed note\n * @example\n * import { tranposeBy } from \"tonal-distance\"\n * transposeBy(\"3m\", \"5P\") // => \"7m\"\n */\n\nexport function transposeBy(interval, note) {\n  if (arguments.length === 1) {\n    return function (n) {\n      return transpose(n, interval);\n    };\n  }\n\n  return transpose(note, interval);\n}\n\nvar isDescending = function isDescending(e) {\n  return e[0] * 7 + e[1] * 12 < 0;\n};\n\nvar decodeIvl = function decodeIvl(i) {\n  return isDescending(i) ? decode(-i[0], -i[1], -1) : decode(i[0], i[1], 1);\n};\n\nexport function addIntervals(ivl1, ivl2, dir) {\n  var i1 = encodeIvl(ivl1);\n  var i2 = encodeIvl(ivl2);\n\n  if (i1 === null || i2 === null) {\n    return null;\n  }\n\n  var i = [i1[0] + dir * i2[0], i1[1] + dir * i2[1]];\n  return ibuild(decodeIvl(i));\n}\n/**\n * Add two intervals\n *\n * Can be partially applied.\n *\n * @param {string} interval1\n * @param {string} interval2\n * @return {string} the resulting interval\n * @example\n * import { add } from \"tonal-distance\"\n * add(\"3m\", \"5P\") // => \"7m\"\n */\n\nexport function add(ivl1, ivl2) {\n  if (arguments.length === 1) {\n    return function (i2) {\n      return add(ivl1, i2);\n    };\n  }\n\n  return addIntervals(ivl1, ivl2, 1);\n}\n/**\n * Subtract two intervals\n *\n * Can be partially applied\n *\n * @param {string} minuend\n * @param {string} subtrahend\n * @return {string} interval diference\n */\n\nexport function subtract(ivl1, ivl2) {\n  if (arguments.length === 1) {\n    return function (i2) {\n      return add(ivl1, i2);\n    };\n  }\n\n  return addIntervals(ivl1, ivl2, -1);\n}\n/**\n * Find the interval between two pitches. It works with pitch classes\n * (both must be pitch classes and the interval is always ascending)\n *\n * Can be partially applied\n *\n * @param {string} from - distance from\n * @param {string} to - distance to\n * @return {string} the interval distance\n *\n * @example\n * import { interval } from \"tonal-distance\"\n * interval(\"C2\", \"C3\") // => \"P8\"\n * interval(\"G\", \"B\") // => \"M3\"\n *\n * @example\n * import * as Distance from \"tonal-distance\"\n * Distance.interval(\"M2\", \"P5\") // => \"P4\"\n */\n\nexport function interval(from, to) {\n  if (arguments.length === 1) {\n    return function (t) {\n      return interval(from, t);\n    };\n  }\n\n  var f = encodeNote(from);\n  var t = encodeNote(to);\n\n  if (f === null || t === null || f.length !== t.length) {\n    return null;\n  }\n\n  var d = f.length === 1 ? [t[0] - f[0], -Math.floor((t[0] - f[0]) * 7 / 12)] : [t[0] - f[0], t[1] - f[1]];\n  return ibuild(decodeIvl(d));\n}\n/**\n * Get the distance between two notes in semitones\n *\n * @param {String|Pitch} from - first note\n * @param {String|Pitch} to - last note\n * @return {Integer} the distance in semitones or null if not valid notes\n * @example\n * import { semitones } from \"tonal-distance\"\n * semitones(\"C3\", \"A2\") // => -3\n * // or use tonal\n * Tonal.Distance.semitones(\"C3\", \"G3\") // => 7\n */\n\nexport function semitones(from, to) {\n  if (arguments.length === 1) {\n    return function (t) {\n      return semitones(from, t);\n    };\n  }\n\n  var f = noteProps(from);\n  var t = noteProps(to);\n  return f.midi !== null && t.midi !== null ? t.midi - f.midi : f.chroma !== null && t.chroma !== null ? (t.chroma - f.chroma + 12) % 12 : null;\n}","map":null,"metadata":{},"sourceType":"module"}