{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs\");\n\nvar protobuf_1 = require(\"../protobuf\");\n\nvar constants_1 = require(\"./constants\");\n\nvar RF_PAD = 3;\n\nfunction batchInput(input, batchLength) {\n  var batchSize = Math.ceil(input.length / batchLength);\n  var batchRemainder = input.length % batchLength;\n  var mergedRemainder = 0;\n\n  if (batchSize > 1 && batchRemainder > 0 && batchRemainder <= RF_PAD) {\n    batchSize -= 1;\n    mergedRemainder = batchRemainder;\n    batchRemainder = 0;\n  }\n\n  if (batchSize === 1) {\n    return tf.tensor2d(input).expandDims(0);\n  }\n\n  var actualBatchLength = batchLength + 2 * RF_PAD;\n  var firstBatch = tf.tensor2d(input.slice(0, actualBatchLength)).expandDims(0);\n  var lastBatch = tf.tensor2d(input.slice(input.length - actualBatchLength)).expandDims(0);\n\n  if (batchSize === 2) {\n    return tf.concat([firstBatch, lastBatch], 0);\n  }\n\n  var naivePaddedBatches;\n\n  if (batchRemainder) {\n    naivePaddedBatches = tf.tensor2d(input).pad([[0, batchLength - batchRemainder], [0, 0]]).as3D(batchSize, batchLength, -1);\n  } else {\n    naivePaddedBatches = tf.tensor2d(input.slice(0, input.length - mergedRemainder)).as3D(batchSize, batchLength, -1);\n  }\n\n  var leftPad = tf.slice(naivePaddedBatches, [0, batchLength - RF_PAD], [batchSize - 2, -1]);\n  var rightPad = tf.slice(naivePaddedBatches, [2, 0], [-1, RF_PAD]);\n  var midBatches = tf.concat([leftPad, naivePaddedBatches.slice(1, batchSize - 2), rightPad], 1);\n  return tf.concat([firstBatch, midBatches, lastBatch], 0);\n}\n\nexports.batchInput = batchInput;\n\nfunction unbatchOutput(batches, batchLength, totalLength) {\n  if (batches.shape[0] === 1) {\n    return batches;\n  }\n\n  return tf.tidy(function () {\n    var firstBatch = batches.slice([0, 0], [1, batchLength]);\n    var finalBatchLength = totalLength % batchLength;\n\n    if (finalBatchLength <= RF_PAD) {\n      finalBatchLength += batchLength;\n    }\n\n    var finalBatch = batches.slice([batches.shape[0] - 1, batches.shape[1] - finalBatchLength], [-1, -1]);\n    var toConcat = [firstBatch, finalBatch];\n\n    if (batches.shape[0] > 2) {\n      var midBatchSize = batches.shape[0] - 2;\n      var midBatches = batches.slice([1, RF_PAD], [midBatchSize, batchLength]);\n      toConcat = [firstBatch, midBatches.as3D(1, midBatchSize * batchLength, -1), finalBatch];\n    }\n\n    return tf.concat(toConcat, 1);\n  });\n}\n\nexports.unbatchOutput = unbatchOutput;\n\nfunction pianorollToNoteSequence(frameProbs, onsetProbs, velocityValues, onsetThreshold, frameThreshold) {\n  if (onsetThreshold === void 0) {\n    onsetThreshold = 0.5;\n  }\n\n  if (frameThreshold === void 0) {\n    frameThreshold = 0.5;\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    function endPitch(pitch, endFrame) {\n      ns.notes.push(protobuf_1.NoteSequence.Note.create({\n        pitch: pitch + constants_1.MIN_MIDI_PITCH,\n        startTime: (pitchStartStepPlusOne[pitch] - 1) * constants_1.FRAME_LENGTH_SECONDS,\n        endTime: endFrame * constants_1.FRAME_LENGTH_SECONDS,\n        velocity: onsetVelocities[pitch]\n      }));\n      pitchStartStepPlusOne[pitch] = 0;\n    }\n\n    function processOnset(p, f, velocity) {\n      if (pitchStartStepPlusOne[p]) {\n        if (!previousOnsets[p]) {\n          endPitch(p, f);\n          pitchStartStepPlusOne[p] = f + 1;\n          onsetVelocities[p] = velocity;\n        }\n      } else {\n        pitchStartStepPlusOne[p] = f + 1;\n        onsetVelocities[p] = velocity;\n      }\n    }\n\n    var ns, pitchStartStepPlusOne, onsetVelocities, previousOnsets, predictions, _a, frames, onsets, velocities, numFrames, f, p, i;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          ns = protobuf_1.NoteSequence.create();\n          pitchStartStepPlusOne = new Uint32Array(constants_1.MIDI_PITCHES);\n          onsetVelocities = new Uint8Array(constants_1.MIDI_PITCHES);\n          previousOnsets = new Uint8Array(constants_1.MIDI_PITCHES);\n          predictions = tf.tidy(function () {\n            var onsetPredictions = tf.greater(onsetProbs, onsetThreshold);\n            var framePredictions = tf.greater(frameProbs, frameThreshold);\n            onsetPredictions = onsetPredictions.pad([[0, 1], [0, 0]]);\n            framePredictions = framePredictions.pad([[0, 1], [0, 0]]);\n            velocityValues = velocityValues.pad([[0, 1], [0, 0]]);\n            framePredictions = tf.logicalOr(framePredictions, onsetPredictions);\n            return [framePredictions, onsetPredictions, velocityValues];\n          });\n          return [4, Promise.all(predictions.map(function (t) {\n            return t.data();\n          }))];\n\n        case 1:\n          _a = _b.sent(), frames = _a[0], onsets = _a[1], velocities = _a[2];\n          predictions.forEach(function (t) {\n            return t.dispose();\n          });\n          numFrames = frameProbs.shape[0];\n\n          for (f = 0; f < numFrames + 1; ++f) {\n            for (p = 0; p < constants_1.MIDI_PITCHES; ++p) {\n              i = f * constants_1.MIDI_PITCHES + p;\n\n              if (onsets[i]) {\n                processOnset(p, f, velocities[i]);\n              } else if (!frames[i] && pitchStartStepPlusOne[p]) {\n                endPitch(p, f);\n              }\n            }\n\n            previousOnsets = onsets.slice(f * constants_1.MIDI_PITCHES, (f + 1) * constants_1.MIDI_PITCHES);\n          }\n\n          ns.totalTime = numFrames * constants_1.FRAME_LENGTH_SECONDS;\n          return [2, ns];\n      }\n    });\n  });\n}\n\nexports.pianorollToNoteSequence = pianorollToNoteSequence;","map":null,"metadata":{},"sourceType":"script"}