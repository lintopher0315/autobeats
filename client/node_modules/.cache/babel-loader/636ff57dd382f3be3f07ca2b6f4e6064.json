{"ast":null,"code":"import _classCallCheck from \"/home/christopher/Documents/autobeats/autobeats/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/christopher/Documents/autobeats/autobeats/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { BinaryInsert } from './BinaryInsert';\nimport { Control } from './Control';\nimport { Merge } from './Merge';\nimport { Note } from './Note';\nimport { instrumentByPatchID, instrumentFamilyByID, drumKitByPatchID } from './instrumentMaps';\n\nvar Track =\n/*#__PURE__*/\nfunction () {\n  _createClass(Track, null, [{\n    key: \"fromJSON\",\n\n    /**\n    \t * Convert JSON to Track object\n    \t * @param {object} json\n    \t * @static\n    \t * @returns {Track}\n    \t */\n    value: function fromJSON(json) {\n      var track = new Track(json.name, json.instrumentNumber, json.channelNumber);\n      track.id = json.id;\n\n      if (json.notes) {\n        json.notes.forEach(function (note) {\n          var newNote = Note.fromJSON(note);\n          track.notes.push(newNote);\n        });\n      }\n\n      if (json.controlChanges) {\n        track.controlChanges = json.controlChanges;\n      }\n\n      return track;\n    }\n  }]);\n\n  function Track(name) {\n    var instrumentNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var channel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n    _classCallCheck(this, Track);\n\n    /**\n     * The name of the track\n     * @type {String}\n     */\n    this.name = name;\n    /**\n     * The MIDI channel of the track\n     * @type {number}\n     */\n\n    this.channelNumber = channel;\n    /**\n     * The note events\n     * @type {Array}\n     */\n\n    this.notes = [];\n    /**\n     * The control changes\n     * @type {Object}\n     */\n\n    this.controlChanges = {};\n    /**\n     * The MIDI patch ID of the instrument. -1 if none is set.\n     * @type {Number}\n     */\n\n    this.instrumentNumber = instrumentNumber;\n  }\n\n  _createClass(Track, [{\n    key: \"note\",\n    value: function note(midi, time) {\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var note = new Note(midi, time, duration, velocity);\n      BinaryInsert(this.notes, note);\n      return this;\n    }\n    /**\n     * Add a note on event\n     * @param  {Number|String} midi     The midi note as either a midi number or\n     *                                  Pitch Notation like ('C#4')\n     * @param  {Number} time     The time in seconds\n     * @param  {Number} velocity The velocity value 0-1\n     * @return {Track} this\n     */\n\n  }, {\n    key: \"noteOn\",\n    value: function noteOn(midi, time) {\n      var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var note = new Note(midi, time, 0, velocity);\n      BinaryInsert(this.notes, note);\n      return this;\n    }\n    /**\n     * Add a note off event. Go through and find an unresolved\n     * noteOn event with the same pitch.\n     * @param  {String|Number} midi The midi number or note name.\n     * @param  {Number} time The time of the event in seconds\n     * @return {Track} this\n     */\n\n  }, {\n    key: \"noteOff\",\n    value: function noteOff(midi, time) {\n      for (var i = 0; i < this.notes.length; i++) {\n        var note = this.notes[i];\n\n        if (note.match(midi) && note.duration === 0) {\n          note.noteOff = time;\n          break;\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Add a CC event\n     * @param  {Number} num The CC number\n     * @param  {Number} time The time of the event in seconds\n     * @param  {Number} value The value of the CC\n     * @return {Track} this\n     */\n\n  }, {\n    key: \"cc\",\n    value: function cc(num, time, value) {\n      if (!this.controlChanges.hasOwnProperty(num)) {\n        this.controlChanges[num] = [];\n      }\n\n      var cc = new Control(num, time, value);\n      BinaryInsert(this.controlChanges[num], cc);\n      return this;\n    }\n    /**\n     * Sets instrumentNumber.\n     * For a list of possible values, see the [General MIDI Instrument Patch Map](https://www.midi.org/specifications/item/gm-level-1-sound-set)\n     * @param  {Number} id The Patch ID for this instrument, as specified in the General MIDI Instrument Patch Map\n     */\n\n  }, {\n    key: \"patch\",\n    value: function patch(id) {\n      this.instrumentNumber = id;\n      return this;\n    }\n    /**\n     * Sets channelNumber.\n     * @param  {Number} id The MIDI channel number, between 0 and 0xF.  0x9 and 0xA are percussion\n     */\n\n  }, {\n    key: \"channel\",\n    value: function channel(id) {\n      this.channelNumber = id;\n      return this;\n    }\n    /**\n     * An array of all the note on events\n     * @type {Array<Object>}\n     * @readOnly\n     */\n\n  }, {\n    key: \"scale\",\n\n    /**\n     * Scale the timing of all the events in the track\n     * @param {Number} amount The amount to scale all the values\n     */\n    value: function scale(amount) {\n      this.notes.forEach(function (note) {\n        note.time *= amount;\n        note.duration *= amount;\n      });\n      return this;\n    }\n    /**\n     * Slice returns a new track with only events that occured between startTime and endTime.\n     * Modifies this track.\n     * @param {Number} startTime\n     * @param {Number} endTime\n     * @returns {Track}\n     */\n\n  }, {\n    key: \"slice\",\n    value: function slice() {\n      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var endTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n      // get the index before the startTime\n      var noteStartIndex = Math.max(this.notes.findIndex(function (note) {\n        return note.time >= startTime;\n      }), 0);\n      var noteEndIndex = this.notes.findIndex(function (note) {\n        return note.noteOff >= endTime;\n      }) + 1;\n      var track = new Track(this.name);\n      track.notes = this.notes.slice(noteStartIndex, noteEndIndex); //shift the start time\n\n      track.notes.forEach(function (note) {\n        return note.time = note.time - startTime;\n      });\n      return track;\n    }\n    /**\n     * Write the output to the stream\n     */\n\n  }, {\n    key: \"encode\",\n    value: function encode(trackEncoder, header) {\n      var ticksPerSecond = header.PPQ / (60 / header.bpm);\n      var lastEventTime = 0; // unset, `channelNumber` defaults to -1, but that's not a valid MIDI channel\n\n      var channelNumber = Math.max(0, this.channelNumber);\n\n      function getDeltaTime(time) {\n        var ticks = Math.floor(ticksPerSecond * time);\n        var delta = Math.max(ticks - lastEventTime, 0);\n        lastEventTime = ticks;\n        return delta;\n      }\n\n      if (this.instrumentNumber !== -1) {\n        trackEncoder.instrument(channelNumber, this.instrumentNumber);\n      }\n\n      Merge(this.noteOns.sort(function (a, b) {\n        return a.time - b.time;\n      }), function (noteOn) {\n        trackEncoder.addNoteOn(channelNumber, noteOn.name, getDeltaTime(noteOn.time), Math.floor(noteOn.velocity * 127));\n      }, this.noteOffs.sort(function (a, b) {\n        return a.time - b.time;\n      }), function (noteOff) {\n        trackEncoder.addNoteOff(channelNumber, noteOff.name, getDeltaTime(noteOff.time));\n      });\n    }\n    /**\n     *  Convert all of the fields to JSON\n     *  @return  {Object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var ret = {\n        startTime: this.startTime,\n        duration: this.duration,\n        length: this.length,\n        notes: [],\n        controlChanges: {}\n      };\n      if (typeof this.id !== 'undefined') ret.id = this.id;\n      ret.name = this.name;\n\n      if (this.instrumentNumber !== -1) {\n        ret.instrumentNumber = this.instrumentNumber;\n        ret.instrument = this.instrument;\n        ret.instrumentFamily = this.instrumentFamily;\n      }\n\n      if (this.channelNumber !== -1) {\n        ret.channelNumber = this.channelNumber;\n        ret.isPercussion = this.isPercussion;\n      }\n\n      if (this.notes.length) ret.notes = this.notes.map(function (n) {\n        return n.toJSON();\n      });\n      if (Object.keys(this.controlChanges).length) ret.controlChanges = this.controlChanges;\n      return ret;\n    }\n  }, {\n    key: \"noteOns\",\n    get: function get() {\n      var noteOns = [];\n      this.notes.forEach(function (note) {\n        noteOns.push({\n          time: note.noteOn,\n          midi: note.midi,\n          name: note.name,\n          velocity: note.velocity\n        });\n      });\n      return noteOns;\n    }\n    /**\n     * An array of all the noteOff events\n     * @type {Array<Object>}\n     * @readOnly\n     */\n\n  }, {\n    key: \"noteOffs\",\n    get: function get() {\n      var noteOffs = [];\n      this.notes.forEach(function (note) {\n        noteOffs.push({\n          time: note.noteOff,\n          midi: note.midi,\n          name: note.name\n        });\n      });\n      return noteOffs;\n    }\n    /**\n     * The length in seconds of the track\n     * @type {Number}\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.notes.length;\n    }\n    /**\n     * The time of the first event in seconds\n     * @type {Number}\n     */\n\n  }, {\n    key: \"startTime\",\n    get: function get() {\n      if (this.notes.length) {\n        var firstNote = this.notes[0];\n        return firstNote.noteOn;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The time of the last event in seconds\n     * @type {Number}\n     */\n\n  }, {\n    key: \"duration\",\n    get: function get() {\n      if (this.notes.length) {\n        var lastNote = this.notes[this.notes.length - 1];\n        return lastNote.noteOff;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The name of the midi instrument\n     * @type {String}\n     */\n\n  }, {\n    key: \"instrument\",\n    get: function get() {\n      if (this.isPercussion) {\n        return drumKitByPatchID[this.instrumentNumber];\n      } else {\n        return instrumentByPatchID[this.instrumentNumber];\n      }\n    },\n    set: function set(inst) {\n      var index = instrumentByPatchID.indexOf(inst);\n\n      if (index !== -1) {\n        this.instrumentNumber = index;\n      }\n    }\n    /**\n     * Whether or not this is a percussion track\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isPercussion\",\n    get: function get() {\n      return [0x9, 0xA].includes(this.channelNumber);\n    }\n    /**\n     * The family that the instrument belongs to\n     * @type {String}\n     * @readOnly\n     */\n\n  }, {\n    key: \"instrumentFamily\",\n    get: function get() {\n      if (this.isPercussion) {\n        return 'drums';\n      } else {\n        return instrumentFamilyByID[Math.floor(this.instrumentNumber / 8)];\n      }\n    }\n  }]);\n\n  return Track;\n}();\n\nexport { Track };","map":null,"metadata":{},"sourceType":"module"}