{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs\");\n\nvar PixelNorm = function (_super) {\n  __extends(PixelNorm, _super);\n\n  function PixelNorm(epsilon, layerConfig) {\n    if (epsilon === void 0) {\n      epsilon = 1e-8;\n    }\n\n    if (layerConfig === void 0) {\n      layerConfig = {};\n    }\n\n    var _this = _super.call(this, layerConfig) || this;\n\n    _this.epsilon = epsilon;\n    _this.layerConfig = layerConfig;\n    _this.supportsMasking = true;\n    return _this;\n  }\n\n  PixelNorm.prototype.computeOutputShape = function (inputShape) {\n    return [inputShape[0], inputShape[1], inputShape[2], inputShape[3]];\n  };\n\n  PixelNorm.prototype.call = function (inputs) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      var input = inputs;\n\n      if (Array.isArray(input)) {\n        input = input[0];\n      }\n\n      var mean = tf.mean(tf.square(input), [3], true);\n      return tf.mul(input, tf.rsqrt(tf.add(mean, _this.epsilon)));\n    });\n  };\n\n  PixelNorm.prototype.getClassName = function () {\n    return 'PixelNorm';\n  };\n\n  return PixelNorm;\n}(tf.layers.Layer);\n\nfunction pixelNorm(epsilon, layerConfig) {\n  if (epsilon === void 0) {\n    epsilon = 1e-8;\n  }\n\n  if (layerConfig === void 0) {\n    layerConfig = {};\n  }\n\n  return new PixelNorm(epsilon, layerConfig);\n}\n\nexports.pixelNorm = pixelNorm;\n\nvar InitialPad = function (_super) {\n  __extends(InitialPad, _super);\n\n  function InitialPad(kernelH, kernelW, layerConfig) {\n    if (kernelH === void 0) {\n      kernelH = 2;\n    }\n\n    if (kernelW === void 0) {\n      kernelW = 16;\n    }\n\n    if (layerConfig === void 0) {\n      layerConfig = {};\n    }\n\n    var _this = _super.call(this, layerConfig) || this;\n\n    _this.kernelH = kernelH;\n    _this.kernelW = kernelW;\n    _this.layerConfig = layerConfig;\n    _this.supportsMasking = true;\n    return _this;\n  }\n\n  InitialPad.prototype.computeOutputShape = function (inputShape) {\n    return [inputShape[0], 2 * (this.kernelH - 1) + inputShape[1], 2 * (this.kernelW - 1) + inputShape[2], inputShape[3]];\n  };\n\n  InitialPad.prototype.call = function (inputs) {\n    var input = inputs;\n\n    if (Array.isArray(input)) {\n      input = input[0];\n    }\n\n    var padH = this.kernelH - 1;\n    var padW = this.kernelW - 1;\n    return tf.pad(input, [[0, 0], [padH, padH], [padW, padW], [0, 0]]);\n  };\n\n  InitialPad.prototype.getClassName = function () {\n    return 'InitialPad';\n  };\n\n  return InitialPad;\n}(tf.layers.Layer);\n\nfunction initialPad(kernelH, kernelW, layerConfig) {\n  if (kernelH === void 0) {\n    kernelH = 2;\n  }\n\n  if (kernelW === void 0) {\n    kernelW = 16;\n  }\n\n  if (layerConfig === void 0) {\n    layerConfig = {};\n  }\n\n  return new InitialPad(kernelH, kernelW, layerConfig);\n}\n\nexports.initialPad = initialPad;\n\nvar BoxUpscale = function (_super) {\n  __extends(BoxUpscale, _super);\n\n  function BoxUpscale(scale) {\n    if (scale === void 0) {\n      scale = 2;\n    }\n\n    var _this = _super.call(this, {}) || this;\n\n    _this.scale = scale;\n    _this.supportsMasking = true;\n    return _this;\n  }\n\n  BoxUpscale.prototype.computeOutputShape = function (inputShape) {\n    return [inputShape[0], this.scale * inputShape[1], this.scale * inputShape[2], inputShape[3]];\n  };\n\n  BoxUpscale.prototype.call = function (inputs) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      var input = inputs;\n\n      if (Array.isArray(input)) {\n        input = input[0];\n      }\n\n      var tiledInput = tf.tile(input, [Math.pow(_this.scale, 2), 1, 1, 1]);\n      return tf.batchToSpaceND(tiledInput, [_this.scale, _this.scale], [[0, 0], [0, 0]]);\n    });\n  };\n\n  BoxUpscale.prototype.getClassName = function () {\n    return 'BoxUpscale';\n  };\n\n  return BoxUpscale;\n}(tf.layers.Layer);\n\nfunction boxUpscale(scale) {\n  if (scale === void 0) {\n    scale = 2;\n  }\n\n  return new BoxUpscale(scale);\n}\n\nexports.boxUpscale = boxUpscale;","map":null,"metadata":{},"sourceType":"script"}