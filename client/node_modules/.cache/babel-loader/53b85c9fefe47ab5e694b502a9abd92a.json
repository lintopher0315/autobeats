{"ast":null,"code":"var bits = require('bit-twiddle');\n\nfunction fft(dir, nrows, ncols, buffer, x_ptr, y_ptr, scratch_ptr) {\n  dir |= 0;\n  nrows |= 0;\n  ncols |= 0;\n  x_ptr |= 0;\n  y_ptr |= 0;\n\n  if (bits.isPow2(ncols)) {\n    fftRadix2(dir, nrows, ncols, buffer, x_ptr, y_ptr);\n  } else {\n    fftBluestein(dir, nrows, ncols, buffer, x_ptr, y_ptr, scratch_ptr);\n  }\n}\n\nmodule.exports = fft;\n\nfunction scratchMemory(n) {\n  if (bits.isPow2(n)) {\n    return 0;\n  }\n\n  return 2 * n + 4 * bits.nextPow2(2 * n + 1);\n}\n\nmodule.exports.scratchMemory = scratchMemory; //Radix 2 FFT Adapted from Paul Bourke's C Implementation\n\nfunction fftRadix2(dir, nrows, ncols, buffer, x_ptr, y_ptr) {\n  dir |= 0;\n  nrows |= 0;\n  ncols |= 0;\n  x_ptr |= 0;\n  y_ptr |= 0;\n  var nn, m, i, i1, j, k, i2, l, l1, l2;\n  var c1, c2, t, t1, t2, u1, u2, z, row, a, b, c, d, k1, k2, k3; // Calculate the number of points\n\n  nn = ncols;\n  m = bits.log2(nn);\n\n  for (row = 0; row < nrows; ++row) {\n    // Do the bit reversal\n    i2 = nn >> 1;\n    j = 0;\n\n    for (i = 0; i < nn - 1; i++) {\n      if (i < j) {\n        t = buffer[x_ptr + i];\n        buffer[x_ptr + i] = buffer[x_ptr + j];\n        buffer[x_ptr + j] = t;\n        t = buffer[y_ptr + i];\n        buffer[y_ptr + i] = buffer[y_ptr + j];\n        buffer[y_ptr + j] = t;\n      }\n\n      k = i2;\n\n      while (k <= j) {\n        j -= k;\n        k >>= 1;\n      }\n\n      j += k;\n    } // Compute the FFT\n\n\n    c1 = -1.0;\n    c2 = 0.0;\n    l2 = 1;\n\n    for (l = 0; l < m; l++) {\n      l1 = l2;\n      l2 <<= 1;\n      u1 = 1.0;\n      u2 = 0.0;\n\n      for (j = 0; j < l1; j++) {\n        for (i = j; i < nn; i += l2) {\n          i1 = i + l1;\n          a = buffer[x_ptr + i1];\n          b = buffer[y_ptr + i1];\n          c = buffer[x_ptr + i];\n          d = buffer[y_ptr + i];\n          k1 = u1 * (a + b);\n          k2 = a * (u2 - u1);\n          k3 = b * (u1 + u2);\n          t1 = k1 - k3;\n          t2 = k1 + k2;\n          buffer[x_ptr + i1] = c - t1;\n          buffer[y_ptr + i1] = d - t2;\n          buffer[x_ptr + i] += t1;\n          buffer[y_ptr + i] += t2;\n        }\n\n        k1 = c1 * (u1 + u2);\n        k2 = u1 * (c2 - c1);\n        k3 = u2 * (c1 + c2);\n        u1 = k1 - k3;\n        u2 = k1 + k2;\n      }\n\n      c2 = Math.sqrt((1.0 - c1) / 2.0);\n\n      if (dir < 0) {\n        c2 = -c2;\n      }\n\n      c1 = Math.sqrt((1.0 + c1) / 2.0);\n    } // Scaling for inverse transform\n\n\n    if (dir < 0) {\n      var scale_f = 1.0 / nn;\n\n      for (i = 0; i < nn; i++) {\n        buffer[x_ptr + i] *= scale_f;\n        buffer[y_ptr + i] *= scale_f;\n      }\n    } // Advance pointers\n\n\n    x_ptr += ncols;\n    y_ptr += ncols;\n  }\n} // Use Bluestein algorithm for npot FFTs\n// Scratch memory required:  2 * ncols + 4 * bits.nextPow2(2*ncols + 1)\n\n\nfunction fftBluestein(dir, nrows, ncols, buffer, x_ptr, y_ptr, scratch_ptr) {\n  dir |= 0;\n  nrows |= 0;\n  ncols |= 0;\n  x_ptr |= 0;\n  y_ptr |= 0;\n  scratch_ptr |= 0; // Initialize tables\n\n  var m = bits.nextPow2(2 * ncols + 1),\n      cos_ptr = scratch_ptr,\n      sin_ptr = cos_ptr + ncols,\n      xs_ptr = sin_ptr + ncols,\n      ys_ptr = xs_ptr + m,\n      cft_ptr = ys_ptr + m,\n      sft_ptr = cft_ptr + m,\n      w = -dir * Math.PI / ncols,\n      row,\n      a,\n      b,\n      c,\n      d,\n      k1,\n      k2,\n      k3,\n      i;\n\n  for (i = 0; i < ncols; ++i) {\n    a = w * (i * i % (ncols * 2));\n    c = Math.cos(a);\n    d = Math.sin(a);\n    buffer[cft_ptr + (m - i)] = buffer[cft_ptr + i] = buffer[cos_ptr + i] = c;\n    buffer[sft_ptr + (m - i)] = buffer[sft_ptr + i] = buffer[sin_ptr + i] = d;\n  }\n\n  for (i = ncols; i <= m - ncols; ++i) {\n    buffer[cft_ptr + i] = 0.0;\n  }\n\n  for (i = ncols; i <= m - ncols; ++i) {\n    buffer[sft_ptr + i] = 0.0;\n  }\n\n  fftRadix2(1, 1, m, buffer, cft_ptr, sft_ptr); //Compute scale factor\n\n  if (dir < 0) {\n    w = 1.0 / ncols;\n  } else {\n    w = 1.0;\n  } //Handle direction\n\n\n  for (row = 0; row < nrows; ++row) {\n    // Copy row into scratch memory, multiply weights\n    for (i = 0; i < ncols; ++i) {\n      a = buffer[x_ptr + i];\n      b = buffer[y_ptr + i];\n      c = buffer[cos_ptr + i];\n      d = -buffer[sin_ptr + i];\n      k1 = c * (a + b);\n      k2 = a * (d - c);\n      k3 = b * (c + d);\n      buffer[xs_ptr + i] = k1 - k3;\n      buffer[ys_ptr + i] = k1 + k2;\n    } //Zero out the rest\n\n\n    for (i = ncols; i < m; ++i) {\n      buffer[xs_ptr + i] = 0.0;\n    }\n\n    for (i = ncols; i < m; ++i) {\n      buffer[ys_ptr + i] = 0.0;\n    } // FFT buffer\n\n\n    fftRadix2(1, 1, m, buffer, xs_ptr, ys_ptr); // Apply multiplier\n\n    for (i = 0; i < m; ++i) {\n      a = buffer[xs_ptr + i];\n      b = buffer[ys_ptr + i];\n      c = buffer[cft_ptr + i];\n      d = buffer[sft_ptr + i];\n      k1 = c * (a + b);\n      k2 = a * (d - c);\n      k3 = b * (c + d);\n      buffer[xs_ptr + i] = k1 - k3;\n      buffer[ys_ptr + i] = k1 + k2;\n    } // Inverse FFT buffer\n\n\n    fftRadix2(-1, 1, m, buffer, xs_ptr, ys_ptr); // Copy result back into x/y\n\n    for (i = 0; i < ncols; ++i) {\n      a = buffer[xs_ptr + i];\n      b = buffer[ys_ptr + i];\n      c = buffer[cos_ptr + i];\n      d = -buffer[sin_ptr + i];\n      k1 = c * (a + b);\n      k2 = a * (d - c);\n      k3 = b * (c + d);\n      buffer[x_ptr + i] = w * (k1 - k3);\n      buffer[y_ptr + i] = w * (k1 + k2);\n    }\n\n    x_ptr += ncols;\n    y_ptr += ncols;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}