{"ast":null,"code":"/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.tensorflow = function () {\n  /**\n   * Namespace tensorflow.\n   * @exports tensorflow\n   * @namespace\n   */\n  var tensorflow = {};\n\n  tensorflow.magenta = function () {\n    /**\n     * Namespace magenta.\n     * @memberof tensorflow\n     * @namespace\n     */\n    var magenta = {};\n\n    magenta.NoteSequence = function () {\n      /**\n       * Properties of a NoteSequence.\n       * @memberof tensorflow.magenta\n       * @interface INoteSequence\n       * @property {string|null} [id] NoteSequence id\n       * @property {string|null} [filename] NoteSequence filename\n       * @property {number|null} [referenceNumber] NoteSequence referenceNumber\n       * @property {string|null} [collectionName] NoteSequence collectionName\n       * @property {number|null} [ticksPerQuarter] NoteSequence ticksPerQuarter\n       * @property {Array.<tensorflow.magenta.NoteSequence.ITimeSignature>|null} [timeSignatures] NoteSequence timeSignatures\n       * @property {Array.<tensorflow.magenta.NoteSequence.IKeySignature>|null} [keySignatures] NoteSequence keySignatures\n       * @property {Array.<tensorflow.magenta.NoteSequence.ITempo>|null} [tempos] NoteSequence tempos\n       * @property {Array.<tensorflow.magenta.NoteSequence.INote>|null} [notes] NoteSequence notes\n       * @property {number|null} [totalTime] NoteSequence totalTime\n       * @property {number|null} [totalQuantizedSteps] NoteSequence totalQuantizedSteps\n       * @property {Array.<tensorflow.magenta.NoteSequence.IPitchBend>|null} [pitchBends] NoteSequence pitchBends\n       * @property {Array.<tensorflow.magenta.NoteSequence.IControlChange>|null} [controlChanges] NoteSequence controlChanges\n       * @property {Array.<tensorflow.magenta.NoteSequence.IPartInfo>|null} [partInfos] NoteSequence partInfos\n       * @property {tensorflow.magenta.NoteSequence.ISourceInfo|null} [sourceInfo] NoteSequence sourceInfo\n       * @property {Array.<tensorflow.magenta.NoteSequence.ITextAnnotation>|null} [textAnnotations] NoteSequence textAnnotations\n       * @property {Array.<tensorflow.magenta.NoteSequence.ISectionAnnotation>|null} [sectionAnnotations] NoteSequence sectionAnnotations\n       * @property {Array.<tensorflow.magenta.NoteSequence.ISectionGroup>|null} [sectionGroups] NoteSequence sectionGroups\n       * @property {tensorflow.magenta.NoteSequence.IQuantizationInfo|null} [quantizationInfo] NoteSequence quantizationInfo\n       * @property {tensorflow.magenta.NoteSequence.ISubsequenceInfo|null} [subsequenceInfo] NoteSequence subsequenceInfo\n       * @property {tensorflow.magenta.ISequenceMetadata|null} [sequenceMetadata] NoteSequence sequenceMetadata\n       */\n\n      /**\n       * Constructs a new NoteSequence.\n       * @memberof tensorflow.magenta\n       * @classdesc Represents a NoteSequence.\n       * @implements INoteSequence\n       * @constructor\n       * @param {tensorflow.magenta.INoteSequence=} [properties] Properties to set\n       */\n      function NoteSequence(properties) {\n        this.timeSignatures = [];\n        this.keySignatures = [];\n        this.tempos = [];\n        this.notes = [];\n        this.pitchBends = [];\n        this.controlChanges = [];\n        this.partInfos = [];\n        this.textAnnotations = [];\n        this.sectionAnnotations = [];\n        this.sectionGroups = [];\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n      }\n      /**\n       * NoteSequence id.\n       * @member {string} id\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n\n      NoteSequence.prototype.id = \"\";\n      /**\n       * NoteSequence filename.\n       * @member {string} filename\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.filename = \"\";\n      /**\n       * NoteSequence referenceNumber.\n       * @member {number} referenceNumber\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.referenceNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n      /**\n       * NoteSequence collectionName.\n       * @member {string} collectionName\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.collectionName = \"\";\n      /**\n       * NoteSequence ticksPerQuarter.\n       * @member {number} ticksPerQuarter\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.ticksPerQuarter = 0;\n      /**\n       * NoteSequence timeSignatures.\n       * @member {Array.<tensorflow.magenta.NoteSequence.ITimeSignature>} timeSignatures\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.timeSignatures = $util.emptyArray;\n      /**\n       * NoteSequence keySignatures.\n       * @member {Array.<tensorflow.magenta.NoteSequence.IKeySignature>} keySignatures\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.keySignatures = $util.emptyArray;\n      /**\n       * NoteSequence tempos.\n       * @member {Array.<tensorflow.magenta.NoteSequence.ITempo>} tempos\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.tempos = $util.emptyArray;\n      /**\n       * NoteSequence notes.\n       * @member {Array.<tensorflow.magenta.NoteSequence.INote>} notes\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.notes = $util.emptyArray;\n      /**\n       * NoteSequence totalTime.\n       * @member {number} totalTime\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.totalTime = 0;\n      /**\n       * NoteSequence totalQuantizedSteps.\n       * @member {number} totalQuantizedSteps\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.totalQuantizedSteps = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n      /**\n       * NoteSequence pitchBends.\n       * @member {Array.<tensorflow.magenta.NoteSequence.IPitchBend>} pitchBends\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.pitchBends = $util.emptyArray;\n      /**\n       * NoteSequence controlChanges.\n       * @member {Array.<tensorflow.magenta.NoteSequence.IControlChange>} controlChanges\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.controlChanges = $util.emptyArray;\n      /**\n       * NoteSequence partInfos.\n       * @member {Array.<tensorflow.magenta.NoteSequence.IPartInfo>} partInfos\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.partInfos = $util.emptyArray;\n      /**\n       * NoteSequence sourceInfo.\n       * @member {tensorflow.magenta.NoteSequence.ISourceInfo|null|undefined} sourceInfo\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.sourceInfo = null;\n      /**\n       * NoteSequence textAnnotations.\n       * @member {Array.<tensorflow.magenta.NoteSequence.ITextAnnotation>} textAnnotations\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.textAnnotations = $util.emptyArray;\n      /**\n       * NoteSequence sectionAnnotations.\n       * @member {Array.<tensorflow.magenta.NoteSequence.ISectionAnnotation>} sectionAnnotations\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.sectionAnnotations = $util.emptyArray;\n      /**\n       * NoteSequence sectionGroups.\n       * @member {Array.<tensorflow.magenta.NoteSequence.ISectionGroup>} sectionGroups\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.sectionGroups = $util.emptyArray;\n      /**\n       * NoteSequence quantizationInfo.\n       * @member {tensorflow.magenta.NoteSequence.IQuantizationInfo|null|undefined} quantizationInfo\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.quantizationInfo = null;\n      /**\n       * NoteSequence subsequenceInfo.\n       * @member {tensorflow.magenta.NoteSequence.ISubsequenceInfo|null|undefined} subsequenceInfo\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.subsequenceInfo = null;\n      /**\n       * NoteSequence sequenceMetadata.\n       * @member {tensorflow.magenta.ISequenceMetadata|null|undefined} sequenceMetadata\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       */\n\n      NoteSequence.prototype.sequenceMetadata = null;\n      /**\n       * Creates a new NoteSequence instance using the specified properties.\n       * @function create\n       * @memberof tensorflow.magenta.NoteSequence\n       * @static\n       * @param {tensorflow.magenta.INoteSequence=} [properties] Properties to set\n       * @returns {tensorflow.magenta.NoteSequence} NoteSequence instance\n       */\n\n      NoteSequence.create = function create(properties) {\n        return new NoteSequence(properties);\n      };\n      /**\n       * Encodes the specified NoteSequence message. Does not implicitly {@link tensorflow.magenta.NoteSequence.verify|verify} messages.\n       * @function encode\n       * @memberof tensorflow.magenta.NoteSequence\n       * @static\n       * @param {tensorflow.magenta.INoteSequence} message NoteSequence message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NoteSequence.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.id != null && message.hasOwnProperty(\"id\")) writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).string(message.id);\n        if (message.filename != null && message.hasOwnProperty(\"filename\")) writer.uint32(\n        /* id 2, wireType 2 =*/\n        18).string(message.filename);\n        if (message.collectionName != null && message.hasOwnProperty(\"collectionName\")) writer.uint32(\n        /* id 3, wireType 2 =*/\n        26).string(message.collectionName);\n        if (message.ticksPerQuarter != null && message.hasOwnProperty(\"ticksPerQuarter\")) writer.uint32(\n        /* id 4, wireType 0 =*/\n        32).int32(message.ticksPerQuarter);\n        if (message.timeSignatures != null && message.timeSignatures.length) for (var i = 0; i < message.timeSignatures.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.TimeSignature.encode(message.timeSignatures[i], writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).fork()).ldelim();\n        }\n        if (message.keySignatures != null && message.keySignatures.length) for (var i = 0; i < message.keySignatures.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.KeySignature.encode(message.keySignatures[i], writer.uint32(\n          /* id 6, wireType 2 =*/\n          50).fork()).ldelim();\n        }\n        if (message.tempos != null && message.tempos.length) for (var i = 0; i < message.tempos.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.Tempo.encode(message.tempos[i], writer.uint32(\n          /* id 7, wireType 2 =*/\n          58).fork()).ldelim();\n        }\n        if (message.notes != null && message.notes.length) for (var i = 0; i < message.notes.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.Note.encode(message.notes[i], writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).fork()).ldelim();\n        }\n        if (message.totalTime != null && message.hasOwnProperty(\"totalTime\")) writer.uint32(\n        /* id 9, wireType 1 =*/\n        73).double(message.totalTime);\n        if (message.pitchBends != null && message.pitchBends.length) for (var i = 0; i < message.pitchBends.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.PitchBend.encode(message.pitchBends[i], writer.uint32(\n          /* id 10, wireType 2 =*/\n          82).fork()).ldelim();\n        }\n        if (message.controlChanges != null && message.controlChanges.length) for (var i = 0; i < message.controlChanges.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.ControlChange.encode(message.controlChanges[i], writer.uint32(\n          /* id 11, wireType 2 =*/\n          90).fork()).ldelim();\n        }\n        if (message.partInfos != null && message.partInfos.length) for (var i = 0; i < message.partInfos.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.PartInfo.encode(message.partInfos[i], writer.uint32(\n          /* id 12, wireType 2 =*/\n          98).fork()).ldelim();\n        }\n        if (message.sourceInfo != null && message.hasOwnProperty(\"sourceInfo\")) $root.tensorflow.magenta.NoteSequence.SourceInfo.encode(message.sourceInfo, writer.uint32(\n        /* id 13, wireType 2 =*/\n        106).fork()).ldelim();\n        if (message.textAnnotations != null && message.textAnnotations.length) for (var i = 0; i < message.textAnnotations.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.TextAnnotation.encode(message.textAnnotations[i], writer.uint32(\n          /* id 14, wireType 2 =*/\n          114).fork()).ldelim();\n        }\n        if (message.quantizationInfo != null && message.hasOwnProperty(\"quantizationInfo\")) $root.tensorflow.magenta.NoteSequence.QuantizationInfo.encode(message.quantizationInfo, writer.uint32(\n        /* id 15, wireType 2 =*/\n        122).fork()).ldelim();\n        if (message.totalQuantizedSteps != null && message.hasOwnProperty(\"totalQuantizedSteps\")) writer.uint32(\n        /* id 16, wireType 0 =*/\n        128).int64(message.totalQuantizedSteps);\n        if (message.subsequenceInfo != null && message.hasOwnProperty(\"subsequenceInfo\")) $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.encode(message.subsequenceInfo, writer.uint32(\n        /* id 17, wireType 2 =*/\n        138).fork()).ldelim();\n        if (message.referenceNumber != null && message.hasOwnProperty(\"referenceNumber\")) writer.uint32(\n        /* id 18, wireType 0 =*/\n        144).int64(message.referenceNumber);\n        if (message.sequenceMetadata != null && message.hasOwnProperty(\"sequenceMetadata\")) $root.tensorflow.magenta.SequenceMetadata.encode(message.sequenceMetadata, writer.uint32(\n        /* id 19, wireType 2 =*/\n        154).fork()).ldelim();\n        if (message.sectionAnnotations != null && message.sectionAnnotations.length) for (var i = 0; i < message.sectionAnnotations.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.SectionAnnotation.encode(message.sectionAnnotations[i], writer.uint32(\n          /* id 20, wireType 2 =*/\n          162).fork()).ldelim();\n        }\n        if (message.sectionGroups != null && message.sectionGroups.length) for (var i = 0; i < message.sectionGroups.length; ++i) {\n          $root.tensorflow.magenta.NoteSequence.SectionGroup.encode(message.sectionGroups[i], writer.uint32(\n          /* id 21, wireType 2 =*/\n          170).fork()).ldelim();\n        }\n        return writer;\n      };\n      /**\n       * Encodes the specified NoteSequence message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof tensorflow.magenta.NoteSequence\n       * @static\n       * @param {tensorflow.magenta.INoteSequence} message NoteSequence message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NoteSequence.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a NoteSequence message from the specified reader or buffer.\n       * @function decode\n       * @memberof tensorflow.magenta.NoteSequence\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {tensorflow.magenta.NoteSequence} NoteSequence\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NoteSequence.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.tensorflow.magenta.NoteSequence();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.id = reader.string();\n              break;\n\n            case 2:\n              message.filename = reader.string();\n              break;\n\n            case 18:\n              message.referenceNumber = $util.Long ? reader.int64().toNumber() : reader.int64();\n              break;\n\n            case 3:\n              message.collectionName = reader.string();\n              break;\n\n            case 4:\n              message.ticksPerQuarter = reader.int32();\n              break;\n\n            case 5:\n              if (!(message.timeSignatures && message.timeSignatures.length)) message.timeSignatures = [];\n              message.timeSignatures.push($root.tensorflow.magenta.NoteSequence.TimeSignature.decode(reader, reader.uint32()));\n              break;\n\n            case 6:\n              if (!(message.keySignatures && message.keySignatures.length)) message.keySignatures = [];\n              message.keySignatures.push($root.tensorflow.magenta.NoteSequence.KeySignature.decode(reader, reader.uint32()));\n              break;\n\n            case 7:\n              if (!(message.tempos && message.tempos.length)) message.tempos = [];\n              message.tempos.push($root.tensorflow.magenta.NoteSequence.Tempo.decode(reader, reader.uint32()));\n              break;\n\n            case 8:\n              if (!(message.notes && message.notes.length)) message.notes = [];\n              message.notes.push($root.tensorflow.magenta.NoteSequence.Note.decode(reader, reader.uint32()));\n              break;\n\n            case 9:\n              message.totalTime = reader.double();\n              break;\n\n            case 16:\n              message.totalQuantizedSteps = $util.Long ? reader.int64().toNumber() : reader.int64();\n              break;\n\n            case 10:\n              if (!(message.pitchBends && message.pitchBends.length)) message.pitchBends = [];\n              message.pitchBends.push($root.tensorflow.magenta.NoteSequence.PitchBend.decode(reader, reader.uint32()));\n              break;\n\n            case 11:\n              if (!(message.controlChanges && message.controlChanges.length)) message.controlChanges = [];\n              message.controlChanges.push($root.tensorflow.magenta.NoteSequence.ControlChange.decode(reader, reader.uint32()));\n              break;\n\n            case 12:\n              if (!(message.partInfos && message.partInfos.length)) message.partInfos = [];\n              message.partInfos.push($root.tensorflow.magenta.NoteSequence.PartInfo.decode(reader, reader.uint32()));\n              break;\n\n            case 13:\n              message.sourceInfo = $root.tensorflow.magenta.NoteSequence.SourceInfo.decode(reader, reader.uint32());\n              break;\n\n            case 14:\n              if (!(message.textAnnotations && message.textAnnotations.length)) message.textAnnotations = [];\n              message.textAnnotations.push($root.tensorflow.magenta.NoteSequence.TextAnnotation.decode(reader, reader.uint32()));\n              break;\n\n            case 20:\n              if (!(message.sectionAnnotations && message.sectionAnnotations.length)) message.sectionAnnotations = [];\n              message.sectionAnnotations.push($root.tensorflow.magenta.NoteSequence.SectionAnnotation.decode(reader, reader.uint32()));\n              break;\n\n            case 21:\n              if (!(message.sectionGroups && message.sectionGroups.length)) message.sectionGroups = [];\n              message.sectionGroups.push($root.tensorflow.magenta.NoteSequence.SectionGroup.decode(reader, reader.uint32()));\n              break;\n\n            case 15:\n              message.quantizationInfo = $root.tensorflow.magenta.NoteSequence.QuantizationInfo.decode(reader, reader.uint32());\n              break;\n\n            case 17:\n              message.subsequenceInfo = $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.decode(reader, reader.uint32());\n              break;\n\n            case 19:\n              message.sequenceMetadata = $root.tensorflow.magenta.SequenceMetadata.decode(reader, reader.uint32());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a NoteSequence message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof tensorflow.magenta.NoteSequence\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {tensorflow.magenta.NoteSequence} NoteSequence\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NoteSequence.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a NoteSequence message.\n       * @function verify\n       * @memberof tensorflow.magenta.NoteSequence\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      NoteSequence.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n        if (message.id != null && message.hasOwnProperty(\"id\")) if (!$util.isString(message.id)) return \"id: string expected\";\n        if (message.filename != null && message.hasOwnProperty(\"filename\")) if (!$util.isString(message.filename)) return \"filename: string expected\";\n        if (message.referenceNumber != null && message.hasOwnProperty(\"referenceNumber\")) if (!$util.isInteger(message.referenceNumber) && !(message.referenceNumber && $util.isInteger(message.referenceNumber.low) && $util.isInteger(message.referenceNumber.high))) return \"referenceNumber: integer|Long expected\";\n        if (message.collectionName != null && message.hasOwnProperty(\"collectionName\")) if (!$util.isString(message.collectionName)) return \"collectionName: string expected\";\n        if (message.ticksPerQuarter != null && message.hasOwnProperty(\"ticksPerQuarter\")) if (!$util.isInteger(message.ticksPerQuarter)) return \"ticksPerQuarter: integer expected\";\n\n        if (message.timeSignatures != null && message.hasOwnProperty(\"timeSignatures\")) {\n          if (!Array.isArray(message.timeSignatures)) return \"timeSignatures: array expected\";\n\n          for (var i = 0; i < message.timeSignatures.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.TimeSignature.verify(message.timeSignatures[i]);\n            if (error) return \"timeSignatures.\" + error;\n          }\n        }\n\n        if (message.keySignatures != null && message.hasOwnProperty(\"keySignatures\")) {\n          if (!Array.isArray(message.keySignatures)) return \"keySignatures: array expected\";\n\n          for (var i = 0; i < message.keySignatures.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.KeySignature.verify(message.keySignatures[i]);\n            if (error) return \"keySignatures.\" + error;\n          }\n        }\n\n        if (message.tempos != null && message.hasOwnProperty(\"tempos\")) {\n          if (!Array.isArray(message.tempos)) return \"tempos: array expected\";\n\n          for (var i = 0; i < message.tempos.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.Tempo.verify(message.tempos[i]);\n            if (error) return \"tempos.\" + error;\n          }\n        }\n\n        if (message.notes != null && message.hasOwnProperty(\"notes\")) {\n          if (!Array.isArray(message.notes)) return \"notes: array expected\";\n\n          for (var i = 0; i < message.notes.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.Note.verify(message.notes[i]);\n            if (error) return \"notes.\" + error;\n          }\n        }\n\n        if (message.totalTime != null && message.hasOwnProperty(\"totalTime\")) if (typeof message.totalTime !== \"number\") return \"totalTime: number expected\";\n        if (message.totalQuantizedSteps != null && message.hasOwnProperty(\"totalQuantizedSteps\")) if (!$util.isInteger(message.totalQuantizedSteps) && !(message.totalQuantizedSteps && $util.isInteger(message.totalQuantizedSteps.low) && $util.isInteger(message.totalQuantizedSteps.high))) return \"totalQuantizedSteps: integer|Long expected\";\n\n        if (message.pitchBends != null && message.hasOwnProperty(\"pitchBends\")) {\n          if (!Array.isArray(message.pitchBends)) return \"pitchBends: array expected\";\n\n          for (var i = 0; i < message.pitchBends.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.PitchBend.verify(message.pitchBends[i]);\n            if (error) return \"pitchBends.\" + error;\n          }\n        }\n\n        if (message.controlChanges != null && message.hasOwnProperty(\"controlChanges\")) {\n          if (!Array.isArray(message.controlChanges)) return \"controlChanges: array expected\";\n\n          for (var i = 0; i < message.controlChanges.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.ControlChange.verify(message.controlChanges[i]);\n            if (error) return \"controlChanges.\" + error;\n          }\n        }\n\n        if (message.partInfos != null && message.hasOwnProperty(\"partInfos\")) {\n          if (!Array.isArray(message.partInfos)) return \"partInfos: array expected\";\n\n          for (var i = 0; i < message.partInfos.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.PartInfo.verify(message.partInfos[i]);\n            if (error) return \"partInfos.\" + error;\n          }\n        }\n\n        if (message.sourceInfo != null && message.hasOwnProperty(\"sourceInfo\")) {\n          var error = $root.tensorflow.magenta.NoteSequence.SourceInfo.verify(message.sourceInfo);\n          if (error) return \"sourceInfo.\" + error;\n        }\n\n        if (message.textAnnotations != null && message.hasOwnProperty(\"textAnnotations\")) {\n          if (!Array.isArray(message.textAnnotations)) return \"textAnnotations: array expected\";\n\n          for (var i = 0; i < message.textAnnotations.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.TextAnnotation.verify(message.textAnnotations[i]);\n            if (error) return \"textAnnotations.\" + error;\n          }\n        }\n\n        if (message.sectionAnnotations != null && message.hasOwnProperty(\"sectionAnnotations\")) {\n          if (!Array.isArray(message.sectionAnnotations)) return \"sectionAnnotations: array expected\";\n\n          for (var i = 0; i < message.sectionAnnotations.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.SectionAnnotation.verify(message.sectionAnnotations[i]);\n            if (error) return \"sectionAnnotations.\" + error;\n          }\n        }\n\n        if (message.sectionGroups != null && message.hasOwnProperty(\"sectionGroups\")) {\n          if (!Array.isArray(message.sectionGroups)) return \"sectionGroups: array expected\";\n\n          for (var i = 0; i < message.sectionGroups.length; ++i) {\n            var error = $root.tensorflow.magenta.NoteSequence.SectionGroup.verify(message.sectionGroups[i]);\n            if (error) return \"sectionGroups.\" + error;\n          }\n        }\n\n        if (message.quantizationInfo != null && message.hasOwnProperty(\"quantizationInfo\")) {\n          var error = $root.tensorflow.magenta.NoteSequence.QuantizationInfo.verify(message.quantizationInfo);\n          if (error) return \"quantizationInfo.\" + error;\n        }\n\n        if (message.subsequenceInfo != null && message.hasOwnProperty(\"subsequenceInfo\")) {\n          var error = $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.verify(message.subsequenceInfo);\n          if (error) return \"subsequenceInfo.\" + error;\n        }\n\n        if (message.sequenceMetadata != null && message.hasOwnProperty(\"sequenceMetadata\")) {\n          var error = $root.tensorflow.magenta.SequenceMetadata.verify(message.sequenceMetadata);\n          if (error) return \"sequenceMetadata.\" + error;\n        }\n\n        return null;\n      };\n      /**\n       * Creates a NoteSequence message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof tensorflow.magenta.NoteSequence\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {tensorflow.magenta.NoteSequence} NoteSequence\n       */\n\n\n      NoteSequence.fromObject = function fromObject(object) {\n        if (object instanceof $root.tensorflow.magenta.NoteSequence) return object;\n        var message = new $root.tensorflow.magenta.NoteSequence();\n        if (object.id != null) message.id = String(object.id);\n        if (object.filename != null) message.filename = String(object.filename);\n        if (object.referenceNumber != null) if ($util.Long) (message.referenceNumber = $util.Long.fromValue(object.referenceNumber)).unsigned = false;else if (typeof object.referenceNumber === \"string\") message.referenceNumber = parseInt(object.referenceNumber, 10);else if (typeof object.referenceNumber === \"number\") message.referenceNumber = object.referenceNumber;else if (typeof object.referenceNumber === \"object\") message.referenceNumber = new $util.LongBits(object.referenceNumber.low >>> 0, object.referenceNumber.high >>> 0).toNumber();\n        if (object.collectionName != null) message.collectionName = String(object.collectionName);\n        if (object.ticksPerQuarter != null) message.ticksPerQuarter = object.ticksPerQuarter | 0;\n\n        if (object.timeSignatures) {\n          if (!Array.isArray(object.timeSignatures)) throw TypeError(\".tensorflow.magenta.NoteSequence.timeSignatures: array expected\");\n          message.timeSignatures = [];\n\n          for (var i = 0; i < object.timeSignatures.length; ++i) {\n            if (typeof object.timeSignatures[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.timeSignatures: object expected\");\n            message.timeSignatures[i] = $root.tensorflow.magenta.NoteSequence.TimeSignature.fromObject(object.timeSignatures[i]);\n          }\n        }\n\n        if (object.keySignatures) {\n          if (!Array.isArray(object.keySignatures)) throw TypeError(\".tensorflow.magenta.NoteSequence.keySignatures: array expected\");\n          message.keySignatures = [];\n\n          for (var i = 0; i < object.keySignatures.length; ++i) {\n            if (typeof object.keySignatures[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.keySignatures: object expected\");\n            message.keySignatures[i] = $root.tensorflow.magenta.NoteSequence.KeySignature.fromObject(object.keySignatures[i]);\n          }\n        }\n\n        if (object.tempos) {\n          if (!Array.isArray(object.tempos)) throw TypeError(\".tensorflow.magenta.NoteSequence.tempos: array expected\");\n          message.tempos = [];\n\n          for (var i = 0; i < object.tempos.length; ++i) {\n            if (typeof object.tempos[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.tempos: object expected\");\n            message.tempos[i] = $root.tensorflow.magenta.NoteSequence.Tempo.fromObject(object.tempos[i]);\n          }\n        }\n\n        if (object.notes) {\n          if (!Array.isArray(object.notes)) throw TypeError(\".tensorflow.magenta.NoteSequence.notes: array expected\");\n          message.notes = [];\n\n          for (var i = 0; i < object.notes.length; ++i) {\n            if (typeof object.notes[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.notes: object expected\");\n            message.notes[i] = $root.tensorflow.magenta.NoteSequence.Note.fromObject(object.notes[i]);\n          }\n        }\n\n        if (object.totalTime != null) message.totalTime = Number(object.totalTime);\n        if (object.totalQuantizedSteps != null) if ($util.Long) (message.totalQuantizedSteps = $util.Long.fromValue(object.totalQuantizedSteps)).unsigned = false;else if (typeof object.totalQuantizedSteps === \"string\") message.totalQuantizedSteps = parseInt(object.totalQuantizedSteps, 10);else if (typeof object.totalQuantizedSteps === \"number\") message.totalQuantizedSteps = object.totalQuantizedSteps;else if (typeof object.totalQuantizedSteps === \"object\") message.totalQuantizedSteps = new $util.LongBits(object.totalQuantizedSteps.low >>> 0, object.totalQuantizedSteps.high >>> 0).toNumber();\n\n        if (object.pitchBends) {\n          if (!Array.isArray(object.pitchBends)) throw TypeError(\".tensorflow.magenta.NoteSequence.pitchBends: array expected\");\n          message.pitchBends = [];\n\n          for (var i = 0; i < object.pitchBends.length; ++i) {\n            if (typeof object.pitchBends[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.pitchBends: object expected\");\n            message.pitchBends[i] = $root.tensorflow.magenta.NoteSequence.PitchBend.fromObject(object.pitchBends[i]);\n          }\n        }\n\n        if (object.controlChanges) {\n          if (!Array.isArray(object.controlChanges)) throw TypeError(\".tensorflow.magenta.NoteSequence.controlChanges: array expected\");\n          message.controlChanges = [];\n\n          for (var i = 0; i < object.controlChanges.length; ++i) {\n            if (typeof object.controlChanges[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.controlChanges: object expected\");\n            message.controlChanges[i] = $root.tensorflow.magenta.NoteSequence.ControlChange.fromObject(object.controlChanges[i]);\n          }\n        }\n\n        if (object.partInfos) {\n          if (!Array.isArray(object.partInfos)) throw TypeError(\".tensorflow.magenta.NoteSequence.partInfos: array expected\");\n          message.partInfos = [];\n\n          for (var i = 0; i < object.partInfos.length; ++i) {\n            if (typeof object.partInfos[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.partInfos: object expected\");\n            message.partInfos[i] = $root.tensorflow.magenta.NoteSequence.PartInfo.fromObject(object.partInfos[i]);\n          }\n        }\n\n        if (object.sourceInfo != null) {\n          if (typeof object.sourceInfo !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.sourceInfo: object expected\");\n          message.sourceInfo = $root.tensorflow.magenta.NoteSequence.SourceInfo.fromObject(object.sourceInfo);\n        }\n\n        if (object.textAnnotations) {\n          if (!Array.isArray(object.textAnnotations)) throw TypeError(\".tensorflow.magenta.NoteSequence.textAnnotations: array expected\");\n          message.textAnnotations = [];\n\n          for (var i = 0; i < object.textAnnotations.length; ++i) {\n            if (typeof object.textAnnotations[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.textAnnotations: object expected\");\n            message.textAnnotations[i] = $root.tensorflow.magenta.NoteSequence.TextAnnotation.fromObject(object.textAnnotations[i]);\n          }\n        }\n\n        if (object.sectionAnnotations) {\n          if (!Array.isArray(object.sectionAnnotations)) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionAnnotations: array expected\");\n          message.sectionAnnotations = [];\n\n          for (var i = 0; i < object.sectionAnnotations.length; ++i) {\n            if (typeof object.sectionAnnotations[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.sectionAnnotations: object expected\");\n            message.sectionAnnotations[i] = $root.tensorflow.magenta.NoteSequence.SectionAnnotation.fromObject(object.sectionAnnotations[i]);\n          }\n        }\n\n        if (object.sectionGroups) {\n          if (!Array.isArray(object.sectionGroups)) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionGroups: array expected\");\n          message.sectionGroups = [];\n\n          for (var i = 0; i < object.sectionGroups.length; ++i) {\n            if (typeof object.sectionGroups[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.sectionGroups: object expected\");\n            message.sectionGroups[i] = $root.tensorflow.magenta.NoteSequence.SectionGroup.fromObject(object.sectionGroups[i]);\n          }\n        }\n\n        if (object.quantizationInfo != null) {\n          if (typeof object.quantizationInfo !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.quantizationInfo: object expected\");\n          message.quantizationInfo = $root.tensorflow.magenta.NoteSequence.QuantizationInfo.fromObject(object.quantizationInfo);\n        }\n\n        if (object.subsequenceInfo != null) {\n          if (typeof object.subsequenceInfo !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.subsequenceInfo: object expected\");\n          message.subsequenceInfo = $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.fromObject(object.subsequenceInfo);\n        }\n\n        if (object.sequenceMetadata != null) {\n          if (typeof object.sequenceMetadata !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.sequenceMetadata: object expected\");\n          message.sequenceMetadata = $root.tensorflow.magenta.SequenceMetadata.fromObject(object.sequenceMetadata);\n        }\n\n        return message;\n      };\n      /**\n       * Creates a plain object from a NoteSequence message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof tensorflow.magenta.NoteSequence\n       * @static\n       * @param {tensorflow.magenta.NoteSequence} message NoteSequence\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      NoteSequence.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n\n        if (options.arrays || options.defaults) {\n          object.timeSignatures = [];\n          object.keySignatures = [];\n          object.tempos = [];\n          object.notes = [];\n          object.pitchBends = [];\n          object.controlChanges = [];\n          object.partInfos = [];\n          object.textAnnotations = [];\n          object.sectionAnnotations = [];\n          object.sectionGroups = [];\n        }\n\n        if (options.defaults) {\n          object.id = \"\";\n          object.filename = \"\";\n          object.collectionName = \"\";\n          object.ticksPerQuarter = 0;\n          object.totalTime = 0;\n          object.sourceInfo = null;\n          object.quantizationInfo = null;\n\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false);\n            object.totalQuantizedSteps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.totalQuantizedSteps = options.longs === String ? \"0\" : 0;\n\n          object.subsequenceInfo = null;\n\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false);\n            object.referenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.referenceNumber = options.longs === String ? \"0\" : 0;\n\n          object.sequenceMetadata = null;\n        }\n\n        if (message.id != null && message.hasOwnProperty(\"id\")) object.id = message.id;\n        if (message.filename != null && message.hasOwnProperty(\"filename\")) object.filename = message.filename;\n        if (message.collectionName != null && message.hasOwnProperty(\"collectionName\")) object.collectionName = message.collectionName;\n        if (message.ticksPerQuarter != null && message.hasOwnProperty(\"ticksPerQuarter\")) object.ticksPerQuarter = message.ticksPerQuarter;\n\n        if (message.timeSignatures && message.timeSignatures.length) {\n          object.timeSignatures = [];\n\n          for (var j = 0; j < message.timeSignatures.length; ++j) {\n            object.timeSignatures[j] = $root.tensorflow.magenta.NoteSequence.TimeSignature.toObject(message.timeSignatures[j], options);\n          }\n        }\n\n        if (message.keySignatures && message.keySignatures.length) {\n          object.keySignatures = [];\n\n          for (var j = 0; j < message.keySignatures.length; ++j) {\n            object.keySignatures[j] = $root.tensorflow.magenta.NoteSequence.KeySignature.toObject(message.keySignatures[j], options);\n          }\n        }\n\n        if (message.tempos && message.tempos.length) {\n          object.tempos = [];\n\n          for (var j = 0; j < message.tempos.length; ++j) {\n            object.tempos[j] = $root.tensorflow.magenta.NoteSequence.Tempo.toObject(message.tempos[j], options);\n          }\n        }\n\n        if (message.notes && message.notes.length) {\n          object.notes = [];\n\n          for (var j = 0; j < message.notes.length; ++j) {\n            object.notes[j] = $root.tensorflow.magenta.NoteSequence.Note.toObject(message.notes[j], options);\n          }\n        }\n\n        if (message.totalTime != null && message.hasOwnProperty(\"totalTime\")) object.totalTime = options.json && !isFinite(message.totalTime) ? String(message.totalTime) : message.totalTime;\n\n        if (message.pitchBends && message.pitchBends.length) {\n          object.pitchBends = [];\n\n          for (var j = 0; j < message.pitchBends.length; ++j) {\n            object.pitchBends[j] = $root.tensorflow.magenta.NoteSequence.PitchBend.toObject(message.pitchBends[j], options);\n          }\n        }\n\n        if (message.controlChanges && message.controlChanges.length) {\n          object.controlChanges = [];\n\n          for (var j = 0; j < message.controlChanges.length; ++j) {\n            object.controlChanges[j] = $root.tensorflow.magenta.NoteSequence.ControlChange.toObject(message.controlChanges[j], options);\n          }\n        }\n\n        if (message.partInfos && message.partInfos.length) {\n          object.partInfos = [];\n\n          for (var j = 0; j < message.partInfos.length; ++j) {\n            object.partInfos[j] = $root.tensorflow.magenta.NoteSequence.PartInfo.toObject(message.partInfos[j], options);\n          }\n        }\n\n        if (message.sourceInfo != null && message.hasOwnProperty(\"sourceInfo\")) object.sourceInfo = $root.tensorflow.magenta.NoteSequence.SourceInfo.toObject(message.sourceInfo, options);\n\n        if (message.textAnnotations && message.textAnnotations.length) {\n          object.textAnnotations = [];\n\n          for (var j = 0; j < message.textAnnotations.length; ++j) {\n            object.textAnnotations[j] = $root.tensorflow.magenta.NoteSequence.TextAnnotation.toObject(message.textAnnotations[j], options);\n          }\n        }\n\n        if (message.quantizationInfo != null && message.hasOwnProperty(\"quantizationInfo\")) object.quantizationInfo = $root.tensorflow.magenta.NoteSequence.QuantizationInfo.toObject(message.quantizationInfo, options);\n        if (message.totalQuantizedSteps != null && message.hasOwnProperty(\"totalQuantizedSteps\")) if (typeof message.totalQuantizedSteps === \"number\") object.totalQuantizedSteps = options.longs === String ? String(message.totalQuantizedSteps) : message.totalQuantizedSteps;else object.totalQuantizedSteps = options.longs === String ? $util.Long.prototype.toString.call(message.totalQuantizedSteps) : options.longs === Number ? new $util.LongBits(message.totalQuantizedSteps.low >>> 0, message.totalQuantizedSteps.high >>> 0).toNumber() : message.totalQuantizedSteps;\n        if (message.subsequenceInfo != null && message.hasOwnProperty(\"subsequenceInfo\")) object.subsequenceInfo = $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.toObject(message.subsequenceInfo, options);\n        if (message.referenceNumber != null && message.hasOwnProperty(\"referenceNumber\")) if (typeof message.referenceNumber === \"number\") object.referenceNumber = options.longs === String ? String(message.referenceNumber) : message.referenceNumber;else object.referenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.referenceNumber) : options.longs === Number ? new $util.LongBits(message.referenceNumber.low >>> 0, message.referenceNumber.high >>> 0).toNumber() : message.referenceNumber;\n        if (message.sequenceMetadata != null && message.hasOwnProperty(\"sequenceMetadata\")) object.sequenceMetadata = $root.tensorflow.magenta.SequenceMetadata.toObject(message.sequenceMetadata, options);\n\n        if (message.sectionAnnotations && message.sectionAnnotations.length) {\n          object.sectionAnnotations = [];\n\n          for (var j = 0; j < message.sectionAnnotations.length; ++j) {\n            object.sectionAnnotations[j] = $root.tensorflow.magenta.NoteSequence.SectionAnnotation.toObject(message.sectionAnnotations[j], options);\n          }\n        }\n\n        if (message.sectionGroups && message.sectionGroups.length) {\n          object.sectionGroups = [];\n\n          for (var j = 0; j < message.sectionGroups.length; ++j) {\n            object.sectionGroups[j] = $root.tensorflow.magenta.NoteSequence.SectionGroup.toObject(message.sectionGroups[j], options);\n          }\n        }\n\n        return object;\n      };\n      /**\n       * Converts this NoteSequence to JSON.\n       * @function toJSON\n       * @memberof tensorflow.magenta.NoteSequence\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      NoteSequence.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      NoteSequence.Note = function () {\n        /**\n         * Properties of a Note.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface INote\n         * @property {number|null} [pitch] Note pitch\n         * @property {tensorflow.magenta.NoteSequence.PitchName|null} [pitchName] Note pitchName\n         * @property {number|null} [velocity] Note velocity\n         * @property {number|null} [startTime] Note startTime\n         * @property {number|null} [quantizedStartStep] Note quantizedStartStep\n         * @property {number|null} [endTime] Note endTime\n         * @property {number|null} [quantizedEndStep] Note quantizedEndStep\n         * @property {number|null} [numerator] Note numerator\n         * @property {number|null} [denominator] Note denominator\n         * @property {number|null} [instrument] Note instrument\n         * @property {number|null} [program] Note program\n         * @property {boolean|null} [isDrum] Note isDrum\n         * @property {number|null} [part] Note part\n         * @property {number|null} [voice] Note voice\n         */\n\n        /**\n         * Constructs a new Note.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a Note.\n         * @implements INote\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.INote=} [properties] Properties to set\n         */\n        function Note(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Note pitch.\n         * @member {number} pitch\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n\n        Note.prototype.pitch = 0;\n        /**\n         * Note pitchName.\n         * @member {tensorflow.magenta.NoteSequence.PitchName} pitchName\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.pitchName = 0;\n        /**\n         * Note velocity.\n         * @member {number} velocity\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.velocity = 0;\n        /**\n         * Note startTime.\n         * @member {number} startTime\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.startTime = 0;\n        /**\n         * Note quantizedStartStep.\n         * @member {number} quantizedStartStep\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.quantizedStartStep = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Note endTime.\n         * @member {number} endTime\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.endTime = 0;\n        /**\n         * Note quantizedEndStep.\n         * @member {number} quantizedEndStep\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.quantizedEndStep = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Note numerator.\n         * @member {number} numerator\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.numerator = 0;\n        /**\n         * Note denominator.\n         * @member {number} denominator\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.denominator = 0;\n        /**\n         * Note instrument.\n         * @member {number} instrument\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.instrument = 0;\n        /**\n         * Note program.\n         * @member {number} program\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.program = 0;\n        /**\n         * Note isDrum.\n         * @member {boolean} isDrum\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.isDrum = false;\n        /**\n         * Note part.\n         * @member {number} part\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.part = 0;\n        /**\n         * Note voice.\n         * @member {number} voice\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         */\n\n        Note.prototype.voice = 0;\n        /**\n         * Creates a new Note instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.INote=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.Note} Note instance\n         */\n\n        Note.create = function create(properties) {\n          return new Note(properties);\n        };\n        /**\n         * Encodes the specified Note message. Does not implicitly {@link tensorflow.magenta.NoteSequence.Note.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.INote} message Note message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Note.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.pitch != null && message.hasOwnProperty(\"pitch\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.pitch);\n          if (message.velocity != null && message.hasOwnProperty(\"velocity\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.velocity);\n          if (message.startTime != null && message.hasOwnProperty(\"startTime\")) writer.uint32(\n          /* id 3, wireType 1 =*/\n          25).double(message.startTime);\n          if (message.endTime != null && message.hasOwnProperty(\"endTime\")) writer.uint32(\n          /* id 4, wireType 1 =*/\n          33).double(message.endTime);\n          if (message.numerator != null && message.hasOwnProperty(\"numerator\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).int32(message.numerator);\n          if (message.denominator != null && message.hasOwnProperty(\"denominator\")) writer.uint32(\n          /* id 6, wireType 0 =*/\n          48).int32(message.denominator);\n          if (message.instrument != null && message.hasOwnProperty(\"instrument\")) writer.uint32(\n          /* id 7, wireType 0 =*/\n          56).int32(message.instrument);\n          if (message.program != null && message.hasOwnProperty(\"program\")) writer.uint32(\n          /* id 8, wireType 0 =*/\n          64).int32(message.program);\n          if (message.isDrum != null && message.hasOwnProperty(\"isDrum\")) writer.uint32(\n          /* id 9, wireType 0 =*/\n          72).bool(message.isDrum);\n          if (message.part != null && message.hasOwnProperty(\"part\")) writer.uint32(\n          /* id 10, wireType 0 =*/\n          80).int32(message.part);\n          if (message.pitchName != null && message.hasOwnProperty(\"pitchName\")) writer.uint32(\n          /* id 11, wireType 0 =*/\n          88).int32(message.pitchName);\n          if (message.voice != null && message.hasOwnProperty(\"voice\")) writer.uint32(\n          /* id 12, wireType 0 =*/\n          96).int32(message.voice);\n          if (message.quantizedStartStep != null && message.hasOwnProperty(\"quantizedStartStep\")) writer.uint32(\n          /* id 13, wireType 0 =*/\n          104).int64(message.quantizedStartStep);\n          if (message.quantizedEndStep != null && message.hasOwnProperty(\"quantizedEndStep\")) writer.uint32(\n          /* id 14, wireType 0 =*/\n          112).int64(message.quantizedEndStep);\n          return writer;\n        };\n        /**\n         * Encodes the specified Note message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.Note.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.INote} message Note message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Note.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Note message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.Note} Note\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Note.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.Note();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.pitch = reader.int32();\n                break;\n\n              case 11:\n                message.pitchName = reader.int32();\n                break;\n\n              case 2:\n                message.velocity = reader.int32();\n                break;\n\n              case 3:\n                message.startTime = reader.double();\n                break;\n\n              case 13:\n                message.quantizedStartStep = $util.Long ? reader.int64().toNumber() : reader.int64();\n                break;\n\n              case 4:\n                message.endTime = reader.double();\n                break;\n\n              case 14:\n                message.quantizedEndStep = $util.Long ? reader.int64().toNumber() : reader.int64();\n                break;\n\n              case 5:\n                message.numerator = reader.int32();\n                break;\n\n              case 6:\n                message.denominator = reader.int32();\n                break;\n\n              case 7:\n                message.instrument = reader.int32();\n                break;\n\n              case 8:\n                message.program = reader.int32();\n                break;\n\n              case 9:\n                message.isDrum = reader.bool();\n                break;\n\n              case 10:\n                message.part = reader.int32();\n                break;\n\n              case 12:\n                message.voice = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Note message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.Note} Note\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Note.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Note message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Note.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.pitch != null && message.hasOwnProperty(\"pitch\")) if (!$util.isInteger(message.pitch)) return \"pitch: integer expected\";\n          if (message.pitchName != null && message.hasOwnProperty(\"pitchName\")) switch (message.pitchName) {\n            default:\n              return \"pitchName: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n            case 19:\n            case 20:\n            case 21:\n            case 22:\n            case 23:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 28:\n            case 29:\n            case 30:\n            case 31:\n            case 32:\n            case 33:\n            case 34:\n            case 35:\n              break;\n          }\n          if (message.velocity != null && message.hasOwnProperty(\"velocity\")) if (!$util.isInteger(message.velocity)) return \"velocity: integer expected\";\n          if (message.startTime != null && message.hasOwnProperty(\"startTime\")) if (typeof message.startTime !== \"number\") return \"startTime: number expected\";\n          if (message.quantizedStartStep != null && message.hasOwnProperty(\"quantizedStartStep\")) if (!$util.isInteger(message.quantizedStartStep) && !(message.quantizedStartStep && $util.isInteger(message.quantizedStartStep.low) && $util.isInteger(message.quantizedStartStep.high))) return \"quantizedStartStep: integer|Long expected\";\n          if (message.endTime != null && message.hasOwnProperty(\"endTime\")) if (typeof message.endTime !== \"number\") return \"endTime: number expected\";\n          if (message.quantizedEndStep != null && message.hasOwnProperty(\"quantizedEndStep\")) if (!$util.isInteger(message.quantizedEndStep) && !(message.quantizedEndStep && $util.isInteger(message.quantizedEndStep.low) && $util.isInteger(message.quantizedEndStep.high))) return \"quantizedEndStep: integer|Long expected\";\n          if (message.numerator != null && message.hasOwnProperty(\"numerator\")) if (!$util.isInteger(message.numerator)) return \"numerator: integer expected\";\n          if (message.denominator != null && message.hasOwnProperty(\"denominator\")) if (!$util.isInteger(message.denominator)) return \"denominator: integer expected\";\n          if (message.instrument != null && message.hasOwnProperty(\"instrument\")) if (!$util.isInteger(message.instrument)) return \"instrument: integer expected\";\n          if (message.program != null && message.hasOwnProperty(\"program\")) if (!$util.isInteger(message.program)) return \"program: integer expected\";\n          if (message.isDrum != null && message.hasOwnProperty(\"isDrum\")) if (typeof message.isDrum !== \"boolean\") return \"isDrum: boolean expected\";\n          if (message.part != null && message.hasOwnProperty(\"part\")) if (!$util.isInteger(message.part)) return \"part: integer expected\";\n          if (message.voice != null && message.hasOwnProperty(\"voice\")) if (!$util.isInteger(message.voice)) return \"voice: integer expected\";\n          return null;\n        };\n        /**\n         * Creates a Note message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.Note} Note\n         */\n\n\n        Note.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.Note) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.Note();\n          if (object.pitch != null) message.pitch = object.pitch | 0;\n\n          switch (object.pitchName) {\n            case \"UNKNOWN_PITCH_NAME\":\n            case 0:\n              message.pitchName = 0;\n              break;\n\n            case \"F_FLAT_FLAT\":\n            case 1:\n              message.pitchName = 1;\n              break;\n\n            case \"C_FLAT_FLAT\":\n            case 2:\n              message.pitchName = 2;\n              break;\n\n            case \"G_FLAT_FLAT\":\n            case 3:\n              message.pitchName = 3;\n              break;\n\n            case \"D_FLAT_FLAT\":\n            case 4:\n              message.pitchName = 4;\n              break;\n\n            case \"A_FLAT_FLAT\":\n            case 5:\n              message.pitchName = 5;\n              break;\n\n            case \"E_FLAT_FLAT\":\n            case 6:\n              message.pitchName = 6;\n              break;\n\n            case \"B_FLAT_FLAT\":\n            case 7:\n              message.pitchName = 7;\n              break;\n\n            case \"F_FLAT\":\n            case 8:\n              message.pitchName = 8;\n              break;\n\n            case \"C_FLAT\":\n            case 9:\n              message.pitchName = 9;\n              break;\n\n            case \"G_FLAT\":\n            case 10:\n              message.pitchName = 10;\n              break;\n\n            case \"D_FLAT\":\n            case 11:\n              message.pitchName = 11;\n              break;\n\n            case \"A_FLAT\":\n            case 12:\n              message.pitchName = 12;\n              break;\n\n            case \"E_FLAT\":\n            case 13:\n              message.pitchName = 13;\n              break;\n\n            case \"B_FLAT\":\n            case 14:\n              message.pitchName = 14;\n              break;\n\n            case \"F\":\n            case 15:\n              message.pitchName = 15;\n              break;\n\n            case \"C\":\n            case 16:\n              message.pitchName = 16;\n              break;\n\n            case \"G\":\n            case 17:\n              message.pitchName = 17;\n              break;\n\n            case \"D\":\n            case 18:\n              message.pitchName = 18;\n              break;\n\n            case \"A\":\n            case 19:\n              message.pitchName = 19;\n              break;\n\n            case \"E\":\n            case 20:\n              message.pitchName = 20;\n              break;\n\n            case \"B\":\n            case 21:\n              message.pitchName = 21;\n              break;\n\n            case \"F_SHARP\":\n            case 22:\n              message.pitchName = 22;\n              break;\n\n            case \"C_SHARP\":\n            case 23:\n              message.pitchName = 23;\n              break;\n\n            case \"G_SHARP\":\n            case 24:\n              message.pitchName = 24;\n              break;\n\n            case \"D_SHARP\":\n            case 25:\n              message.pitchName = 25;\n              break;\n\n            case \"A_SHARP\":\n            case 26:\n              message.pitchName = 26;\n              break;\n\n            case \"E_SHARP\":\n            case 27:\n              message.pitchName = 27;\n              break;\n\n            case \"B_SHARP\":\n            case 28:\n              message.pitchName = 28;\n              break;\n\n            case \"F_SHARP_SHARP\":\n            case 29:\n              message.pitchName = 29;\n              break;\n\n            case \"C_SHARP_SHARP\":\n            case 30:\n              message.pitchName = 30;\n              break;\n\n            case \"G_SHARP_SHARP\":\n            case 31:\n              message.pitchName = 31;\n              break;\n\n            case \"D_SHARP_SHARP\":\n            case 32:\n              message.pitchName = 32;\n              break;\n\n            case \"A_SHARP_SHARP\":\n            case 33:\n              message.pitchName = 33;\n              break;\n\n            case \"E_SHARP_SHARP\":\n            case 34:\n              message.pitchName = 34;\n              break;\n\n            case \"B_SHARP_SHARP\":\n            case 35:\n              message.pitchName = 35;\n              break;\n          }\n\n          if (object.velocity != null) message.velocity = object.velocity | 0;\n          if (object.startTime != null) message.startTime = Number(object.startTime);\n          if (object.quantizedStartStep != null) if ($util.Long) (message.quantizedStartStep = $util.Long.fromValue(object.quantizedStartStep)).unsigned = false;else if (typeof object.quantizedStartStep === \"string\") message.quantizedStartStep = parseInt(object.quantizedStartStep, 10);else if (typeof object.quantizedStartStep === \"number\") message.quantizedStartStep = object.quantizedStartStep;else if (typeof object.quantizedStartStep === \"object\") message.quantizedStartStep = new $util.LongBits(object.quantizedStartStep.low >>> 0, object.quantizedStartStep.high >>> 0).toNumber();\n          if (object.endTime != null) message.endTime = Number(object.endTime);\n          if (object.quantizedEndStep != null) if ($util.Long) (message.quantizedEndStep = $util.Long.fromValue(object.quantizedEndStep)).unsigned = false;else if (typeof object.quantizedEndStep === \"string\") message.quantizedEndStep = parseInt(object.quantizedEndStep, 10);else if (typeof object.quantizedEndStep === \"number\") message.quantizedEndStep = object.quantizedEndStep;else if (typeof object.quantizedEndStep === \"object\") message.quantizedEndStep = new $util.LongBits(object.quantizedEndStep.low >>> 0, object.quantizedEndStep.high >>> 0).toNumber();\n          if (object.numerator != null) message.numerator = object.numerator | 0;\n          if (object.denominator != null) message.denominator = object.denominator | 0;\n          if (object.instrument != null) message.instrument = object.instrument | 0;\n          if (object.program != null) message.program = object.program | 0;\n          if (object.isDrum != null) message.isDrum = Boolean(object.isDrum);\n          if (object.part != null) message.part = object.part | 0;\n          if (object.voice != null) message.voice = object.voice | 0;\n          return message;\n        };\n        /**\n         * Creates a plain object from a Note message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.Note} message Note\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Note.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.pitch = 0;\n            object.velocity = 0;\n            object.startTime = 0;\n            object.endTime = 0;\n            object.numerator = 0;\n            object.denominator = 0;\n            object.instrument = 0;\n            object.program = 0;\n            object.isDrum = false;\n            object.part = 0;\n            object.pitchName = options.enums === String ? \"UNKNOWN_PITCH_NAME\" : 0;\n            object.voice = 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.quantizedStartStep = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.quantizedStartStep = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.quantizedEndStep = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.quantizedEndStep = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.pitch != null && message.hasOwnProperty(\"pitch\")) object.pitch = message.pitch;\n          if (message.velocity != null && message.hasOwnProperty(\"velocity\")) object.velocity = message.velocity;\n          if (message.startTime != null && message.hasOwnProperty(\"startTime\")) object.startTime = options.json && !isFinite(message.startTime) ? String(message.startTime) : message.startTime;\n          if (message.endTime != null && message.hasOwnProperty(\"endTime\")) object.endTime = options.json && !isFinite(message.endTime) ? String(message.endTime) : message.endTime;\n          if (message.numerator != null && message.hasOwnProperty(\"numerator\")) object.numerator = message.numerator;\n          if (message.denominator != null && message.hasOwnProperty(\"denominator\")) object.denominator = message.denominator;\n          if (message.instrument != null && message.hasOwnProperty(\"instrument\")) object.instrument = message.instrument;\n          if (message.program != null && message.hasOwnProperty(\"program\")) object.program = message.program;\n          if (message.isDrum != null && message.hasOwnProperty(\"isDrum\")) object.isDrum = message.isDrum;\n          if (message.part != null && message.hasOwnProperty(\"part\")) object.part = message.part;\n          if (message.pitchName != null && message.hasOwnProperty(\"pitchName\")) object.pitchName = options.enums === String ? $root.tensorflow.magenta.NoteSequence.PitchName[message.pitchName] : message.pitchName;\n          if (message.voice != null && message.hasOwnProperty(\"voice\")) object.voice = message.voice;\n          if (message.quantizedStartStep != null && message.hasOwnProperty(\"quantizedStartStep\")) if (typeof message.quantizedStartStep === \"number\") object.quantizedStartStep = options.longs === String ? String(message.quantizedStartStep) : message.quantizedStartStep;else object.quantizedStartStep = options.longs === String ? $util.Long.prototype.toString.call(message.quantizedStartStep) : options.longs === Number ? new $util.LongBits(message.quantizedStartStep.low >>> 0, message.quantizedStartStep.high >>> 0).toNumber() : message.quantizedStartStep;\n          if (message.quantizedEndStep != null && message.hasOwnProperty(\"quantizedEndStep\")) if (typeof message.quantizedEndStep === \"number\") object.quantizedEndStep = options.longs === String ? String(message.quantizedEndStep) : message.quantizedEndStep;else object.quantizedEndStep = options.longs === String ? $util.Long.prototype.toString.call(message.quantizedEndStep) : options.longs === Number ? new $util.LongBits(message.quantizedEndStep.low >>> 0, message.quantizedEndStep.high >>> 0).toNumber() : message.quantizedEndStep;\n          return object;\n        };\n        /**\n         * Converts this Note to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.Note\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Note.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Note;\n      }();\n      /**\n       * PitchName enum.\n       * @name tensorflow.magenta.NoteSequence.PitchName\n       * @enum {string}\n       * @property {number} UNKNOWN_PITCH_NAME=0 UNKNOWN_PITCH_NAME value\n       * @property {number} F_FLAT_FLAT=1 F_FLAT_FLAT value\n       * @property {number} C_FLAT_FLAT=2 C_FLAT_FLAT value\n       * @property {number} G_FLAT_FLAT=3 G_FLAT_FLAT value\n       * @property {number} D_FLAT_FLAT=4 D_FLAT_FLAT value\n       * @property {number} A_FLAT_FLAT=5 A_FLAT_FLAT value\n       * @property {number} E_FLAT_FLAT=6 E_FLAT_FLAT value\n       * @property {number} B_FLAT_FLAT=7 B_FLAT_FLAT value\n       * @property {number} F_FLAT=8 F_FLAT value\n       * @property {number} C_FLAT=9 C_FLAT value\n       * @property {number} G_FLAT=10 G_FLAT value\n       * @property {number} D_FLAT=11 D_FLAT value\n       * @property {number} A_FLAT=12 A_FLAT value\n       * @property {number} E_FLAT=13 E_FLAT value\n       * @property {number} B_FLAT=14 B_FLAT value\n       * @property {number} F=15 F value\n       * @property {number} C=16 C value\n       * @property {number} G=17 G value\n       * @property {number} D=18 D value\n       * @property {number} A=19 A value\n       * @property {number} E=20 E value\n       * @property {number} B=21 B value\n       * @property {number} F_SHARP=22 F_SHARP value\n       * @property {number} C_SHARP=23 C_SHARP value\n       * @property {number} G_SHARP=24 G_SHARP value\n       * @property {number} D_SHARP=25 D_SHARP value\n       * @property {number} A_SHARP=26 A_SHARP value\n       * @property {number} E_SHARP=27 E_SHARP value\n       * @property {number} B_SHARP=28 B_SHARP value\n       * @property {number} F_SHARP_SHARP=29 F_SHARP_SHARP value\n       * @property {number} C_SHARP_SHARP=30 C_SHARP_SHARP value\n       * @property {number} G_SHARP_SHARP=31 G_SHARP_SHARP value\n       * @property {number} D_SHARP_SHARP=32 D_SHARP_SHARP value\n       * @property {number} A_SHARP_SHARP=33 A_SHARP_SHARP value\n       * @property {number} E_SHARP_SHARP=34 E_SHARP_SHARP value\n       * @property {number} B_SHARP_SHARP=35 B_SHARP_SHARP value\n       */\n\n\n      NoteSequence.PitchName = function () {\n        var valuesById = {},\n            values = Object.create(valuesById);\n        values[valuesById[0] = \"UNKNOWN_PITCH_NAME\"] = 0;\n        values[valuesById[1] = \"F_FLAT_FLAT\"] = 1;\n        values[valuesById[2] = \"C_FLAT_FLAT\"] = 2;\n        values[valuesById[3] = \"G_FLAT_FLAT\"] = 3;\n        values[valuesById[4] = \"D_FLAT_FLAT\"] = 4;\n        values[valuesById[5] = \"A_FLAT_FLAT\"] = 5;\n        values[valuesById[6] = \"E_FLAT_FLAT\"] = 6;\n        values[valuesById[7] = \"B_FLAT_FLAT\"] = 7;\n        values[valuesById[8] = \"F_FLAT\"] = 8;\n        values[valuesById[9] = \"C_FLAT\"] = 9;\n        values[valuesById[10] = \"G_FLAT\"] = 10;\n        values[valuesById[11] = \"D_FLAT\"] = 11;\n        values[valuesById[12] = \"A_FLAT\"] = 12;\n        values[valuesById[13] = \"E_FLAT\"] = 13;\n        values[valuesById[14] = \"B_FLAT\"] = 14;\n        values[valuesById[15] = \"F\"] = 15;\n        values[valuesById[16] = \"C\"] = 16;\n        values[valuesById[17] = \"G\"] = 17;\n        values[valuesById[18] = \"D\"] = 18;\n        values[valuesById[19] = \"A\"] = 19;\n        values[valuesById[20] = \"E\"] = 20;\n        values[valuesById[21] = \"B\"] = 21;\n        values[valuesById[22] = \"F_SHARP\"] = 22;\n        values[valuesById[23] = \"C_SHARP\"] = 23;\n        values[valuesById[24] = \"G_SHARP\"] = 24;\n        values[valuesById[25] = \"D_SHARP\"] = 25;\n        values[valuesById[26] = \"A_SHARP\"] = 26;\n        values[valuesById[27] = \"E_SHARP\"] = 27;\n        values[valuesById[28] = \"B_SHARP\"] = 28;\n        values[valuesById[29] = \"F_SHARP_SHARP\"] = 29;\n        values[valuesById[30] = \"C_SHARP_SHARP\"] = 30;\n        values[valuesById[31] = \"G_SHARP_SHARP\"] = 31;\n        values[valuesById[32] = \"D_SHARP_SHARP\"] = 32;\n        values[valuesById[33] = \"A_SHARP_SHARP\"] = 33;\n        values[valuesById[34] = \"E_SHARP_SHARP\"] = 34;\n        values[valuesById[35] = \"B_SHARP_SHARP\"] = 35;\n        return values;\n      }();\n\n      NoteSequence.TimeSignature = function () {\n        /**\n         * Properties of a TimeSignature.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface ITimeSignature\n         * @property {number|null} [time] TimeSignature time\n         * @property {number|null} [numerator] TimeSignature numerator\n         * @property {number|null} [denominator] TimeSignature denominator\n         */\n\n        /**\n         * Constructs a new TimeSignature.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a TimeSignature.\n         * @implements ITimeSignature\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.ITimeSignature=} [properties] Properties to set\n         */\n        function TimeSignature(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * TimeSignature time.\n         * @member {number} time\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @instance\n         */\n\n\n        TimeSignature.prototype.time = 0;\n        /**\n         * TimeSignature numerator.\n         * @member {number} numerator\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @instance\n         */\n\n        TimeSignature.prototype.numerator = 0;\n        /**\n         * TimeSignature denominator.\n         * @member {number} denominator\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @instance\n         */\n\n        TimeSignature.prototype.denominator = 0;\n        /**\n         * Creates a new TimeSignature instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ITimeSignature=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.TimeSignature} TimeSignature instance\n         */\n\n        TimeSignature.create = function create(properties) {\n          return new TimeSignature(properties);\n        };\n        /**\n         * Encodes the specified TimeSignature message. Does not implicitly {@link tensorflow.magenta.NoteSequence.TimeSignature.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ITimeSignature} message TimeSignature message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        TimeSignature.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.time != null && message.hasOwnProperty(\"time\")) writer.uint32(\n          /* id 1, wireType 1 =*/\n          9).double(message.time);\n          if (message.numerator != null && message.hasOwnProperty(\"numerator\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.numerator);\n          if (message.denominator != null && message.hasOwnProperty(\"denominator\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int32(message.denominator);\n          return writer;\n        };\n        /**\n         * Encodes the specified TimeSignature message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.TimeSignature.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ITimeSignature} message TimeSignature message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        TimeSignature.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a TimeSignature message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.TimeSignature} TimeSignature\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        TimeSignature.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.TimeSignature();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.time = reader.double();\n                break;\n\n              case 2:\n                message.numerator = reader.int32();\n                break;\n\n              case 3:\n                message.denominator = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a TimeSignature message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.TimeSignature} TimeSignature\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        TimeSignature.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a TimeSignature message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        TimeSignature.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.time != null && message.hasOwnProperty(\"time\")) if (typeof message.time !== \"number\") return \"time: number expected\";\n          if (message.numerator != null && message.hasOwnProperty(\"numerator\")) if (!$util.isInteger(message.numerator)) return \"numerator: integer expected\";\n          if (message.denominator != null && message.hasOwnProperty(\"denominator\")) if (!$util.isInteger(message.denominator)) return \"denominator: integer expected\";\n          return null;\n        };\n        /**\n         * Creates a TimeSignature message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.TimeSignature} TimeSignature\n         */\n\n\n        TimeSignature.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.TimeSignature) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.TimeSignature();\n          if (object.time != null) message.time = Number(object.time);\n          if (object.numerator != null) message.numerator = object.numerator | 0;\n          if (object.denominator != null) message.denominator = object.denominator | 0;\n          return message;\n        };\n        /**\n         * Creates a plain object from a TimeSignature message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.TimeSignature} message TimeSignature\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        TimeSignature.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.time = 0;\n            object.numerator = 0;\n            object.denominator = 0;\n          }\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;\n          if (message.numerator != null && message.hasOwnProperty(\"numerator\")) object.numerator = message.numerator;\n          if (message.denominator != null && message.hasOwnProperty(\"denominator\")) object.denominator = message.denominator;\n          return object;\n        };\n        /**\n         * Converts this TimeSignature to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.TimeSignature\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        TimeSignature.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return TimeSignature;\n      }();\n\n      NoteSequence.KeySignature = function () {\n        /**\n         * Properties of a KeySignature.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface IKeySignature\n         * @property {number|null} [time] KeySignature time\n         * @property {tensorflow.magenta.NoteSequence.KeySignature.Key|null} [key] KeySignature key\n         * @property {tensorflow.magenta.NoteSequence.KeySignature.Mode|null} [mode] KeySignature mode\n         */\n\n        /**\n         * Constructs a new KeySignature.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a KeySignature.\n         * @implements IKeySignature\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.IKeySignature=} [properties] Properties to set\n         */\n        function KeySignature(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * KeySignature time.\n         * @member {number} time\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @instance\n         */\n\n\n        KeySignature.prototype.time = 0;\n        /**\n         * KeySignature key.\n         * @member {tensorflow.magenta.NoteSequence.KeySignature.Key} key\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @instance\n         */\n\n        KeySignature.prototype.key = 0;\n        /**\n         * KeySignature mode.\n         * @member {tensorflow.magenta.NoteSequence.KeySignature.Mode} mode\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @instance\n         */\n\n        KeySignature.prototype.mode = 0;\n        /**\n         * Creates a new KeySignature instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IKeySignature=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.KeySignature} KeySignature instance\n         */\n\n        KeySignature.create = function create(properties) {\n          return new KeySignature(properties);\n        };\n        /**\n         * Encodes the specified KeySignature message. Does not implicitly {@link tensorflow.magenta.NoteSequence.KeySignature.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IKeySignature} message KeySignature message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        KeySignature.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.time != null && message.hasOwnProperty(\"time\")) writer.uint32(\n          /* id 1, wireType 1 =*/\n          9).double(message.time);\n          if (message.key != null && message.hasOwnProperty(\"key\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.key);\n          if (message.mode != null && message.hasOwnProperty(\"mode\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int32(message.mode);\n          return writer;\n        };\n        /**\n         * Encodes the specified KeySignature message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.KeySignature.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IKeySignature} message KeySignature message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        KeySignature.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a KeySignature message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.KeySignature} KeySignature\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        KeySignature.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.KeySignature();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.time = reader.double();\n                break;\n\n              case 2:\n                message.key = reader.int32();\n                break;\n\n              case 3:\n                message.mode = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a KeySignature message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.KeySignature} KeySignature\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        KeySignature.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a KeySignature message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        KeySignature.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.time != null && message.hasOwnProperty(\"time\")) if (typeof message.time !== \"number\") return \"time: number expected\";\n          if (message.key != null && message.hasOwnProperty(\"key\")) switch (message.key) {\n            default:\n              return \"key: enum value expected\";\n\n            case 0:\n            case 1:\n            case 1:\n            case 2:\n            case 3:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 6:\n            case 7:\n            case 8:\n            case 8:\n            case 9:\n            case 10:\n            case 10:\n            case 11:\n              break;\n          }\n          if (message.mode != null && message.hasOwnProperty(\"mode\")) switch (message.mode) {\n            default:\n              return \"mode: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n              break;\n          }\n          return null;\n        };\n        /**\n         * Creates a KeySignature message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.KeySignature} KeySignature\n         */\n\n\n        KeySignature.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.KeySignature) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.KeySignature();\n          if (object.time != null) message.time = Number(object.time);\n\n          switch (object.key) {\n            case \"C\":\n            case 0:\n              message.key = 0;\n              break;\n\n            case \"C_SHARP\":\n            case 1:\n              message.key = 1;\n              break;\n\n            case \"D_FLAT\":\n            case 1:\n              message.key = 1;\n              break;\n\n            case \"D\":\n            case 2:\n              message.key = 2;\n              break;\n\n            case \"D_SHARP\":\n            case 3:\n              message.key = 3;\n              break;\n\n            case \"E_FLAT\":\n            case 3:\n              message.key = 3;\n              break;\n\n            case \"E\":\n            case 4:\n              message.key = 4;\n              break;\n\n            case \"F\":\n            case 5:\n              message.key = 5;\n              break;\n\n            case \"F_SHARP\":\n            case 6:\n              message.key = 6;\n              break;\n\n            case \"G_FLAT\":\n            case 6:\n              message.key = 6;\n              break;\n\n            case \"G\":\n            case 7:\n              message.key = 7;\n              break;\n\n            case \"G_SHARP\":\n            case 8:\n              message.key = 8;\n              break;\n\n            case \"A_FLAT\":\n            case 8:\n              message.key = 8;\n              break;\n\n            case \"A\":\n            case 9:\n              message.key = 9;\n              break;\n\n            case \"A_SHARP\":\n            case 10:\n              message.key = 10;\n              break;\n\n            case \"B_FLAT\":\n            case 10:\n              message.key = 10;\n              break;\n\n            case \"B\":\n            case 11:\n              message.key = 11;\n              break;\n          }\n\n          switch (object.mode) {\n            case \"MAJOR\":\n            case 0:\n              message.mode = 0;\n              break;\n\n            case \"MINOR\":\n            case 1:\n              message.mode = 1;\n              break;\n\n            case \"NOT_SPECIFIED\":\n            case 2:\n              message.mode = 2;\n              break;\n\n            case \"MIXOLYDIAN\":\n            case 3:\n              message.mode = 3;\n              break;\n\n            case \"DORIAN\":\n            case 4:\n              message.mode = 4;\n              break;\n\n            case \"PHRYGIAN\":\n            case 5:\n              message.mode = 5;\n              break;\n\n            case \"LYDIAN\":\n            case 6:\n              message.mode = 6;\n              break;\n\n            case \"LOCRIAN\":\n            case 7:\n              message.mode = 7;\n              break;\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a KeySignature message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.KeySignature} message KeySignature\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        KeySignature.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.time = 0;\n            object.key = options.enums === String ? \"C\" : 0;\n            object.mode = options.enums === String ? \"MAJOR\" : 0;\n          }\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;\n          if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.enums === String ? $root.tensorflow.magenta.NoteSequence.KeySignature.Key[message.key] : message.key;\n          if (message.mode != null && message.hasOwnProperty(\"mode\")) object.mode = options.enums === String ? $root.tensorflow.magenta.NoteSequence.KeySignature.Mode[message.mode] : message.mode;\n          return object;\n        };\n        /**\n         * Converts this KeySignature to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.KeySignature\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        KeySignature.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        /**\n         * Key enum.\n         * @name tensorflow.magenta.NoteSequence.KeySignature.Key\n         * @enum {string}\n         * @property {number} C=0 C value\n         * @property {number} C_SHARP=1 C_SHARP value\n         * @property {number} D_FLAT=1 D_FLAT value\n         * @property {number} D=2 D value\n         * @property {number} D_SHARP=3 D_SHARP value\n         * @property {number} E_FLAT=3 E_FLAT value\n         * @property {number} E=4 E value\n         * @property {number} F=5 F value\n         * @property {number} F_SHARP=6 F_SHARP value\n         * @property {number} G_FLAT=6 G_FLAT value\n         * @property {number} G=7 G value\n         * @property {number} G_SHARP=8 G_SHARP value\n         * @property {number} A_FLAT=8 A_FLAT value\n         * @property {number} A=9 A value\n         * @property {number} A_SHARP=10 A_SHARP value\n         * @property {number} B_FLAT=10 B_FLAT value\n         * @property {number} B=11 B value\n         */\n\n\n        KeySignature.Key = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"C\"] = 0;\n          values[valuesById[1] = \"C_SHARP\"] = 1;\n          values[\"D_FLAT\"] = 1;\n          values[valuesById[2] = \"D\"] = 2;\n          values[valuesById[3] = \"D_SHARP\"] = 3;\n          values[\"E_FLAT\"] = 3;\n          values[valuesById[4] = \"E\"] = 4;\n          values[valuesById[5] = \"F\"] = 5;\n          values[valuesById[6] = \"F_SHARP\"] = 6;\n          values[\"G_FLAT\"] = 6;\n          values[valuesById[7] = \"G\"] = 7;\n          values[valuesById[8] = \"G_SHARP\"] = 8;\n          values[\"A_FLAT\"] = 8;\n          values[valuesById[9] = \"A\"] = 9;\n          values[valuesById[10] = \"A_SHARP\"] = 10;\n          values[\"B_FLAT\"] = 10;\n          values[valuesById[11] = \"B\"] = 11;\n          return values;\n        }();\n        /**\n         * Mode enum.\n         * @name tensorflow.magenta.NoteSequence.KeySignature.Mode\n         * @enum {string}\n         * @property {number} MAJOR=0 MAJOR value\n         * @property {number} MINOR=1 MINOR value\n         * @property {number} NOT_SPECIFIED=2 NOT_SPECIFIED value\n         * @property {number} MIXOLYDIAN=3 MIXOLYDIAN value\n         * @property {number} DORIAN=4 DORIAN value\n         * @property {number} PHRYGIAN=5 PHRYGIAN value\n         * @property {number} LYDIAN=6 LYDIAN value\n         * @property {number} LOCRIAN=7 LOCRIAN value\n         */\n\n\n        KeySignature.Mode = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"MAJOR\"] = 0;\n          values[valuesById[1] = \"MINOR\"] = 1;\n          values[valuesById[2] = \"NOT_SPECIFIED\"] = 2;\n          values[valuesById[3] = \"MIXOLYDIAN\"] = 3;\n          values[valuesById[4] = \"DORIAN\"] = 4;\n          values[valuesById[5] = \"PHRYGIAN\"] = 5;\n          values[valuesById[6] = \"LYDIAN\"] = 6;\n          values[valuesById[7] = \"LOCRIAN\"] = 7;\n          return values;\n        }();\n\n        return KeySignature;\n      }();\n\n      NoteSequence.Tempo = function () {\n        /**\n         * Properties of a Tempo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface ITempo\n         * @property {number|null} [time] Tempo time\n         * @property {number|null} [qpm] Tempo qpm\n         */\n\n        /**\n         * Constructs a new Tempo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a Tempo.\n         * @implements ITempo\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.ITempo=} [properties] Properties to set\n         */\n        function Tempo(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Tempo time.\n         * @member {number} time\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @instance\n         */\n\n\n        Tempo.prototype.time = 0;\n        /**\n         * Tempo qpm.\n         * @member {number} qpm\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @instance\n         */\n\n        Tempo.prototype.qpm = 0;\n        /**\n         * Creates a new Tempo instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ITempo=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.Tempo} Tempo instance\n         */\n\n        Tempo.create = function create(properties) {\n          return new Tempo(properties);\n        };\n        /**\n         * Encodes the specified Tempo message. Does not implicitly {@link tensorflow.magenta.NoteSequence.Tempo.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ITempo} message Tempo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Tempo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.time != null && message.hasOwnProperty(\"time\")) writer.uint32(\n          /* id 1, wireType 1 =*/\n          9).double(message.time);\n          if (message.qpm != null && message.hasOwnProperty(\"qpm\")) writer.uint32(\n          /* id 2, wireType 1 =*/\n          17).double(message.qpm);\n          return writer;\n        };\n        /**\n         * Encodes the specified Tempo message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.Tempo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ITempo} message Tempo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Tempo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Tempo message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.Tempo} Tempo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Tempo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.Tempo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.time = reader.double();\n                break;\n\n              case 2:\n                message.qpm = reader.double();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Tempo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.Tempo} Tempo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Tempo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Tempo message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Tempo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.time != null && message.hasOwnProperty(\"time\")) if (typeof message.time !== \"number\") return \"time: number expected\";\n          if (message.qpm != null && message.hasOwnProperty(\"qpm\")) if (typeof message.qpm !== \"number\") return \"qpm: number expected\";\n          return null;\n        };\n        /**\n         * Creates a Tempo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.Tempo} Tempo\n         */\n\n\n        Tempo.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.Tempo) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.Tempo();\n          if (object.time != null) message.time = Number(object.time);\n          if (object.qpm != null) message.qpm = Number(object.qpm);\n          return message;\n        };\n        /**\n         * Creates a plain object from a Tempo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.Tempo} message Tempo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Tempo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.time = 0;\n            object.qpm = 0;\n          }\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;\n          if (message.qpm != null && message.hasOwnProperty(\"qpm\")) object.qpm = options.json && !isFinite(message.qpm) ? String(message.qpm) : message.qpm;\n          return object;\n        };\n        /**\n         * Converts this Tempo to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.Tempo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Tempo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Tempo;\n      }();\n\n      NoteSequence.PitchBend = function () {\n        /**\n         * Properties of a PitchBend.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface IPitchBend\n         * @property {number|null} [time] PitchBend time\n         * @property {number|null} [bend] PitchBend bend\n         * @property {number|null} [instrument] PitchBend instrument\n         * @property {number|null} [program] PitchBend program\n         * @property {boolean|null} [isDrum] PitchBend isDrum\n         */\n\n        /**\n         * Constructs a new PitchBend.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a PitchBend.\n         * @implements IPitchBend\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.IPitchBend=} [properties] Properties to set\n         */\n        function PitchBend(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * PitchBend time.\n         * @member {number} time\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @instance\n         */\n\n\n        PitchBend.prototype.time = 0;\n        /**\n         * PitchBend bend.\n         * @member {number} bend\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @instance\n         */\n\n        PitchBend.prototype.bend = 0;\n        /**\n         * PitchBend instrument.\n         * @member {number} instrument\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @instance\n         */\n\n        PitchBend.prototype.instrument = 0;\n        /**\n         * PitchBend program.\n         * @member {number} program\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @instance\n         */\n\n        PitchBend.prototype.program = 0;\n        /**\n         * PitchBend isDrum.\n         * @member {boolean} isDrum\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @instance\n         */\n\n        PitchBend.prototype.isDrum = false;\n        /**\n         * Creates a new PitchBend instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IPitchBend=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.PitchBend} PitchBend instance\n         */\n\n        PitchBend.create = function create(properties) {\n          return new PitchBend(properties);\n        };\n        /**\n         * Encodes the specified PitchBend message. Does not implicitly {@link tensorflow.magenta.NoteSequence.PitchBend.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IPitchBend} message PitchBend message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        PitchBend.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.time != null && message.hasOwnProperty(\"time\")) writer.uint32(\n          /* id 1, wireType 1 =*/\n          9).double(message.time);\n          if (message.bend != null && message.hasOwnProperty(\"bend\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.bend);\n          if (message.instrument != null && message.hasOwnProperty(\"instrument\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int32(message.instrument);\n          if (message.program != null && message.hasOwnProperty(\"program\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int32(message.program);\n          if (message.isDrum != null && message.hasOwnProperty(\"isDrum\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).bool(message.isDrum);\n          return writer;\n        };\n        /**\n         * Encodes the specified PitchBend message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.PitchBend.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IPitchBend} message PitchBend message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        PitchBend.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a PitchBend message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.PitchBend} PitchBend\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        PitchBend.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.PitchBend();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.time = reader.double();\n                break;\n\n              case 2:\n                message.bend = reader.int32();\n                break;\n\n              case 3:\n                message.instrument = reader.int32();\n                break;\n\n              case 4:\n                message.program = reader.int32();\n                break;\n\n              case 5:\n                message.isDrum = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a PitchBend message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.PitchBend} PitchBend\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        PitchBend.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a PitchBend message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        PitchBend.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.time != null && message.hasOwnProperty(\"time\")) if (typeof message.time !== \"number\") return \"time: number expected\";\n          if (message.bend != null && message.hasOwnProperty(\"bend\")) if (!$util.isInteger(message.bend)) return \"bend: integer expected\";\n          if (message.instrument != null && message.hasOwnProperty(\"instrument\")) if (!$util.isInteger(message.instrument)) return \"instrument: integer expected\";\n          if (message.program != null && message.hasOwnProperty(\"program\")) if (!$util.isInteger(message.program)) return \"program: integer expected\";\n          if (message.isDrum != null && message.hasOwnProperty(\"isDrum\")) if (typeof message.isDrum !== \"boolean\") return \"isDrum: boolean expected\";\n          return null;\n        };\n        /**\n         * Creates a PitchBend message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.PitchBend} PitchBend\n         */\n\n\n        PitchBend.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.PitchBend) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.PitchBend();\n          if (object.time != null) message.time = Number(object.time);\n          if (object.bend != null) message.bend = object.bend | 0;\n          if (object.instrument != null) message.instrument = object.instrument | 0;\n          if (object.program != null) message.program = object.program | 0;\n          if (object.isDrum != null) message.isDrum = Boolean(object.isDrum);\n          return message;\n        };\n        /**\n         * Creates a plain object from a PitchBend message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.PitchBend} message PitchBend\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        PitchBend.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.time = 0;\n            object.bend = 0;\n            object.instrument = 0;\n            object.program = 0;\n            object.isDrum = false;\n          }\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;\n          if (message.bend != null && message.hasOwnProperty(\"bend\")) object.bend = message.bend;\n          if (message.instrument != null && message.hasOwnProperty(\"instrument\")) object.instrument = message.instrument;\n          if (message.program != null && message.hasOwnProperty(\"program\")) object.program = message.program;\n          if (message.isDrum != null && message.hasOwnProperty(\"isDrum\")) object.isDrum = message.isDrum;\n          return object;\n        };\n        /**\n         * Converts this PitchBend to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.PitchBend\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        PitchBend.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return PitchBend;\n      }();\n\n      NoteSequence.ControlChange = function () {\n        /**\n         * Properties of a ControlChange.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface IControlChange\n         * @property {number|null} [time] ControlChange time\n         * @property {number|null} [quantizedStep] ControlChange quantizedStep\n         * @property {number|null} [controlNumber] ControlChange controlNumber\n         * @property {number|null} [controlValue] ControlChange controlValue\n         * @property {number|null} [instrument] ControlChange instrument\n         * @property {number|null} [program] ControlChange program\n         * @property {boolean|null} [isDrum] ControlChange isDrum\n         */\n\n        /**\n         * Constructs a new ControlChange.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a ControlChange.\n         * @implements IControlChange\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.IControlChange=} [properties] Properties to set\n         */\n        function ControlChange(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ControlChange time.\n         * @member {number} time\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @instance\n         */\n\n\n        ControlChange.prototype.time = 0;\n        /**\n         * ControlChange quantizedStep.\n         * @member {number} quantizedStep\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @instance\n         */\n\n        ControlChange.prototype.quantizedStep = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * ControlChange controlNumber.\n         * @member {number} controlNumber\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @instance\n         */\n\n        ControlChange.prototype.controlNumber = 0;\n        /**\n         * ControlChange controlValue.\n         * @member {number} controlValue\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @instance\n         */\n\n        ControlChange.prototype.controlValue = 0;\n        /**\n         * ControlChange instrument.\n         * @member {number} instrument\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @instance\n         */\n\n        ControlChange.prototype.instrument = 0;\n        /**\n         * ControlChange program.\n         * @member {number} program\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @instance\n         */\n\n        ControlChange.prototype.program = 0;\n        /**\n         * ControlChange isDrum.\n         * @member {boolean} isDrum\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @instance\n         */\n\n        ControlChange.prototype.isDrum = false;\n        /**\n         * Creates a new ControlChange instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IControlChange=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.ControlChange} ControlChange instance\n         */\n\n        ControlChange.create = function create(properties) {\n          return new ControlChange(properties);\n        };\n        /**\n         * Encodes the specified ControlChange message. Does not implicitly {@link tensorflow.magenta.NoteSequence.ControlChange.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IControlChange} message ControlChange message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ControlChange.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.time != null && message.hasOwnProperty(\"time\")) writer.uint32(\n          /* id 1, wireType 1 =*/\n          9).double(message.time);\n          if (message.controlNumber != null && message.hasOwnProperty(\"controlNumber\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.controlNumber);\n          if (message.controlValue != null && message.hasOwnProperty(\"controlValue\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int32(message.controlValue);\n          if (message.instrument != null && message.hasOwnProperty(\"instrument\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int32(message.instrument);\n          if (message.program != null && message.hasOwnProperty(\"program\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).int32(message.program);\n          if (message.isDrum != null && message.hasOwnProperty(\"isDrum\")) writer.uint32(\n          /* id 6, wireType 0 =*/\n          48).bool(message.isDrum);\n          if (message.quantizedStep != null && message.hasOwnProperty(\"quantizedStep\")) writer.uint32(\n          /* id 7, wireType 0 =*/\n          56).int64(message.quantizedStep);\n          return writer;\n        };\n        /**\n         * Encodes the specified ControlChange message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.ControlChange.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IControlChange} message ControlChange message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ControlChange.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ControlChange message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.ControlChange} ControlChange\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ControlChange.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.ControlChange();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.time = reader.double();\n                break;\n\n              case 7:\n                message.quantizedStep = $util.Long ? reader.int64().toNumber() : reader.int64();\n                break;\n\n              case 2:\n                message.controlNumber = reader.int32();\n                break;\n\n              case 3:\n                message.controlValue = reader.int32();\n                break;\n\n              case 4:\n                message.instrument = reader.int32();\n                break;\n\n              case 5:\n                message.program = reader.int32();\n                break;\n\n              case 6:\n                message.isDrum = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ControlChange message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.ControlChange} ControlChange\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ControlChange.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ControlChange message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ControlChange.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.time != null && message.hasOwnProperty(\"time\")) if (typeof message.time !== \"number\") return \"time: number expected\";\n          if (message.quantizedStep != null && message.hasOwnProperty(\"quantizedStep\")) if (!$util.isInteger(message.quantizedStep) && !(message.quantizedStep && $util.isInteger(message.quantizedStep.low) && $util.isInteger(message.quantizedStep.high))) return \"quantizedStep: integer|Long expected\";\n          if (message.controlNumber != null && message.hasOwnProperty(\"controlNumber\")) if (!$util.isInteger(message.controlNumber)) return \"controlNumber: integer expected\";\n          if (message.controlValue != null && message.hasOwnProperty(\"controlValue\")) if (!$util.isInteger(message.controlValue)) return \"controlValue: integer expected\";\n          if (message.instrument != null && message.hasOwnProperty(\"instrument\")) if (!$util.isInteger(message.instrument)) return \"instrument: integer expected\";\n          if (message.program != null && message.hasOwnProperty(\"program\")) if (!$util.isInteger(message.program)) return \"program: integer expected\";\n          if (message.isDrum != null && message.hasOwnProperty(\"isDrum\")) if (typeof message.isDrum !== \"boolean\") return \"isDrum: boolean expected\";\n          return null;\n        };\n        /**\n         * Creates a ControlChange message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.ControlChange} ControlChange\n         */\n\n\n        ControlChange.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.ControlChange) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.ControlChange();\n          if (object.time != null) message.time = Number(object.time);\n          if (object.quantizedStep != null) if ($util.Long) (message.quantizedStep = $util.Long.fromValue(object.quantizedStep)).unsigned = false;else if (typeof object.quantizedStep === \"string\") message.quantizedStep = parseInt(object.quantizedStep, 10);else if (typeof object.quantizedStep === \"number\") message.quantizedStep = object.quantizedStep;else if (typeof object.quantizedStep === \"object\") message.quantizedStep = new $util.LongBits(object.quantizedStep.low >>> 0, object.quantizedStep.high >>> 0).toNumber();\n          if (object.controlNumber != null) message.controlNumber = object.controlNumber | 0;\n          if (object.controlValue != null) message.controlValue = object.controlValue | 0;\n          if (object.instrument != null) message.instrument = object.instrument | 0;\n          if (object.program != null) message.program = object.program | 0;\n          if (object.isDrum != null) message.isDrum = Boolean(object.isDrum);\n          return message;\n        };\n        /**\n         * Creates a plain object from a ControlChange message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ControlChange} message ControlChange\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ControlChange.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.time = 0;\n            object.controlNumber = 0;\n            object.controlValue = 0;\n            object.instrument = 0;\n            object.program = 0;\n            object.isDrum = false;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.quantizedStep = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.quantizedStep = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;\n          if (message.controlNumber != null && message.hasOwnProperty(\"controlNumber\")) object.controlNumber = message.controlNumber;\n          if (message.controlValue != null && message.hasOwnProperty(\"controlValue\")) object.controlValue = message.controlValue;\n          if (message.instrument != null && message.hasOwnProperty(\"instrument\")) object.instrument = message.instrument;\n          if (message.program != null && message.hasOwnProperty(\"program\")) object.program = message.program;\n          if (message.isDrum != null && message.hasOwnProperty(\"isDrum\")) object.isDrum = message.isDrum;\n          if (message.quantizedStep != null && message.hasOwnProperty(\"quantizedStep\")) if (typeof message.quantizedStep === \"number\") object.quantizedStep = options.longs === String ? String(message.quantizedStep) : message.quantizedStep;else object.quantizedStep = options.longs === String ? $util.Long.prototype.toString.call(message.quantizedStep) : options.longs === Number ? new $util.LongBits(message.quantizedStep.low >>> 0, message.quantizedStep.high >>> 0).toNumber() : message.quantizedStep;\n          return object;\n        };\n        /**\n         * Converts this ControlChange to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.ControlChange\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ControlChange.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ControlChange;\n      }();\n\n      NoteSequence.PartInfo = function () {\n        /**\n         * Properties of a PartInfo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface IPartInfo\n         * @property {number|null} [part] PartInfo part\n         * @property {string|null} [name] PartInfo name\n         */\n\n        /**\n         * Constructs a new PartInfo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a PartInfo.\n         * @implements IPartInfo\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.IPartInfo=} [properties] Properties to set\n         */\n        function PartInfo(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * PartInfo part.\n         * @member {number} part\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @instance\n         */\n\n\n        PartInfo.prototype.part = 0;\n        /**\n         * PartInfo name.\n         * @member {string} name\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @instance\n         */\n\n        PartInfo.prototype.name = \"\";\n        /**\n         * Creates a new PartInfo instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IPartInfo=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.PartInfo} PartInfo instance\n         */\n\n        PartInfo.create = function create(properties) {\n          return new PartInfo(properties);\n        };\n        /**\n         * Encodes the specified PartInfo message. Does not implicitly {@link tensorflow.magenta.NoteSequence.PartInfo.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IPartInfo} message PartInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        PartInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.part != null && message.hasOwnProperty(\"part\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.part);\n          if (message.name != null && message.hasOwnProperty(\"name\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.name);\n          return writer;\n        };\n        /**\n         * Encodes the specified PartInfo message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.PartInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IPartInfo} message PartInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        PartInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a PartInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.PartInfo} PartInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        PartInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.PartInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.part = reader.int32();\n                break;\n\n              case 2:\n                message.name = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a PartInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.PartInfo} PartInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        PartInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a PartInfo message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        PartInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.part != null && message.hasOwnProperty(\"part\")) if (!$util.isInteger(message.part)) return \"part: integer expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n          return null;\n        };\n        /**\n         * Creates a PartInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.PartInfo} PartInfo\n         */\n\n\n        PartInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.PartInfo) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.PartInfo();\n          if (object.part != null) message.part = object.part | 0;\n          if (object.name != null) message.name = String(object.name);\n          return message;\n        };\n        /**\n         * Creates a plain object from a PartInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.PartInfo} message PartInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        PartInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.part = 0;\n            object.name = \"\";\n          }\n\n          if (message.part != null && message.hasOwnProperty(\"part\")) object.part = message.part;\n          if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n          return object;\n        };\n        /**\n         * Converts this PartInfo to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.PartInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        PartInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return PartInfo;\n      }();\n\n      NoteSequence.SourceInfo = function () {\n        /**\n         * Properties of a SourceInfo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface ISourceInfo\n         * @property {tensorflow.magenta.NoteSequence.SourceInfo.SourceType|null} [sourceType] SourceInfo sourceType\n         * @property {tensorflow.magenta.NoteSequence.SourceInfo.EncodingType|null} [encodingType] SourceInfo encodingType\n         * @property {tensorflow.magenta.NoteSequence.SourceInfo.Parser|null} [parser] SourceInfo parser\n         */\n\n        /**\n         * Constructs a new SourceInfo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a SourceInfo.\n         * @implements ISourceInfo\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.ISourceInfo=} [properties] Properties to set\n         */\n        function SourceInfo(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * SourceInfo sourceType.\n         * @member {tensorflow.magenta.NoteSequence.SourceInfo.SourceType} sourceType\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @instance\n         */\n\n\n        SourceInfo.prototype.sourceType = 0;\n        /**\n         * SourceInfo encodingType.\n         * @member {tensorflow.magenta.NoteSequence.SourceInfo.EncodingType} encodingType\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @instance\n         */\n\n        SourceInfo.prototype.encodingType = 0;\n        /**\n         * SourceInfo parser.\n         * @member {tensorflow.magenta.NoteSequence.SourceInfo.Parser} parser\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @instance\n         */\n\n        SourceInfo.prototype.parser = 0;\n        /**\n         * Creates a new SourceInfo instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISourceInfo=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.SourceInfo} SourceInfo instance\n         */\n\n        SourceInfo.create = function create(properties) {\n          return new SourceInfo(properties);\n        };\n        /**\n         * Encodes the specified SourceInfo message. Does not implicitly {@link tensorflow.magenta.NoteSequence.SourceInfo.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISourceInfo} message SourceInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SourceInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.sourceType != null && message.hasOwnProperty(\"sourceType\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.sourceType);\n          if (message.encodingType != null && message.hasOwnProperty(\"encodingType\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.encodingType);\n          if (message.parser != null && message.hasOwnProperty(\"parser\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int32(message.parser);\n          return writer;\n        };\n        /**\n         * Encodes the specified SourceInfo message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.SourceInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISourceInfo} message SourceInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SourceInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a SourceInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.SourceInfo} SourceInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SourceInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.SourceInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.sourceType = reader.int32();\n                break;\n\n              case 2:\n                message.encodingType = reader.int32();\n                break;\n\n              case 3:\n                message.parser = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a SourceInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.SourceInfo} SourceInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SourceInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a SourceInfo message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        SourceInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.sourceType != null && message.hasOwnProperty(\"sourceType\")) switch (message.sourceType) {\n            default:\n              return \"sourceType: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n              break;\n          }\n          if (message.encodingType != null && message.hasOwnProperty(\"encodingType\")) switch (message.encodingType) {\n            default:\n              return \"encodingType: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n              break;\n          }\n          if (message.parser != null && message.hasOwnProperty(\"parser\")) switch (message.parser) {\n            default:\n              return \"parser: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n              break;\n          }\n          return null;\n        };\n        /**\n         * Creates a SourceInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.SourceInfo} SourceInfo\n         */\n\n\n        SourceInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.SourceInfo) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.SourceInfo();\n\n          switch (object.sourceType) {\n            case \"UNKNOWN_SOURCE_TYPE\":\n            case 0:\n              message.sourceType = 0;\n              break;\n\n            case \"SCORE_BASED\":\n            case 1:\n              message.sourceType = 1;\n              break;\n\n            case \"PERFORMANCE_BASED\":\n            case 2:\n              message.sourceType = 2;\n              break;\n          }\n\n          switch (object.encodingType) {\n            case \"UNKNOWN_ENCODING_TYPE\":\n            case 0:\n              message.encodingType = 0;\n              break;\n\n            case \"MUSIC_XML\":\n            case 1:\n              message.encodingType = 1;\n              break;\n\n            case \"ABC\":\n            case 2:\n              message.encodingType = 2;\n              break;\n\n            case \"MIDI\":\n            case 3:\n              message.encodingType = 3;\n              break;\n\n            case \"MUSICNET\":\n            case 4:\n              message.encodingType = 4;\n              break;\n          }\n\n          switch (object.parser) {\n            case \"UNKNOWN_PARSER\":\n            case 0:\n              message.parser = 0;\n              break;\n\n            case \"MUSIC21\":\n            case 1:\n              message.parser = 1;\n              break;\n\n            case \"PRETTY_MIDI\":\n            case 2:\n              message.parser = 2;\n              break;\n\n            case \"MAGENTA_MUSIC_XML\":\n            case 3:\n              message.parser = 3;\n              break;\n\n            case \"MAGENTA_MUSICNET\":\n            case 4:\n              message.parser = 4;\n              break;\n\n            case \"MAGENTA_ABC\":\n            case 5:\n              message.parser = 5;\n              break;\n\n            case \"TONEJS_MIDI_CONVERT\":\n            case 6:\n              message.parser = 6;\n              break;\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a SourceInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.SourceInfo} message SourceInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        SourceInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.sourceType = options.enums === String ? \"UNKNOWN_SOURCE_TYPE\" : 0;\n            object.encodingType = options.enums === String ? \"UNKNOWN_ENCODING_TYPE\" : 0;\n            object.parser = options.enums === String ? \"UNKNOWN_PARSER\" : 0;\n          }\n\n          if (message.sourceType != null && message.hasOwnProperty(\"sourceType\")) object.sourceType = options.enums === String ? $root.tensorflow.magenta.NoteSequence.SourceInfo.SourceType[message.sourceType] : message.sourceType;\n          if (message.encodingType != null && message.hasOwnProperty(\"encodingType\")) object.encodingType = options.enums === String ? $root.tensorflow.magenta.NoteSequence.SourceInfo.EncodingType[message.encodingType] : message.encodingType;\n          if (message.parser != null && message.hasOwnProperty(\"parser\")) object.parser = options.enums === String ? $root.tensorflow.magenta.NoteSequence.SourceInfo.Parser[message.parser] : message.parser;\n          return object;\n        };\n        /**\n         * Converts this SourceInfo to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.SourceInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        SourceInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        /**\n         * SourceType enum.\n         * @name tensorflow.magenta.NoteSequence.SourceInfo.SourceType\n         * @enum {string}\n         * @property {number} UNKNOWN_SOURCE_TYPE=0 UNKNOWN_SOURCE_TYPE value\n         * @property {number} SCORE_BASED=1 SCORE_BASED value\n         * @property {number} PERFORMANCE_BASED=2 PERFORMANCE_BASED value\n         */\n\n\n        SourceInfo.SourceType = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"UNKNOWN_SOURCE_TYPE\"] = 0;\n          values[valuesById[1] = \"SCORE_BASED\"] = 1;\n          values[valuesById[2] = \"PERFORMANCE_BASED\"] = 2;\n          return values;\n        }();\n        /**\n         * EncodingType enum.\n         * @name tensorflow.magenta.NoteSequence.SourceInfo.EncodingType\n         * @enum {string}\n         * @property {number} UNKNOWN_ENCODING_TYPE=0 UNKNOWN_ENCODING_TYPE value\n         * @property {number} MUSIC_XML=1 MUSIC_XML value\n         * @property {number} ABC=2 ABC value\n         * @property {number} MIDI=3 MIDI value\n         * @property {number} MUSICNET=4 MUSICNET value\n         */\n\n\n        SourceInfo.EncodingType = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"UNKNOWN_ENCODING_TYPE\"] = 0;\n          values[valuesById[1] = \"MUSIC_XML\"] = 1;\n          values[valuesById[2] = \"ABC\"] = 2;\n          values[valuesById[3] = \"MIDI\"] = 3;\n          values[valuesById[4] = \"MUSICNET\"] = 4;\n          return values;\n        }();\n        /**\n         * Parser enum.\n         * @name tensorflow.magenta.NoteSequence.SourceInfo.Parser\n         * @enum {string}\n         * @property {number} UNKNOWN_PARSER=0 UNKNOWN_PARSER value\n         * @property {number} MUSIC21=1 MUSIC21 value\n         * @property {number} PRETTY_MIDI=2 PRETTY_MIDI value\n         * @property {number} MAGENTA_MUSIC_XML=3 MAGENTA_MUSIC_XML value\n         * @property {number} MAGENTA_MUSICNET=4 MAGENTA_MUSICNET value\n         * @property {number} MAGENTA_ABC=5 MAGENTA_ABC value\n         * @property {number} TONEJS_MIDI_CONVERT=6 TONEJS_MIDI_CONVERT value\n         */\n\n\n        SourceInfo.Parser = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"UNKNOWN_PARSER\"] = 0;\n          values[valuesById[1] = \"MUSIC21\"] = 1;\n          values[valuesById[2] = \"PRETTY_MIDI\"] = 2;\n          values[valuesById[3] = \"MAGENTA_MUSIC_XML\"] = 3;\n          values[valuesById[4] = \"MAGENTA_MUSICNET\"] = 4;\n          values[valuesById[5] = \"MAGENTA_ABC\"] = 5;\n          values[valuesById[6] = \"TONEJS_MIDI_CONVERT\"] = 6;\n          return values;\n        }();\n\n        return SourceInfo;\n      }();\n\n      NoteSequence.TextAnnotation = function () {\n        /**\n         * Properties of a TextAnnotation.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface ITextAnnotation\n         * @property {number|null} [time] TextAnnotation time\n         * @property {number|null} [quantizedStep] TextAnnotation quantizedStep\n         * @property {string|null} [text] TextAnnotation text\n         * @property {tensorflow.magenta.NoteSequence.TextAnnotation.TextAnnotationType|null} [annotationType] TextAnnotation annotationType\n         */\n\n        /**\n         * Constructs a new TextAnnotation.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a TextAnnotation.\n         * @implements ITextAnnotation\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.ITextAnnotation=} [properties] Properties to set\n         */\n        function TextAnnotation(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * TextAnnotation time.\n         * @member {number} time\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @instance\n         */\n\n\n        TextAnnotation.prototype.time = 0;\n        /**\n         * TextAnnotation quantizedStep.\n         * @member {number} quantizedStep\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @instance\n         */\n\n        TextAnnotation.prototype.quantizedStep = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * TextAnnotation text.\n         * @member {string} text\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @instance\n         */\n\n        TextAnnotation.prototype.text = \"\";\n        /**\n         * TextAnnotation annotationType.\n         * @member {tensorflow.magenta.NoteSequence.TextAnnotation.TextAnnotationType} annotationType\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @instance\n         */\n\n        TextAnnotation.prototype.annotationType = 0;\n        /**\n         * Creates a new TextAnnotation instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ITextAnnotation=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.TextAnnotation} TextAnnotation instance\n         */\n\n        TextAnnotation.create = function create(properties) {\n          return new TextAnnotation(properties);\n        };\n        /**\n         * Encodes the specified TextAnnotation message. Does not implicitly {@link tensorflow.magenta.NoteSequence.TextAnnotation.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ITextAnnotation} message TextAnnotation message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        TextAnnotation.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.time != null && message.hasOwnProperty(\"time\")) writer.uint32(\n          /* id 1, wireType 1 =*/\n          9).double(message.time);\n          if (message.text != null && message.hasOwnProperty(\"text\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.text);\n          if (message.annotationType != null && message.hasOwnProperty(\"annotationType\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int32(message.annotationType);\n          if (message.quantizedStep != null && message.hasOwnProperty(\"quantizedStep\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int64(message.quantizedStep);\n          return writer;\n        };\n        /**\n         * Encodes the specified TextAnnotation message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.TextAnnotation.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ITextAnnotation} message TextAnnotation message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        TextAnnotation.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a TextAnnotation message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.TextAnnotation} TextAnnotation\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        TextAnnotation.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.TextAnnotation();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.time = reader.double();\n                break;\n\n              case 4:\n                message.quantizedStep = $util.Long ? reader.int64().toNumber() : reader.int64();\n                break;\n\n              case 2:\n                message.text = reader.string();\n                break;\n\n              case 3:\n                message.annotationType = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a TextAnnotation message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.TextAnnotation} TextAnnotation\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        TextAnnotation.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a TextAnnotation message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        TextAnnotation.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.time != null && message.hasOwnProperty(\"time\")) if (typeof message.time !== \"number\") return \"time: number expected\";\n          if (message.quantizedStep != null && message.hasOwnProperty(\"quantizedStep\")) if (!$util.isInteger(message.quantizedStep) && !(message.quantizedStep && $util.isInteger(message.quantizedStep.low) && $util.isInteger(message.quantizedStep.high))) return \"quantizedStep: integer|Long expected\";\n          if (message.text != null && message.hasOwnProperty(\"text\")) if (!$util.isString(message.text)) return \"text: string expected\";\n          if (message.annotationType != null && message.hasOwnProperty(\"annotationType\")) switch (message.annotationType) {\n            default:\n              return \"annotationType: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n              break;\n          }\n          return null;\n        };\n        /**\n         * Creates a TextAnnotation message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.TextAnnotation} TextAnnotation\n         */\n\n\n        TextAnnotation.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.TextAnnotation) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.TextAnnotation();\n          if (object.time != null) message.time = Number(object.time);\n          if (object.quantizedStep != null) if ($util.Long) (message.quantizedStep = $util.Long.fromValue(object.quantizedStep)).unsigned = false;else if (typeof object.quantizedStep === \"string\") message.quantizedStep = parseInt(object.quantizedStep, 10);else if (typeof object.quantizedStep === \"number\") message.quantizedStep = object.quantizedStep;else if (typeof object.quantizedStep === \"object\") message.quantizedStep = new $util.LongBits(object.quantizedStep.low >>> 0, object.quantizedStep.high >>> 0).toNumber();\n          if (object.text != null) message.text = String(object.text);\n\n          switch (object.annotationType) {\n            case \"UNKNOWN\":\n            case 0:\n              message.annotationType = 0;\n              break;\n\n            case \"CHORD_SYMBOL\":\n            case 1:\n              message.annotationType = 1;\n              break;\n\n            case \"BEAT\":\n            case 2:\n              message.annotationType = 2;\n              break;\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a TextAnnotation message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.TextAnnotation} message TextAnnotation\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        TextAnnotation.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.time = 0;\n            object.text = \"\";\n            object.annotationType = options.enums === String ? \"UNKNOWN\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.quantizedStep = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.quantizedStep = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;\n          if (message.text != null && message.hasOwnProperty(\"text\")) object.text = message.text;\n          if (message.annotationType != null && message.hasOwnProperty(\"annotationType\")) object.annotationType = options.enums === String ? $root.tensorflow.magenta.NoteSequence.TextAnnotation.TextAnnotationType[message.annotationType] : message.annotationType;\n          if (message.quantizedStep != null && message.hasOwnProperty(\"quantizedStep\")) if (typeof message.quantizedStep === \"number\") object.quantizedStep = options.longs === String ? String(message.quantizedStep) : message.quantizedStep;else object.quantizedStep = options.longs === String ? $util.Long.prototype.toString.call(message.quantizedStep) : options.longs === Number ? new $util.LongBits(message.quantizedStep.low >>> 0, message.quantizedStep.high >>> 0).toNumber() : message.quantizedStep;\n          return object;\n        };\n        /**\n         * Converts this TextAnnotation to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.TextAnnotation\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        TextAnnotation.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        /**\n         * TextAnnotationType enum.\n         * @name tensorflow.magenta.NoteSequence.TextAnnotation.TextAnnotationType\n         * @enum {string}\n         * @property {number} UNKNOWN=0 UNKNOWN value\n         * @property {number} CHORD_SYMBOL=1 CHORD_SYMBOL value\n         * @property {number} BEAT=2 BEAT value\n         */\n\n\n        TextAnnotation.TextAnnotationType = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"UNKNOWN\"] = 0;\n          values[valuesById[1] = \"CHORD_SYMBOL\"] = 1;\n          values[valuesById[2] = \"BEAT\"] = 2;\n          return values;\n        }();\n\n        return TextAnnotation;\n      }();\n\n      NoteSequence.QuantizationInfo = function () {\n        /**\n         * Properties of a QuantizationInfo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface IQuantizationInfo\n         * @property {number|null} [stepsPerQuarter] QuantizationInfo stepsPerQuarter\n         * @property {number|null} [stepsPerSecond] QuantizationInfo stepsPerSecond\n         */\n\n        /**\n         * Constructs a new QuantizationInfo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a QuantizationInfo.\n         * @implements IQuantizationInfo\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.IQuantizationInfo=} [properties] Properties to set\n         */\n        function QuantizationInfo(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * QuantizationInfo stepsPerQuarter.\n         * @member {number} stepsPerQuarter\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @instance\n         */\n\n\n        QuantizationInfo.prototype.stepsPerQuarter = 0;\n        /**\n         * QuantizationInfo stepsPerSecond.\n         * @member {number} stepsPerSecond\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @instance\n         */\n\n        QuantizationInfo.prototype.stepsPerSecond = 0; // OneOf field names bound to virtual getters and setters\n\n        var $oneOfFields;\n        /**\n         * QuantizationInfo resolution.\n         * @member {\"stepsPerQuarter\"|\"stepsPerSecond\"|undefined} resolution\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @instance\n         */\n\n        Object.defineProperty(QuantizationInfo.prototype, \"resolution\", {\n          get: $util.oneOfGetter($oneOfFields = [\"stepsPerQuarter\", \"stepsPerSecond\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        /**\n         * Creates a new QuantizationInfo instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IQuantizationInfo=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.QuantizationInfo} QuantizationInfo instance\n         */\n\n        QuantizationInfo.create = function create(properties) {\n          return new QuantizationInfo(properties);\n        };\n        /**\n         * Encodes the specified QuantizationInfo message. Does not implicitly {@link tensorflow.magenta.NoteSequence.QuantizationInfo.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IQuantizationInfo} message QuantizationInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        QuantizationInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.stepsPerQuarter != null && message.hasOwnProperty(\"stepsPerQuarter\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.stepsPerQuarter);\n          if (message.stepsPerSecond != null && message.hasOwnProperty(\"stepsPerSecond\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.stepsPerSecond);\n          return writer;\n        };\n        /**\n         * Encodes the specified QuantizationInfo message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.QuantizationInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.IQuantizationInfo} message QuantizationInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        QuantizationInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a QuantizationInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.QuantizationInfo} QuantizationInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        QuantizationInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.QuantizationInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.stepsPerQuarter = reader.int32();\n                break;\n\n              case 2:\n                message.stepsPerSecond = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a QuantizationInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.QuantizationInfo} QuantizationInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        QuantizationInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a QuantizationInfo message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        QuantizationInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          var properties = {};\n\n          if (message.stepsPerQuarter != null && message.hasOwnProperty(\"stepsPerQuarter\")) {\n            properties.resolution = 1;\n            if (!$util.isInteger(message.stepsPerQuarter)) return \"stepsPerQuarter: integer expected\";\n          }\n\n          if (message.stepsPerSecond != null && message.hasOwnProperty(\"stepsPerSecond\")) {\n            if (properties.resolution === 1) return \"resolution: multiple values\";\n            properties.resolution = 1;\n            if (!$util.isInteger(message.stepsPerSecond)) return \"stepsPerSecond: integer expected\";\n          }\n\n          return null;\n        };\n        /**\n         * Creates a QuantizationInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.QuantizationInfo} QuantizationInfo\n         */\n\n\n        QuantizationInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.QuantizationInfo) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.QuantizationInfo();\n          if (object.stepsPerQuarter != null) message.stepsPerQuarter = object.stepsPerQuarter | 0;\n          if (object.stepsPerSecond != null) message.stepsPerSecond = object.stepsPerSecond | 0;\n          return message;\n        };\n        /**\n         * Creates a plain object from a QuantizationInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.QuantizationInfo} message QuantizationInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        QuantizationInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (message.stepsPerQuarter != null && message.hasOwnProperty(\"stepsPerQuarter\")) {\n            object.stepsPerQuarter = message.stepsPerQuarter;\n            if (options.oneofs) object.resolution = \"stepsPerQuarter\";\n          }\n\n          if (message.stepsPerSecond != null && message.hasOwnProperty(\"stepsPerSecond\")) {\n            object.stepsPerSecond = message.stepsPerSecond;\n            if (options.oneofs) object.resolution = \"stepsPerSecond\";\n          }\n\n          return object;\n        };\n        /**\n         * Converts this QuantizationInfo to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.QuantizationInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        QuantizationInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return QuantizationInfo;\n      }();\n\n      NoteSequence.SubsequenceInfo = function () {\n        /**\n         * Properties of a SubsequenceInfo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface ISubsequenceInfo\n         * @property {number|null} [startTimeOffset] SubsequenceInfo startTimeOffset\n         * @property {number|null} [endTimeOffset] SubsequenceInfo endTimeOffset\n         */\n\n        /**\n         * Constructs a new SubsequenceInfo.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a SubsequenceInfo.\n         * @implements ISubsequenceInfo\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.ISubsequenceInfo=} [properties] Properties to set\n         */\n        function SubsequenceInfo(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * SubsequenceInfo startTimeOffset.\n         * @member {number} startTimeOffset\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @instance\n         */\n\n\n        SubsequenceInfo.prototype.startTimeOffset = 0;\n        /**\n         * SubsequenceInfo endTimeOffset.\n         * @member {number} endTimeOffset\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @instance\n         */\n\n        SubsequenceInfo.prototype.endTimeOffset = 0;\n        /**\n         * Creates a new SubsequenceInfo instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISubsequenceInfo=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.SubsequenceInfo} SubsequenceInfo instance\n         */\n\n        SubsequenceInfo.create = function create(properties) {\n          return new SubsequenceInfo(properties);\n        };\n        /**\n         * Encodes the specified SubsequenceInfo message. Does not implicitly {@link tensorflow.magenta.NoteSequence.SubsequenceInfo.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISubsequenceInfo} message SubsequenceInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SubsequenceInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.startTimeOffset != null && message.hasOwnProperty(\"startTimeOffset\")) writer.uint32(\n          /* id 1, wireType 1 =*/\n          9).double(message.startTimeOffset);\n          if (message.endTimeOffset != null && message.hasOwnProperty(\"endTimeOffset\")) writer.uint32(\n          /* id 2, wireType 1 =*/\n          17).double(message.endTimeOffset);\n          return writer;\n        };\n        /**\n         * Encodes the specified SubsequenceInfo message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.SubsequenceInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISubsequenceInfo} message SubsequenceInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SubsequenceInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a SubsequenceInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.SubsequenceInfo} SubsequenceInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SubsequenceInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.SubsequenceInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.startTimeOffset = reader.double();\n                break;\n\n              case 2:\n                message.endTimeOffset = reader.double();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a SubsequenceInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.SubsequenceInfo} SubsequenceInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SubsequenceInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a SubsequenceInfo message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        SubsequenceInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.startTimeOffset != null && message.hasOwnProperty(\"startTimeOffset\")) if (typeof message.startTimeOffset !== \"number\") return \"startTimeOffset: number expected\";\n          if (message.endTimeOffset != null && message.hasOwnProperty(\"endTimeOffset\")) if (typeof message.endTimeOffset !== \"number\") return \"endTimeOffset: number expected\";\n          return null;\n        };\n        /**\n         * Creates a SubsequenceInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.SubsequenceInfo} SubsequenceInfo\n         */\n\n\n        SubsequenceInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.SubsequenceInfo) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.SubsequenceInfo();\n          if (object.startTimeOffset != null) message.startTimeOffset = Number(object.startTimeOffset);\n          if (object.endTimeOffset != null) message.endTimeOffset = Number(object.endTimeOffset);\n          return message;\n        };\n        /**\n         * Creates a plain object from a SubsequenceInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.SubsequenceInfo} message SubsequenceInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        SubsequenceInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.startTimeOffset = 0;\n            object.endTimeOffset = 0;\n          }\n\n          if (message.startTimeOffset != null && message.hasOwnProperty(\"startTimeOffset\")) object.startTimeOffset = options.json && !isFinite(message.startTimeOffset) ? String(message.startTimeOffset) : message.startTimeOffset;\n          if (message.endTimeOffset != null && message.hasOwnProperty(\"endTimeOffset\")) object.endTimeOffset = options.json && !isFinite(message.endTimeOffset) ? String(message.endTimeOffset) : message.endTimeOffset;\n          return object;\n        };\n        /**\n         * Converts this SubsequenceInfo to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.SubsequenceInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        SubsequenceInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SubsequenceInfo;\n      }();\n\n      NoteSequence.SectionAnnotation = function () {\n        /**\n         * Properties of a SectionAnnotation.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface ISectionAnnotation\n         * @property {number|null} [time] SectionAnnotation time\n         * @property {number|null} [sectionId] SectionAnnotation sectionId\n         */\n\n        /**\n         * Constructs a new SectionAnnotation.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a SectionAnnotation.\n         * @implements ISectionAnnotation\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.ISectionAnnotation=} [properties] Properties to set\n         */\n        function SectionAnnotation(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * SectionAnnotation time.\n         * @member {number} time\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @instance\n         */\n\n\n        SectionAnnotation.prototype.time = 0;\n        /**\n         * SectionAnnotation sectionId.\n         * @member {number} sectionId\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @instance\n         */\n\n        SectionAnnotation.prototype.sectionId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new SectionAnnotation instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISectionAnnotation=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.SectionAnnotation} SectionAnnotation instance\n         */\n\n        SectionAnnotation.create = function create(properties) {\n          return new SectionAnnotation(properties);\n        };\n        /**\n         * Encodes the specified SectionAnnotation message. Does not implicitly {@link tensorflow.magenta.NoteSequence.SectionAnnotation.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISectionAnnotation} message SectionAnnotation message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SectionAnnotation.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.time != null && message.hasOwnProperty(\"time\")) writer.uint32(\n          /* id 1, wireType 1 =*/\n          9).double(message.time);\n          if (message.sectionId != null && message.hasOwnProperty(\"sectionId\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int64(message.sectionId);\n          return writer;\n        };\n        /**\n         * Encodes the specified SectionAnnotation message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.SectionAnnotation.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISectionAnnotation} message SectionAnnotation message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SectionAnnotation.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a SectionAnnotation message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.SectionAnnotation} SectionAnnotation\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SectionAnnotation.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.SectionAnnotation();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.time = reader.double();\n                break;\n\n              case 4:\n                message.sectionId = $util.Long ? reader.int64().toNumber() : reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a SectionAnnotation message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.SectionAnnotation} SectionAnnotation\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SectionAnnotation.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a SectionAnnotation message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        SectionAnnotation.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.time != null && message.hasOwnProperty(\"time\")) if (typeof message.time !== \"number\") return \"time: number expected\";\n          if (message.sectionId != null && message.hasOwnProperty(\"sectionId\")) if (!$util.isInteger(message.sectionId) && !(message.sectionId && $util.isInteger(message.sectionId.low) && $util.isInteger(message.sectionId.high))) return \"sectionId: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a SectionAnnotation message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.SectionAnnotation} SectionAnnotation\n         */\n\n\n        SectionAnnotation.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.SectionAnnotation) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.SectionAnnotation();\n          if (object.time != null) message.time = Number(object.time);\n          if (object.sectionId != null) if ($util.Long) (message.sectionId = $util.Long.fromValue(object.sectionId)).unsigned = false;else if (typeof object.sectionId === \"string\") message.sectionId = parseInt(object.sectionId, 10);else if (typeof object.sectionId === \"number\") message.sectionId = object.sectionId;else if (typeof object.sectionId === \"object\") message.sectionId = new $util.LongBits(object.sectionId.low >>> 0, object.sectionId.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a SectionAnnotation message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.SectionAnnotation} message SectionAnnotation\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        SectionAnnotation.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.time = 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.sectionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.sectionId = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;\n          if (message.sectionId != null && message.hasOwnProperty(\"sectionId\")) if (typeof message.sectionId === \"number\") object.sectionId = options.longs === String ? String(message.sectionId) : message.sectionId;else object.sectionId = options.longs === String ? $util.Long.prototype.toString.call(message.sectionId) : options.longs === Number ? new $util.LongBits(message.sectionId.low >>> 0, message.sectionId.high >>> 0).toNumber() : message.sectionId;\n          return object;\n        };\n        /**\n         * Converts this SectionAnnotation to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.SectionAnnotation\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        SectionAnnotation.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SectionAnnotation;\n      }();\n\n      NoteSequence.Section = function () {\n        /**\n         * Properties of a Section.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface ISection\n         * @property {number|null} [sectionId] Section sectionId\n         * @property {tensorflow.magenta.NoteSequence.ISectionGroup|null} [sectionGroup] Section sectionGroup\n         */\n\n        /**\n         * Constructs a new Section.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a Section.\n         * @implements ISection\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.ISection=} [properties] Properties to set\n         */\n        function Section(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Section sectionId.\n         * @member {number} sectionId\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @instance\n         */\n\n\n        Section.prototype.sectionId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Section sectionGroup.\n         * @member {tensorflow.magenta.NoteSequence.ISectionGroup|null|undefined} sectionGroup\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @instance\n         */\n\n        Section.prototype.sectionGroup = null; // OneOf field names bound to virtual getters and setters\n\n        var $oneOfFields;\n        /**\n         * Section sectionType.\n         * @member {\"sectionId\"|\"sectionGroup\"|undefined} sectionType\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @instance\n         */\n\n        Object.defineProperty(Section.prototype, \"sectionType\", {\n          get: $util.oneOfGetter($oneOfFields = [\"sectionId\", \"sectionGroup\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        /**\n         * Creates a new Section instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISection=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.Section} Section instance\n         */\n\n        Section.create = function create(properties) {\n          return new Section(properties);\n        };\n        /**\n         * Encodes the specified Section message. Does not implicitly {@link tensorflow.magenta.NoteSequence.Section.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISection} message Section message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Section.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.sectionId != null && message.hasOwnProperty(\"sectionId\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.sectionId);\n          if (message.sectionGroup != null && message.hasOwnProperty(\"sectionGroup\")) $root.tensorflow.magenta.NoteSequence.SectionGroup.encode(message.sectionGroup, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified Section message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.Section.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISection} message Section message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Section.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Section message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.Section} Section\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Section.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.Section();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.sectionId = $util.Long ? reader.int64().toNumber() : reader.int64();\n                break;\n\n              case 2:\n                message.sectionGroup = $root.tensorflow.magenta.NoteSequence.SectionGroup.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Section message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.Section} Section\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Section.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Section message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Section.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          var properties = {};\n\n          if (message.sectionId != null && message.hasOwnProperty(\"sectionId\")) {\n            properties.sectionType = 1;\n            if (!$util.isInteger(message.sectionId) && !(message.sectionId && $util.isInteger(message.sectionId.low) && $util.isInteger(message.sectionId.high))) return \"sectionId: integer|Long expected\";\n          }\n\n          if (message.sectionGroup != null && message.hasOwnProperty(\"sectionGroup\")) {\n            if (properties.sectionType === 1) return \"sectionType: multiple values\";\n            properties.sectionType = 1;\n            {\n              var error = $root.tensorflow.magenta.NoteSequence.SectionGroup.verify(message.sectionGroup);\n              if (error) return \"sectionGroup.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a Section message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.Section} Section\n         */\n\n\n        Section.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.Section) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.Section();\n          if (object.sectionId != null) if ($util.Long) (message.sectionId = $util.Long.fromValue(object.sectionId)).unsigned = false;else if (typeof object.sectionId === \"string\") message.sectionId = parseInt(object.sectionId, 10);else if (typeof object.sectionId === \"number\") message.sectionId = object.sectionId;else if (typeof object.sectionId === \"object\") message.sectionId = new $util.LongBits(object.sectionId.low >>> 0, object.sectionId.high >>> 0).toNumber();\n\n          if (object.sectionGroup != null) {\n            if (typeof object.sectionGroup !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.Section.sectionGroup: object expected\");\n            message.sectionGroup = $root.tensorflow.magenta.NoteSequence.SectionGroup.fromObject(object.sectionGroup);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a Section message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.Section} message Section\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Section.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (message.sectionId != null && message.hasOwnProperty(\"sectionId\")) {\n            if (typeof message.sectionId === \"number\") object.sectionId = options.longs === String ? String(message.sectionId) : message.sectionId;else object.sectionId = options.longs === String ? $util.Long.prototype.toString.call(message.sectionId) : options.longs === Number ? new $util.LongBits(message.sectionId.low >>> 0, message.sectionId.high >>> 0).toNumber() : message.sectionId;\n            if (options.oneofs) object.sectionType = \"sectionId\";\n          }\n\n          if (message.sectionGroup != null && message.hasOwnProperty(\"sectionGroup\")) {\n            object.sectionGroup = $root.tensorflow.magenta.NoteSequence.SectionGroup.toObject(message.sectionGroup, options);\n            if (options.oneofs) object.sectionType = \"sectionGroup\";\n          }\n\n          return object;\n        };\n        /**\n         * Converts this Section to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.Section\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Section.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Section;\n      }();\n\n      NoteSequence.SectionGroup = function () {\n        /**\n         * Properties of a SectionGroup.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @interface ISectionGroup\n         * @property {Array.<tensorflow.magenta.NoteSequence.ISection>|null} [sections] SectionGroup sections\n         * @property {number|null} [numTimes] SectionGroup numTimes\n         */\n\n        /**\n         * Constructs a new SectionGroup.\n         * @memberof tensorflow.magenta.NoteSequence\n         * @classdesc Represents a SectionGroup.\n         * @implements ISectionGroup\n         * @constructor\n         * @param {tensorflow.magenta.NoteSequence.ISectionGroup=} [properties] Properties to set\n         */\n        function SectionGroup(properties) {\n          this.sections = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * SectionGroup sections.\n         * @member {Array.<tensorflow.magenta.NoteSequence.ISection>} sections\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @instance\n         */\n\n\n        SectionGroup.prototype.sections = $util.emptyArray;\n        /**\n         * SectionGroup numTimes.\n         * @member {number} numTimes\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @instance\n         */\n\n        SectionGroup.prototype.numTimes = 0;\n        /**\n         * Creates a new SectionGroup instance using the specified properties.\n         * @function create\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISectionGroup=} [properties] Properties to set\n         * @returns {tensorflow.magenta.NoteSequence.SectionGroup} SectionGroup instance\n         */\n\n        SectionGroup.create = function create(properties) {\n          return new SectionGroup(properties);\n        };\n        /**\n         * Encodes the specified SectionGroup message. Does not implicitly {@link tensorflow.magenta.NoteSequence.SectionGroup.verify|verify} messages.\n         * @function encode\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISectionGroup} message SectionGroup message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SectionGroup.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.sections != null && message.sections.length) for (var i = 0; i < message.sections.length; ++i) {\n            $root.tensorflow.magenta.NoteSequence.Section.encode(message.sections[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          if (message.numTimes != null && message.hasOwnProperty(\"numTimes\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.numTimes);\n          return writer;\n        };\n        /**\n         * Encodes the specified SectionGroup message, length delimited. Does not implicitly {@link tensorflow.magenta.NoteSequence.SectionGroup.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.ISectionGroup} message SectionGroup message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SectionGroup.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a SectionGroup message from the specified reader or buffer.\n         * @function decode\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tensorflow.magenta.NoteSequence.SectionGroup} SectionGroup\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SectionGroup.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tensorflow.magenta.NoteSequence.SectionGroup();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.sections && message.sections.length)) message.sections = [];\n                message.sections.push($root.tensorflow.magenta.NoteSequence.Section.decode(reader, reader.uint32()));\n                break;\n\n              case 2:\n                message.numTimes = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a SectionGroup message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tensorflow.magenta.NoteSequence.SectionGroup} SectionGroup\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SectionGroup.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a SectionGroup message.\n         * @function verify\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        SectionGroup.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.sections != null && message.hasOwnProperty(\"sections\")) {\n            if (!Array.isArray(message.sections)) return \"sections: array expected\";\n\n            for (var i = 0; i < message.sections.length; ++i) {\n              var error = $root.tensorflow.magenta.NoteSequence.Section.verify(message.sections[i]);\n              if (error) return \"sections.\" + error;\n            }\n          }\n\n          if (message.numTimes != null && message.hasOwnProperty(\"numTimes\")) if (!$util.isInteger(message.numTimes)) return \"numTimes: integer expected\";\n          return null;\n        };\n        /**\n         * Creates a SectionGroup message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tensorflow.magenta.NoteSequence.SectionGroup} SectionGroup\n         */\n\n\n        SectionGroup.fromObject = function fromObject(object) {\n          if (object instanceof $root.tensorflow.magenta.NoteSequence.SectionGroup) return object;\n          var message = new $root.tensorflow.magenta.NoteSequence.SectionGroup();\n\n          if (object.sections) {\n            if (!Array.isArray(object.sections)) throw TypeError(\".tensorflow.magenta.NoteSequence.SectionGroup.sections: array expected\");\n            message.sections = [];\n\n            for (var i = 0; i < object.sections.length; ++i) {\n              if (typeof object.sections[i] !== \"object\") throw TypeError(\".tensorflow.magenta.NoteSequence.SectionGroup.sections: object expected\");\n              message.sections[i] = $root.tensorflow.magenta.NoteSequence.Section.fromObject(object.sections[i]);\n            }\n          }\n\n          if (object.numTimes != null) message.numTimes = object.numTimes | 0;\n          return message;\n        };\n        /**\n         * Creates a plain object from a SectionGroup message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @static\n         * @param {tensorflow.magenta.NoteSequence.SectionGroup} message SectionGroup\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        SectionGroup.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.sections = [];\n          if (options.defaults) object.numTimes = 0;\n\n          if (message.sections && message.sections.length) {\n            object.sections = [];\n\n            for (var j = 0; j < message.sections.length; ++j) {\n              object.sections[j] = $root.tensorflow.magenta.NoteSequence.Section.toObject(message.sections[j], options);\n            }\n          }\n\n          if (message.numTimes != null && message.hasOwnProperty(\"numTimes\")) object.numTimes = message.numTimes;\n          return object;\n        };\n        /**\n         * Converts this SectionGroup to JSON.\n         * @function toJSON\n         * @memberof tensorflow.magenta.NoteSequence.SectionGroup\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        SectionGroup.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SectionGroup;\n      }();\n\n      return NoteSequence;\n    }();\n\n    magenta.SequenceMetadata = function () {\n      /**\n       * Properties of a SequenceMetadata.\n       * @memberof tensorflow.magenta\n       * @interface ISequenceMetadata\n       * @property {string|null} [title] SequenceMetadata title\n       * @property {string|null} [artist] SequenceMetadata artist\n       * @property {Array.<string>|null} [genre] SequenceMetadata genre\n       * @property {Array.<string>|null} [composers] SequenceMetadata composers\n       */\n\n      /**\n       * Constructs a new SequenceMetadata.\n       * @memberof tensorflow.magenta\n       * @classdesc Represents a SequenceMetadata.\n       * @implements ISequenceMetadata\n       * @constructor\n       * @param {tensorflow.magenta.ISequenceMetadata=} [properties] Properties to set\n       */\n      function SequenceMetadata(properties) {\n        this.genre = [];\n        this.composers = [];\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n      }\n      /**\n       * SequenceMetadata title.\n       * @member {string} title\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @instance\n       */\n\n\n      SequenceMetadata.prototype.title = \"\";\n      /**\n       * SequenceMetadata artist.\n       * @member {string} artist\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @instance\n       */\n\n      SequenceMetadata.prototype.artist = \"\";\n      /**\n       * SequenceMetadata genre.\n       * @member {Array.<string>} genre\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @instance\n       */\n\n      SequenceMetadata.prototype.genre = $util.emptyArray;\n      /**\n       * SequenceMetadata composers.\n       * @member {Array.<string>} composers\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @instance\n       */\n\n      SequenceMetadata.prototype.composers = $util.emptyArray;\n      /**\n       * Creates a new SequenceMetadata instance using the specified properties.\n       * @function create\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @static\n       * @param {tensorflow.magenta.ISequenceMetadata=} [properties] Properties to set\n       * @returns {tensorflow.magenta.SequenceMetadata} SequenceMetadata instance\n       */\n\n      SequenceMetadata.create = function create(properties) {\n        return new SequenceMetadata(properties);\n      };\n      /**\n       * Encodes the specified SequenceMetadata message. Does not implicitly {@link tensorflow.magenta.SequenceMetadata.verify|verify} messages.\n       * @function encode\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @static\n       * @param {tensorflow.magenta.ISequenceMetadata} message SequenceMetadata message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      SequenceMetadata.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.title != null && message.hasOwnProperty(\"title\")) writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).string(message.title);\n        if (message.artist != null && message.hasOwnProperty(\"artist\")) writer.uint32(\n        /* id 2, wireType 2 =*/\n        18).string(message.artist);\n        if (message.genre != null && message.genre.length) for (var i = 0; i < message.genre.length; ++i) {\n          writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.genre[i]);\n        }\n        if (message.composers != null && message.composers.length) for (var i = 0; i < message.composers.length; ++i) {\n          writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).string(message.composers[i]);\n        }\n        return writer;\n      };\n      /**\n       * Encodes the specified SequenceMetadata message, length delimited. Does not implicitly {@link tensorflow.magenta.SequenceMetadata.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @static\n       * @param {tensorflow.magenta.ISequenceMetadata} message SequenceMetadata message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      SequenceMetadata.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a SequenceMetadata message from the specified reader or buffer.\n       * @function decode\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {tensorflow.magenta.SequenceMetadata} SequenceMetadata\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      SequenceMetadata.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.tensorflow.magenta.SequenceMetadata();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.title = reader.string();\n              break;\n\n            case 2:\n              message.artist = reader.string();\n              break;\n\n            case 3:\n              if (!(message.genre && message.genre.length)) message.genre = [];\n              message.genre.push(reader.string());\n              break;\n\n            case 4:\n              if (!(message.composers && message.composers.length)) message.composers = [];\n              message.composers.push(reader.string());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a SequenceMetadata message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {tensorflow.magenta.SequenceMetadata} SequenceMetadata\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      SequenceMetadata.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a SequenceMetadata message.\n       * @function verify\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      SequenceMetadata.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n        if (message.title != null && message.hasOwnProperty(\"title\")) if (!$util.isString(message.title)) return \"title: string expected\";\n        if (message.artist != null && message.hasOwnProperty(\"artist\")) if (!$util.isString(message.artist)) return \"artist: string expected\";\n\n        if (message.genre != null && message.hasOwnProperty(\"genre\")) {\n          if (!Array.isArray(message.genre)) return \"genre: array expected\";\n\n          for (var i = 0; i < message.genre.length; ++i) {\n            if (!$util.isString(message.genre[i])) return \"genre: string[] expected\";\n          }\n        }\n\n        if (message.composers != null && message.hasOwnProperty(\"composers\")) {\n          if (!Array.isArray(message.composers)) return \"composers: array expected\";\n\n          for (var i = 0; i < message.composers.length; ++i) {\n            if (!$util.isString(message.composers[i])) return \"composers: string[] expected\";\n          }\n        }\n\n        return null;\n      };\n      /**\n       * Creates a SequenceMetadata message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {tensorflow.magenta.SequenceMetadata} SequenceMetadata\n       */\n\n\n      SequenceMetadata.fromObject = function fromObject(object) {\n        if (object instanceof $root.tensorflow.magenta.SequenceMetadata) return object;\n        var message = new $root.tensorflow.magenta.SequenceMetadata();\n        if (object.title != null) message.title = String(object.title);\n        if (object.artist != null) message.artist = String(object.artist);\n\n        if (object.genre) {\n          if (!Array.isArray(object.genre)) throw TypeError(\".tensorflow.magenta.SequenceMetadata.genre: array expected\");\n          message.genre = [];\n\n          for (var i = 0; i < object.genre.length; ++i) {\n            message.genre[i] = String(object.genre[i]);\n          }\n        }\n\n        if (object.composers) {\n          if (!Array.isArray(object.composers)) throw TypeError(\".tensorflow.magenta.SequenceMetadata.composers: array expected\");\n          message.composers = [];\n\n          for (var i = 0; i < object.composers.length; ++i) {\n            message.composers[i] = String(object.composers[i]);\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Creates a plain object from a SequenceMetadata message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @static\n       * @param {tensorflow.magenta.SequenceMetadata} message SequenceMetadata\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      SequenceMetadata.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n\n        if (options.arrays || options.defaults) {\n          object.genre = [];\n          object.composers = [];\n        }\n\n        if (options.defaults) {\n          object.title = \"\";\n          object.artist = \"\";\n        }\n\n        if (message.title != null && message.hasOwnProperty(\"title\")) object.title = message.title;\n        if (message.artist != null && message.hasOwnProperty(\"artist\")) object.artist = message.artist;\n\n        if (message.genre && message.genre.length) {\n          object.genre = [];\n\n          for (var j = 0; j < message.genre.length; ++j) {\n            object.genre[j] = message.genre[j];\n          }\n        }\n\n        if (message.composers && message.composers.length) {\n          object.composers = [];\n\n          for (var j = 0; j < message.composers.length; ++j) {\n            object.composers[j] = message.composers[j];\n          }\n        }\n\n        return object;\n      };\n      /**\n       * Converts this SequenceMetadata to JSON.\n       * @function toJSON\n       * @memberof tensorflow.magenta.SequenceMetadata\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      SequenceMetadata.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return SequenceMetadata;\n    }();\n\n    magenta.VelocityRange = function () {\n      /**\n       * Properties of a VelocityRange.\n       * @memberof tensorflow.magenta\n       * @interface IVelocityRange\n       * @property {number|null} [min] VelocityRange min\n       * @property {number|null} [max] VelocityRange max\n       */\n\n      /**\n       * Constructs a new VelocityRange.\n       * @memberof tensorflow.magenta\n       * @classdesc Represents a VelocityRange.\n       * @implements IVelocityRange\n       * @constructor\n       * @param {tensorflow.magenta.IVelocityRange=} [properties] Properties to set\n       */\n      function VelocityRange(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n      }\n      /**\n       * VelocityRange min.\n       * @member {number} min\n       * @memberof tensorflow.magenta.VelocityRange\n       * @instance\n       */\n\n\n      VelocityRange.prototype.min = 0;\n      /**\n       * VelocityRange max.\n       * @member {number} max\n       * @memberof tensorflow.magenta.VelocityRange\n       * @instance\n       */\n\n      VelocityRange.prototype.max = 0;\n      /**\n       * Creates a new VelocityRange instance using the specified properties.\n       * @function create\n       * @memberof tensorflow.magenta.VelocityRange\n       * @static\n       * @param {tensorflow.magenta.IVelocityRange=} [properties] Properties to set\n       * @returns {tensorflow.magenta.VelocityRange} VelocityRange instance\n       */\n\n      VelocityRange.create = function create(properties) {\n        return new VelocityRange(properties);\n      };\n      /**\n       * Encodes the specified VelocityRange message. Does not implicitly {@link tensorflow.magenta.VelocityRange.verify|verify} messages.\n       * @function encode\n       * @memberof tensorflow.magenta.VelocityRange\n       * @static\n       * @param {tensorflow.magenta.IVelocityRange} message VelocityRange message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      VelocityRange.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.min != null && message.hasOwnProperty(\"min\")) writer.uint32(\n        /* id 1, wireType 0 =*/\n        8).int32(message.min);\n        if (message.max != null && message.hasOwnProperty(\"max\")) writer.uint32(\n        /* id 2, wireType 0 =*/\n        16).int32(message.max);\n        return writer;\n      };\n      /**\n       * Encodes the specified VelocityRange message, length delimited. Does not implicitly {@link tensorflow.magenta.VelocityRange.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof tensorflow.magenta.VelocityRange\n       * @static\n       * @param {tensorflow.magenta.IVelocityRange} message VelocityRange message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      VelocityRange.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a VelocityRange message from the specified reader or buffer.\n       * @function decode\n       * @memberof tensorflow.magenta.VelocityRange\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {tensorflow.magenta.VelocityRange} VelocityRange\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      VelocityRange.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.tensorflow.magenta.VelocityRange();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.min = reader.int32();\n              break;\n\n            case 2:\n              message.max = reader.int32();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a VelocityRange message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof tensorflow.magenta.VelocityRange\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {tensorflow.magenta.VelocityRange} VelocityRange\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      VelocityRange.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a VelocityRange message.\n       * @function verify\n       * @memberof tensorflow.magenta.VelocityRange\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      VelocityRange.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n        if (message.min != null && message.hasOwnProperty(\"min\")) if (!$util.isInteger(message.min)) return \"min: integer expected\";\n        if (message.max != null && message.hasOwnProperty(\"max\")) if (!$util.isInteger(message.max)) return \"max: integer expected\";\n        return null;\n      };\n      /**\n       * Creates a VelocityRange message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof tensorflow.magenta.VelocityRange\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {tensorflow.magenta.VelocityRange} VelocityRange\n       */\n\n\n      VelocityRange.fromObject = function fromObject(object) {\n        if (object instanceof $root.tensorflow.magenta.VelocityRange) return object;\n        var message = new $root.tensorflow.magenta.VelocityRange();\n        if (object.min != null) message.min = object.min | 0;\n        if (object.max != null) message.max = object.max | 0;\n        return message;\n      };\n      /**\n       * Creates a plain object from a VelocityRange message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof tensorflow.magenta.VelocityRange\n       * @static\n       * @param {tensorflow.magenta.VelocityRange} message VelocityRange\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      VelocityRange.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n\n        if (options.defaults) {\n          object.min = 0;\n          object.max = 0;\n        }\n\n        if (message.min != null && message.hasOwnProperty(\"min\")) object.min = message.min;\n        if (message.max != null && message.hasOwnProperty(\"max\")) object.max = message.max;\n        return object;\n      };\n      /**\n       * Converts this VelocityRange to JSON.\n       * @function toJSON\n       * @memberof tensorflow.magenta.VelocityRange\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      VelocityRange.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return VelocityRange;\n    }();\n\n    return magenta;\n  }();\n\n  return tensorflow;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}