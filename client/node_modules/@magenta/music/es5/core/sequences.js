"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../protobuf/index");
var constants = require("./constants");
var QUANTIZE_CUTOFF = 0.5;
var MultipleTimeSignatureException = (function (_super) {
    __extends(MultipleTimeSignatureException, _super);
    function MultipleTimeSignatureException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return MultipleTimeSignatureException;
}(Error));
exports.MultipleTimeSignatureException = MultipleTimeSignatureException;
var BadTimeSignatureException = (function (_super) {
    __extends(BadTimeSignatureException, _super);
    function BadTimeSignatureException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return BadTimeSignatureException;
}(Error));
exports.BadTimeSignatureException = BadTimeSignatureException;
var NegativeTimeException = (function (_super) {
    __extends(NegativeTimeException, _super);
    function NegativeTimeException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return NegativeTimeException;
}(Error));
exports.NegativeTimeException = NegativeTimeException;
var MultipleTempoException = (function (_super) {
    __extends(MultipleTempoException, _super);
    function MultipleTempoException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return MultipleTempoException;
}(Error));
exports.MultipleTempoException = MultipleTempoException;
var QuantizationStatusException = (function (_super) {
    __extends(QuantizationStatusException, _super);
    function QuantizationStatusException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return QuantizationStatusException;
}(Error));
exports.QuantizationStatusException = QuantizationStatusException;
function isPowerOf2(n) {
    return n && (n & (n - 1)) === 0;
}
function clone(ns) {
    return index_1.NoteSequence.decode(index_1.NoteSequence.encode(ns).finish());
}
exports.clone = clone;
function stepsPerQuarterToStepsPerSecond(stepsPerQuarter, qpm) {
    return stepsPerQuarter * qpm / 60.0;
}
exports.stepsPerQuarterToStepsPerSecond = stepsPerQuarterToStepsPerSecond;
function quantizeToStep(unquantizedSeconds, stepsPerSecond, quantizeCutoff) {
    if (quantizeCutoff === void 0) { quantizeCutoff = QUANTIZE_CUTOFF; }
    var unquantizedSteps = unquantizedSeconds * stepsPerSecond;
    return Math.floor(unquantizedSteps + (1 - quantizeCutoff));
}
exports.quantizeToStep = quantizeToStep;
function getQuantizedTimeEvents(ns) {
    return ns.controlChanges.concat(ns.textAnnotations);
}
function quantizeNotesAndEvents(ns, stepsPerSecond) {
    for (var _i = 0, _a = ns.notes; _i < _a.length; _i++) {
        var note = _a[_i];
        note.quantizedStartStep = quantizeToStep(note.startTime, stepsPerSecond);
        note.quantizedEndStep = quantizeToStep(note.endTime, stepsPerSecond);
        if (note.quantizedEndStep === note.quantizedStartStep) {
            note.quantizedEndStep += 1;
        }
        if (note.quantizedStartStep < 0 || note.quantizedEndStep < 0) {
            throw new NegativeTimeException("Got negative note time: start_step = " +
                (note.quantizedStartStep + ", end_step = ") +
                ("" + note.quantizedEndStep));
        }
        if (note.quantizedEndStep > ns.totalQuantizedSteps) {
            ns.totalQuantizedSteps = note.quantizedEndStep;
        }
    }
    getQuantizedTimeEvents(ns).forEach(function (event) {
        event.quantizedStep = quantizeToStep(event.time, stepsPerSecond);
        if (event.quantizedStep < 0) {
            throw new NegativeTimeException("Got negative event time: step = " + event.quantizedStep);
        }
    });
}
function assertSingleTempo(ns) {
    if (!ns.tempos || ns.tempos.length === 0) {
        return;
    }
    ns.tempos.sort(function (a, b) { return a.time - b.time; });
    if (ns.tempos[0].time !== 0 &&
        ns.tempos[0].qpm !== constants.DEFAULT_QUARTERS_PER_MINUTE) {
        throw new MultipleTempoException('NoteSequence has an implicit tempo change from initial ' +
            (constants.DEFAULT_QUARTERS_PER_MINUTE + " qpm to ") +
            (ns.tempos[0].qpm + " qpm at " + ns.tempos[0].time + " seconds."));
    }
    for (var i = 1; i < ns.tempos.length; i++) {
        if (ns.tempos[i].qpm !== ns.tempos[0].qpm) {
            throw new MultipleTempoException('NoteSequence has at least one tempo change from ' +
                (ns.tempos[0].qpm + " qpm to " + ns.tempos[i].qpm) +
                ("qpm at " + ns.tempos[i].time + " seconds."));
        }
    }
}
function quantizeNoteSequence(ns, stepsPerQuarter) {
    var qns = clone(ns);
    qns.quantizationInfo =
        index_1.NoteSequence.QuantizationInfo.create({ stepsPerQuarter: stepsPerQuarter });
    if (qns.timeSignatures.length > 0) {
        qns.timeSignatures.sort(function (a, b) { return a.time - b.time; });
        if (qns.timeSignatures[0].time !== 0 &&
            !(qns.timeSignatures[0].numerator === 4 &&
                qns.timeSignatures[0].denominator === 4)) {
            throw new MultipleTimeSignatureException('NoteSequence has an implicit change from initial 4/4 time ' +
                ("signature to " + qns.timeSignatures[0].numerator + "/") +
                (qns.timeSignatures[0].denominator + " at ") +
                (qns.timeSignatures[0].time + " seconds."));
        }
        for (var i = 1; i < qns.timeSignatures.length; i++) {
            var timeSignature = qns.timeSignatures[i];
            if (timeSignature.numerator !== qns.timeSignatures[0].numerator ||
                timeSignature.denominator !== qns.timeSignatures[0].denominator) {
                throw new MultipleTimeSignatureException('NoteSequence has at least one time signature change from ' +
                    (qns.timeSignatures[0].numerator + "/") +
                    (qns.timeSignatures[0].denominator + " to ") +
                    (timeSignature.numerator + "/" + timeSignature.denominator + " ") +
                    ("at " + timeSignature.time + " seconds"));
            }
        }
        qns.timeSignatures[0].time = 0;
        qns.timeSignatures = [qns.timeSignatures[0]];
    }
    else {
        var timeSignature = index_1.NoteSequence.TimeSignature.create({ numerator: 4, denominator: 4, time: 0 });
        qns.timeSignatures.push(timeSignature);
    }
    var firstTS = qns.timeSignatures[0];
    if (!isPowerOf2(firstTS.denominator)) {
        throw new BadTimeSignatureException('Denominator is not a power of 2. Time signature: ' +
            (firstTS.numerator + "/" + firstTS.denominator));
    }
    if (firstTS.numerator === 0) {
        throw new BadTimeSignatureException('Numerator is 0. Time signature: ' +
            (firstTS.numerator + "/" + firstTS.denominator));
    }
    if (qns.tempos.length > 0) {
        assertSingleTempo(qns);
        qns.tempos[0].time = 0;
        qns.tempos = [qns.tempos[0]];
    }
    else {
        var tempo = index_1.NoteSequence.Tempo.create({ qpm: constants.DEFAULT_QUARTERS_PER_MINUTE, time: 0 });
        qns.tempos.push(tempo);
    }
    var stepsPerSecond = stepsPerQuarterToStepsPerSecond(stepsPerQuarter, qns.tempos[0].qpm);
    qns.totalQuantizedSteps = quantizeToStep(ns.totalTime, stepsPerSecond);
    quantizeNotesAndEvents(qns, stepsPerSecond);
    return qns;
}
exports.quantizeNoteSequence = quantizeNoteSequence;
function isQuantizedSequence(ns) {
    return ns.quantizationInfo &&
        (ns.quantizationInfo.stepsPerQuarter > 0 ||
            ns.quantizationInfo.stepsPerSecond > 0);
}
exports.isQuantizedSequence = isQuantizedSequence;
function assertIsQuantizedSequence(ns) {
    if (!isQuantizedSequence(ns)) {
        throw new QuantizationStatusException("NoteSequence " + ns.id + " is not quantized (missing quantizationInfo)");
    }
}
exports.assertIsQuantizedSequence = assertIsQuantizedSequence;
function isRelativeQuantizedSequence(ns) {
    return ns.quantizationInfo && ns.quantizationInfo.stepsPerQuarter > 0;
}
exports.isRelativeQuantizedSequence = isRelativeQuantizedSequence;
function assertIsRelativeQuantizedSequence(ns) {
    if (!isRelativeQuantizedSequence(ns)) {
        throw new QuantizationStatusException("NoteSequence " + ns.id + " is not quantized or is quantized based on absolute timing");
    }
}
exports.assertIsRelativeQuantizedSequence = assertIsRelativeQuantizedSequence;
function isAbsoluteQuantizedSequence(ns) {
    return ns.quantizationInfo && ns.quantizationInfo.stepsPerSecond > 0;
}
exports.isAbsoluteQuantizedSequence = isAbsoluteQuantizedSequence;
function assertIsAbsoluteQuantizedSequence(ns) {
    if (!isAbsoluteQuantizedSequence(ns)) {
        throw new QuantizationStatusException("NoteSequence " + ns.id + " is not quantized or is quantized based on relative timing");
    }
}
exports.assertIsAbsoluteQuantizedSequence = assertIsAbsoluteQuantizedSequence;
function unquantizeSequence(qns, qpm) {
    assertIsRelativeQuantizedSequence(qns);
    assertSingleTempo(qns);
    var ns = clone(qns);
    if (qpm) {
        if (ns.tempos && ns.tempos.length > 0) {
            ns.tempos[0].qpm = qpm;
        }
        else {
            ns.tempos.push(index_1.NoteSequence.Tempo.create({ time: 0, qpm: qpm }));
        }
    }
    else {
        qpm = (qns.tempos && qns.tempos.length > 0) ?
            ns.tempos[0].qpm :
            constants.DEFAULT_QUARTERS_PER_MINUTE;
    }
    var stepToSeconds = function (step) {
        return step / ns.quantizationInfo.stepsPerQuarter * (60 / qpm);
    };
    ns.totalTime = stepToSeconds(ns.totalQuantizedSteps);
    ns.notes.forEach(function (n) {
        n.startTime = stepToSeconds(n.quantizedStartStep);
        n.endTime = stepToSeconds(n.quantizedEndStep);
        ns.totalTime = Math.max(ns.totalTime, n.endTime);
    });
    getQuantizedTimeEvents(ns).forEach(function (event) {
        event.time = stepToSeconds(event.time);
    });
    return ns;
}
exports.unquantizeSequence = unquantizeSequence;
function mergeInstruments(ns) {
    var result = clone(ns);
    var events = result.notes.concat(result.pitchBends).concat(result.controlChanges);
    var programs = Array.from(new Set(events.filter(function (e) { return !e.isDrum; }).map(function (e) { return e.program; })));
    events.forEach(function (e) {
        if (e.isDrum) {
            e.program = 0;
            e.instrument = programs.length;
        }
        else {
            e.instrument = programs.indexOf(e.program);
        }
    });
    return result;
}
exports.mergeInstruments = mergeInstruments;
function replaceInstruments(originalSequence, replaceSequence) {
    var instrumentsInOriginal = new Set(originalSequence.notes.map(function (n) { return n.instrument; }));
    var instrumentsInReplace = new Set(replaceSequence.notes.map(function (n) { return n.instrument; }));
    var newNotes = [];
    originalSequence.notes.forEach(function (n) {
        if (!instrumentsInReplace.has(n.instrument)) {
            newNotes.push(index_1.NoteSequence.Note.create(n));
        }
    });
    replaceSequence.notes.forEach(function (n) {
        if (instrumentsInOriginal.has(n.instrument)) {
            newNotes.push(index_1.NoteSequence.Note.create(n));
        }
    });
    var output = clone(originalSequence);
    output.notes = newNotes.sort(function (a, b) {
        var voiceCompare = a.instrument - b.instrument;
        if (voiceCompare) {
            return voiceCompare;
        }
        return a.quantizedStartStep - b.quantizedStartStep;
    });
    return output;
}
exports.replaceInstruments = replaceInstruments;
function mergeConsecutiveNotes(sequence) {
    assertIsQuantizedSequence(sequence);
    var output = clone(sequence);
    output.notes = [];
    var newNotes = sequence.notes.sort(function (a, b) {
        var voiceCompare = a.instrument - b.instrument;
        if (voiceCompare) {
            return voiceCompare;
        }
        return a.quantizedStartStep - b.quantizedStartStep;
    });
    var note = new index_1.NoteSequence.Note();
    note.pitch = newNotes[0].pitch;
    note.instrument = newNotes[0].instrument;
    note.quantizedStartStep = newNotes[0].quantizedStartStep;
    note.quantizedEndStep = newNotes[0].quantizedEndStep;
    output.notes.push(note);
    var o = 0;
    for (var i = 1; i < newNotes.length; i++) {
        var thisNote = newNotes[i];
        var previousNote = output.notes[o];
        if (previousNote.instrument === thisNote.instrument &&
            previousNote.pitch === thisNote.pitch &&
            thisNote.quantizedStartStep === previousNote.quantizedEndStep &&
            thisNote.quantizedStartStep % 16 !== 0) {
            output.notes[o].quantizedEndStep +=
                thisNote.quantizedEndStep - thisNote.quantizedStartStep;
        }
        else {
            var note_1 = new index_1.NoteSequence.Note();
            note_1.pitch = newNotes[i].pitch;
            note_1.instrument = newNotes[i].instrument;
            note_1.quantizedStartStep = newNotes[i].quantizedStartStep;
            note_1.quantizedEndStep = newNotes[i].quantizedEndStep;
            output.notes.push(note_1);
            o++;
        }
    }
    return output;
}
exports.mergeConsecutiveNotes = mergeConsecutiveNotes;
function concatenate(concatenateSequences, sequenceDurations) {
    if (sequenceDurations &&
        sequenceDurations.length !== concatenateSequences.length) {
        throw new Error("Number of sequences to concatenate and their individual\n durations does not match.");
    }
    if (isQuantizedSequence(concatenateSequences[0])) {
        for (var i = 0; i < concatenateSequences.length; ++i) {
            assertIsQuantizedSequence(concatenateSequences[i]);
            if (concatenateSequences[i].quantizationInfo.stepsPerQuarter !==
                concatenateSequences[0].quantizationInfo.stepsPerQuarter) {
                throw new Error('Not all sequences have the same quantizationInfo');
            }
        }
        return concatenateHelper(concatenateSequences, 'totalQuantizedSteps', 'quantizedStartStep', 'quantizedEndStep', sequenceDurations);
    }
    else {
        return concatenateHelper(concatenateSequences, 'totalTime', 'startTime', 'endTime', sequenceDurations);
    }
}
exports.concatenate = concatenate;
function trim(ns, start, end, truncateEndNotes) {
    return isQuantizedSequence(ns) ?
        trimHelper(ns, start, end, 'totalQuantizedSteps', 'quantizedStartStep', 'quantizedEndStep', truncateEndNotes) :
        trimHelper(ns, start, end, 'totalTime', 'startTime', 'endTime', truncateEndNotes);
}
exports.trim = trim;
function concatenateHelper(seqs, totalKey, startKey, endKey, sequenceDurations) {
    var concatSeq;
    var totalDuration = 0;
    for (var i = 0; i < seqs.length; ++i) {
        var seqDuration = sequenceDurations ? sequenceDurations[i] : seqs[i][totalKey];
        if (seqDuration === 0) {
            throw Error("Sequence " + seqs[i].id + " has no " + totalKey + ", and no individual duration was provided.");
        }
        if (i === 0) {
            concatSeq = clone(seqs[0]);
        }
        else {
            Array.prototype.push.apply(concatSeq.notes, seqs[i].notes.map(function (n) {
                var newN = index_1.NoteSequence.Note.create(n);
                newN[startKey] += totalDuration;
                newN[endKey] += totalDuration;
                return newN;
            }));
        }
        totalDuration += seqDuration;
    }
    concatSeq[totalKey] = totalDuration;
    return concatSeq;
}
function trimHelper(ns, start, end, totalKey, startKey, endKey, truncateEndNotes) {
    var result = clone(ns);
    result[totalKey] = end;
    result.notes = result.notes.filter(function (n) { return n[startKey] >= start && n[startKey] <= end &&
        (truncateEndNotes || n[endKey] <= end); });
    for (var i = 0; i < result.notes.length; i++) {
        result.notes[i][startKey] -= start;
        result.notes[i][endKey] -= start;
        if (truncateEndNotes) {
            result.notes[i][endKey] = Math.min(result.notes[i][endKey], end);
        }
    }
    result[totalKey] = Math.min(ns[totalKey] - start, end);
    return result;
}
function split(seq, chunkSize) {
    assertIsQuantizedSequence(seq);
    var ns = clone(seq);
    var notesBystartStep = ns.notes.sort(function (a, b) { return a.quantizedStartStep - b.quantizedStartStep; });
    var chunks = [];
    var startStep = 0;
    var currentNotes = [];
    for (var i = 0; i < notesBystartStep.length; i++) {
        var note = notesBystartStep[i];
        var originalStartStep = note.quantizedStartStep;
        var originalEndStep = note.quantizedEndStep;
        note.quantizedStartStep -= startStep;
        note.quantizedEndStep -= startStep;
        if (note.quantizedStartStep < 0) {
            continue;
        }
        if (note.quantizedEndStep <= chunkSize) {
            currentNotes.push(note);
        }
        else {
            if (note.quantizedStartStep < chunkSize) {
                var newNote = index_1.NoteSequence.Note.create(note);
                newNote.quantizedEndStep = chunkSize;
                newNote.startTime = newNote.endTime = undefined;
                currentNotes.push(newNote);
                note.quantizedStartStep = startStep + chunkSize;
                note.quantizedEndStep = originalEndStep;
            }
            else {
                note.quantizedStartStep = originalStartStep;
                note.quantizedEndStep = originalEndStep;
            }
            if (note.quantizedEndStep > chunkSize ||
                note.quantizedStartStep > chunkSize) {
                i = i - 1;
            }
            if (currentNotes.length !== 0) {
                var newSequence = clone(ns);
                newSequence.notes = currentNotes;
                newSequence.totalQuantizedSteps = chunkSize;
                chunks.push(newSequence);
            }
            currentNotes = [];
            startStep += chunkSize;
        }
    }
    if (currentNotes.length !== 0) {
        var newSequence = clone(ns);
        newSequence.notes = currentNotes;
        newSequence.totalQuantizedSteps = chunkSize;
        chunks.push(newSequence);
    }
    return chunks;
}
exports.split = split;
//# sourceMappingURL=sequences.js.map