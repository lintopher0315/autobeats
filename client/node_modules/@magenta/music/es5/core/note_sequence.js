"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require(".");
var QUANTIZE_CUTOFF = 0.5;
function stepsPerQuarterToStepsPerSecond(stepsPerQuarter, qpm) {
    return stepsPerQuarter * qpm / 60.0;
}
exports.stepsPerQuarterToStepsPerSecond = stepsPerQuarterToStepsPerSecond;
function quantizeToStep(unquantizedSeconds, stepsPerSecond, quantizeCutoff) {
    if (quantizeCutoff === void 0) { quantizeCutoff = QUANTIZE_CUTOFF; }
    var unquantizedSteps = unquantizedSeconds * stepsPerSecond;
    return Math.floor(unquantizedSteps + (1 - quantizeCutoff));
}
exports.quantizeToStep = quantizeToStep;
var MultipleTimeSignatureException = (function (_super) {
    __extends(MultipleTimeSignatureException, _super);
    function MultipleTimeSignatureException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return MultipleTimeSignatureException;
}(Error));
exports.MultipleTimeSignatureException = MultipleTimeSignatureException;
var BadTimeSignatureException = (function (_super) {
    __extends(BadTimeSignatureException, _super);
    function BadTimeSignatureException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return BadTimeSignatureException;
}(Error));
exports.BadTimeSignatureException = BadTimeSignatureException;
var NegativeTimeException = (function (_super) {
    __extends(NegativeTimeException, _super);
    function NegativeTimeException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return NegativeTimeException;
}(Error));
exports.NegativeTimeException = NegativeTimeException;
var MultipleTempoException = (function (_super) {
    __extends(MultipleTempoException, _super);
    function MultipleTempoException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return MultipleTempoException;
}(Error));
exports.MultipleTempoException = MultipleTempoException;
var QuantizationStatusException = (function (_super) {
    __extends(QuantizationStatusException, _super);
    function QuantizationStatusException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return QuantizationStatusException;
}(Error));
exports.QuantizationStatusException = QuantizationStatusException;
var SimpleNote = (function () {
    function SimpleNote(note) {
        if (note) {
            this.pitch = note.pitch;
            this.pitchName = note.pitchName;
            this.velocity = note.velocity;
            this.instrument = note.instrument;
            this.program = note.program;
            this.isDrum = note.isDrum;
            this.startTime = note.startTime;
            this.endTime = note.endTime;
            this.quantizedStartStep = note.quantizedStartStep;
            this.quantizedEndStep = note.quantizedEndStep;
            this.pitchName = note.pitchName;
        }
    }
    return SimpleNote;
}());
exports.SimpleNote = SimpleNote;
var SimpleNoteSequence = (function () {
    function SimpleNoteSequence(seq) {
        if (seq) {
            this.id = seq.id;
            this.notes = JSON.parse(JSON.stringify(seq.notes));
            this.totalTime = seq.totalTime;
            this.totalQuantizedSteps = seq.totalQuantizedSteps;
            this.ticksPerQuarter = seq.ticksPerQuarter;
            this.timeSignatures = JSON.parse(JSON.stringify(seq.timeSignatures));
            this.keySignatures = JSON.parse(JSON.stringify(seq.keySignatures));
            this.tempos = JSON.parse(JSON.stringify(seq.tempos));
            this.pitchBends = JSON.parse(JSON.stringify(seq.pitchBends));
            this.controlChanges = JSON.parse(JSON.stringify(seq.controlChanges));
        }
    }
    SimpleNoteSequence.prototype.addNote = function (note) {
        this.notes.push(note);
        if (this.isQuantizedSequence()) {
            if (this.totalQuantizedSteps < note.quantizedEndStep) {
                this.totalQuantizedSteps = note.quantizedEndStep;
            }
        }
        else {
            if (this.totalTime < note.endTime) {
                this.totalTime = note.endTime;
            }
        }
    };
    SimpleNoteSequence.prototype.isAbsoluteQuantizedSequence = function () {
        return this.quantizationInfo && this.quantizationInfo.stepsPerSecond > 0;
    };
    SimpleNoteSequence.prototype.assertIsAbsoluteQuantizedSequence = function () {
        if (!this.isAbsoluteQuantizedSequence()) {
            throw new QuantizationStatusException("NoteSequence " + this.id + " is not quantized or is quantized based on relative timing");
        }
    };
    SimpleNoteSequence.prototype.isQuantizedSequence = function () {
        return this.quantizationInfo &&
            (this.quantizationInfo.stepsPerQuarter > 0 ||
                this.quantizationInfo.stepsPerSecond > 0);
    };
    SimpleNoteSequence.prototype.assertIsQuantizedSequence = function () {
        if (!this.isQuantizedSequence()) {
            throw new QuantizationStatusException("NoteSequence " + this.id + " is not quantized (missing quantizationInfo)");
        }
    };
    SimpleNoteSequence.prototype.isRelativeQuantizedSequence = function () {
        return this.quantizationInfo && this.quantizationInfo.stepsPerQuarter > 0;
    };
    SimpleNoteSequence.prototype.assertIsRelativeQuantizedSequence = function () {
        if (!this.isRelativeQuantizedSequence()) {
            throw new QuantizationStatusException("NoteSequence " + this.id + " is not quantized or is quantized based on absolute timing");
        }
    };
    SimpleNoteSequence.prototype.assertSingleTempo = function () {
        if (!this.tempos || this.tempos.length === 0) {
            return;
        }
        this.tempos.sort(function (a, b) { return a.time - b.time; });
        if (this.tempos[0].time !== 0 &&
            this.tempos[0].qpm !== _1.constants.DEFAULT_QUARTERS_PER_MINUTE) {
            throw new MultipleTempoException('NoteSequence has an implicit tempo change from initial ' +
                (_1.constants.DEFAULT_QUARTERS_PER_MINUTE + " qpm to ") +
                (this.tempos[0].qpm + " qpm at " + this.tempos[0].time + " seconds."));
        }
        for (var i = 1; i < this.tempos.length; i++) {
            if (this.tempos[i].qpm !== this.tempos[0].qpm) {
                throw new MultipleTempoException('NoteSequence has at least one tempo change from ' +
                    (this.tempos[0].qpm + " qpm to " + this.tempos[i].qpm) +
                    ("qpm at " + this.tempos[i].time + " seconds."));
            }
        }
    };
    SimpleNoteSequence.prototype.isPowerOf2 = function (n) {
        return n && (n & (n - 1)) === 0;
    };
    SimpleNoteSequence.prototype.quantize = function (stepsPerQuarter) {
        var qns = new SimpleNoteSequence(this);
        qns.quantizationInfo.stepsPerQuarter = stepsPerQuarter;
        if (qns.timeSignatures.length > 0) {
            qns.timeSignatures.sort(function (a, b) { return a.time - b.time; });
            if (qns.timeSignatures[0].time !== 0 &&
                !(qns.timeSignatures[0].numerator === 4 &&
                    qns.timeSignatures[0].denominator === 4)) {
                throw new MultipleTimeSignatureException('NoteSequence has an implicit change from initial 4/4 time ' +
                    ("signature to " + qns.timeSignatures[0].numerator + "/") +
                    (qns.timeSignatures[0].denominator + " at ") +
                    (qns.timeSignatures[0].time + " seconds."));
            }
            for (var i = 1; i < qns.timeSignatures.length; i++) {
                var timeSignature = qns.timeSignatures[i];
                if (timeSignature.numerator !== qns.timeSignatures[0].numerator ||
                    timeSignature.denominator !== qns.timeSignatures[0].denominator) {
                    throw new MultipleTimeSignatureException('NoteSequence has at least one time signature change from ' +
                        (qns.timeSignatures[0].numerator + "/") +
                        (qns.timeSignatures[0].denominator + " to ") +
                        (timeSignature.numerator + "/" + timeSignature.denominator + " ") +
                        ("at " + timeSignature.time + " seconds"));
                }
            }
            qns.timeSignatures[0].time = 0;
            qns.timeSignatures = [qns.timeSignatures[0]];
        }
        else {
            qns.timeSignatures.push({ numerator: 4, denominator: 4, time: 0 });
        }
        var firstTS = qns.timeSignatures[0];
        if (!this.isPowerOf2(firstTS.denominator)) {
            throw new BadTimeSignatureException('Denominator is not a power of 2. Time signature: ' +
                (firstTS.numerator + "/" + firstTS.denominator));
        }
        if (firstTS.numerator === 0) {
            throw new BadTimeSignatureException('Numerator is 0. Time signature: ' +
                (firstTS.numerator + "/" + firstTS.denominator));
        }
        if (qns.tempos.length > 0) {
            qns.assertSingleTempo();
            qns.tempos[0].time = 0;
            qns.tempos = [qns.tempos[0]];
        }
        else {
            qns.tempos.push({ qpm: _1.constants.DEFAULT_QUARTERS_PER_MINUTE, time: 0 });
        }
        var stepsPerSecond = stepsPerQuarterToStepsPerSecond(stepsPerQuarter, qns.tempos[0].qpm);
        qns.totalQuantizedSteps = quantizeToStep(this.totalTime, stepsPerSecond);
        this.quantizeNotesAndEvents(stepsPerSecond);
        return qns;
    };
    SimpleNoteSequence.prototype.unquantize = function (qpm) {
        this.assertIsRelativeQuantizedSequence();
        this.assertSingleTempo();
        var ns = new SimpleNoteSequence(this);
        if (qpm) {
            if (ns.tempos && ns.tempos.length > 0) {
                ns.tempos[0].qpm = qpm;
            }
            else {
                ns.tempos.push({ time: 0, qpm: qpm });
            }
        }
        else {
            qpm = (this.tempos && this.tempos.length > 0) ?
                ns.tempos[0].qpm :
                _1.constants.DEFAULT_QUARTERS_PER_MINUTE;
        }
        var stepToSeconds = function (step) {
            return step / ns.quantizationInfo.stepsPerQuarter * (60 / qpm);
        };
        ns.totalTime = stepToSeconds(ns.totalQuantizedSteps);
        ns.notes.forEach(function (n) {
            n.startTime = stepToSeconds(n.quantizedStartStep);
            n.endTime = stepToSeconds(n.quantizedEndStep);
            ns.totalTime = Math.max(ns.totalTime, n.endTime);
        });
        this.getQuantizedTimeEvents().forEach(function (event) {
            event.time = stepToSeconds(event.time);
        });
        return ns;
    };
    SimpleNoteSequence.prototype.getQuantizedTimeEvents = function () {
        return this.controlChanges;
    };
    SimpleNoteSequence.prototype.quantizeNotesAndEvents = function (stepsPerSecond) {
        for (var _i = 0, _a = this.notes; _i < _a.length; _i++) {
            var note = _a[_i];
            note.quantizedStartStep = quantizeToStep(note.startTime, stepsPerSecond);
            note.quantizedEndStep = quantizeToStep(note.endTime, stepsPerSecond);
            if (note.quantizedEndStep === note.quantizedStartStep) {
                note.quantizedEndStep += 1;
            }
            if (note.quantizedStartStep < 0 || note.quantizedEndStep < 0) {
                throw new NegativeTimeException("Got negative note time: start_step = " +
                    (note.quantizedStartStep + ", end_step = ") +
                    ("" + note.quantizedEndStep));
            }
            if (note.quantizedEndStep > this.totalQuantizedSteps) {
                this.totalQuantizedSteps = note.quantizedEndStep;
            }
        }
        this.getQuantizedTimeEvents().forEach(function (event) {
            event.quantizedStep = quantizeToStep(event.time, stepsPerSecond);
            if (event.quantizedStep < 0) {
                throw new NegativeTimeException("Got negative event time: step = " + event.quantizedStep);
            }
        });
    };
    return SimpleNoteSequence;
}());
exports.SimpleNoteSequence = SimpleNoteSequence;
//# sourceMappingURL=note_sequence.js.map