"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require(".");
var constants_1 = require("./constants");
var BaseVisualizer = (function () {
    function BaseVisualizer(sequence, config) {
        if (config === void 0) { config = {}; }
        this.noteSequence = sequence;
        this.sequenceIsQuantized = _1.sequences.isQuantizedSequence(this.noteSequence);
        var defaultPixelsPerTimeStep = 30;
        if (this.sequenceIsQuantized) {
            var spq = sequence.quantizationInfo.stepsPerQuarter;
            defaultPixelsPerTimeStep = spq ? defaultPixelsPerTimeStep / spq : 7;
        }
        this.config = {
            noteHeight: config.noteHeight || 6,
            noteSpacing: config.noteSpacing || 1,
            pixelsPerTimeStep: config.pixelsPerTimeStep || defaultPixelsPerTimeStep,
            noteRGB: config.noteRGB || '8, 41, 64',
            activeNoteRGB: config.activeNoteRGB || '240, 84, 119',
            minPitch: config.minPitch,
            maxPitch: config.maxPitch,
        };
        var size = this.getSize();
        this.width = size.width;
        this.height = size.height;
    }
    BaseVisualizer.prototype.getSize = function () {
        if (this.config.minPitch === undefined ||
            this.config.maxPitch === undefined) {
            this.config.minPitch = constants_1.MAX_MIDI_PITCH;
            this.config.maxPitch = constants_1.MIN_MIDI_PITCH;
            for (var _i = 0, _a = this.noteSequence.notes; _i < _a.length; _i++) {
                var note = _a[_i];
                this.config.minPitch = Math.min(note.pitch, this.config.minPitch);
                this.config.maxPitch = Math.max(note.pitch, this.config.maxPitch);
            }
            this.config.minPitch -= 2;
            this.config.maxPitch += 2;
        }
        var height = (this.config.maxPitch - this.config.minPitch) * this.config.noteHeight;
        var numNotes = this.noteSequence.notes.length;
        var endTime = this.sequenceIsQuantized ?
            this.noteSequence.totalQuantizedSteps :
            this.noteSequence.totalTime;
        var width = (numNotes * this.config.noteSpacing) +
            (endTime * this.config.pixelsPerTimeStep);
        return { width: width, height: height };
    };
    BaseVisualizer.prototype.getNotePosition = function (note, noteIndex) {
        var x = (this.getNoteStartTime(note) * this.config.pixelsPerTimeStep);
        var w = this.config.pixelsPerTimeStep *
            (this.getNoteEndTime(note) - this.getNoteStartTime(note)) -
            this.config.noteSpacing;
        var y = this.height -
            ((note.pitch - this.config.minPitch) * this.config.noteHeight);
        return { x: x, y: y, w: w, h: this.config.noteHeight };
    };
    BaseVisualizer.prototype.scrollIntoViewIfNeeded = function (scrollIntoView, activeNotePosition) {
        if (scrollIntoView && this.parentElement) {
            var containerWidth = this.parentElement.getBoundingClientRect().width;
            if (activeNotePosition >
                (this.parentElement.scrollLeft + containerWidth)) {
                this.parentElement.scrollLeft = activeNotePosition - 20;
            }
        }
    };
    BaseVisualizer.prototype.getNoteStartTime = function (note) {
        return this.sequenceIsQuantized ? note.quantizedStartStep : note.startTime;
    };
    BaseVisualizer.prototype.getNoteEndTime = function (note) {
        return this.sequenceIsQuantized ? note.quantizedEndStep : note.endTime;
    };
    BaseVisualizer.prototype.isPaintingActiveNote = function (note, playedNote) {
        var isPlayedNote = this.getNoteStartTime(note) === this.getNoteStartTime(playedNote);
        var heldDownDuringPlayedNote = this.getNoteStartTime(note) <= this.getNoteStartTime(playedNote) &&
            this.getNoteEndTime(note) >= this.getNoteEndTime(playedNote);
        return isPlayedNote || heldDownDuringPlayedNote;
    };
    return BaseVisualizer;
}());
exports.BaseVisualizer = BaseVisualizer;
var PianoRollCanvasVisualizer = (function (_super) {
    __extends(PianoRollCanvasVisualizer, _super);
    function PianoRollCanvasVisualizer(sequence, canvas, config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, sequence, config) || this;
        _this.ctx = canvas.getContext('2d');
        _this.parentElement = canvas.parentElement;
        var dpr = window.devicePixelRatio || 1;
        if (_this.ctx) {
            _this.ctx.canvas.width = dpr * _this.width;
            _this.ctx.canvas.height = dpr * _this.height;
            canvas.style.width = _this.width + "px";
            canvas.style.height = _this.height + "px";
            _this.ctx.scale(dpr, dpr);
        }
        _this.redraw();
        return _this;
    }
    PianoRollCanvasVisualizer.prototype.redraw = function (activeNote, scrollIntoView) {
        this.clear();
        var activeNotePosition;
        for (var i = 0; i < this.noteSequence.notes.length; i++) {
            var note = this.noteSequence.notes[i];
            var size = this.getNotePosition(note, i);
            var opacityBaseline = 0.2;
            var opacity = note.velocity ? note.velocity / 100 + opacityBaseline : 1;
            var isActive = activeNote && this.isPaintingActiveNote(note, activeNote);
            var fill = "rgba(" + (isActive ? this.config.activeNoteRGB : this.config.noteRGB) + ",\n  " + opacity + ")";
            this.redrawNote(size.x, size.y, size.w, size.h, fill);
            if (isActive) {
                activeNotePosition = size.x;
            }
        }
        this.scrollIntoViewIfNeeded(scrollIntoView, activeNotePosition);
        return activeNotePosition;
    };
    PianoRollCanvasVisualizer.prototype.clear = function () {
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    };
    PianoRollCanvasVisualizer.prototype.redrawNote = function (x, y, w, h, fill) {
        this.ctx.fillStyle = fill;
        this.ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
    };
    return PianoRollCanvasVisualizer;
}(BaseVisualizer));
exports.PianoRollCanvasVisualizer = PianoRollCanvasVisualizer;
var Visualizer = (function (_super) {
    __extends(Visualizer, _super);
    function Visualizer(sequence, canvas, config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, sequence, canvas, config) || this;
        _1.logging.log('mm.Visualizer is deprecated, and will be removed in a future \
         version. Please use mm.PianoRollCanvasVisualizer instead', 'mm.Visualizer', 5);
        return _this;
    }
    return Visualizer;
}(PianoRollCanvasVisualizer));
exports.Visualizer = Visualizer;
var PianoRollSVGVisualizer = (function (_super) {
    __extends(PianoRollSVGVisualizer, _super);
    function PianoRollSVGVisualizer(sequence, svg, config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, sequence, config) || this;
        _this.svg = svg;
        _this.parentElement = svg.parentElement;
        _this.drawn = false;
        _this.svg.style.width = _this.width + "px";
        _this.svg.style.height = _this.height + "px";
        _this.clear();
        _this.draw();
        return _this;
    }
    PianoRollSVGVisualizer.prototype.redraw = function (activeNote, scrollIntoView) {
        if (!this.drawn) {
            this.draw();
        }
        if (!activeNote) {
            return null;
        }
        var el = this.svg.querySelector('rect.active');
        if (el) {
            var fill = this.getNoteFillColor(this.noteSequence.notes[parseInt(el.getAttribute('data-index'), 10)], false);
            el.setAttribute('fill', fill);
            el.removeAttribute('class');
        }
        var activeNotePosition;
        for (var i = 0; i < this.noteSequence.notes.length; i++) {
            var note = this.noteSequence.notes[i];
            var isActive = activeNote && this.isPaintingActiveNote(note, activeNote);
            if (!isActive) {
                continue;
            }
            var el_1 = this.svg.querySelector("rect[data-index=\"" + i + "\"]");
            var fill = this.getNoteFillColor(note, true);
            el_1.setAttribute('fill', fill);
            el_1.setAttribute('class', 'active');
            activeNotePosition = parseFloat(el_1.getAttribute('x'));
        }
        this.scrollIntoViewIfNeeded(scrollIntoView, activeNotePosition);
        return activeNotePosition;
    };
    PianoRollSVGVisualizer.prototype.draw = function () {
        for (var i = 0; i < this.noteSequence.notes.length; i++) {
            var note = this.noteSequence.notes[i];
            var size = this.getNotePosition(note, i);
            var fill = this.getNoteFillColor(note, false);
            this.drawNote(size.x, size.y, size.w, size.h, fill, i);
        }
        this.drawn = true;
    };
    PianoRollSVGVisualizer.prototype.getNoteFillColor = function (note, isActive) {
        var opacityBaseline = 0.2;
        var opacity = note.velocity ? note.velocity / 100 + opacityBaseline : 1;
        var fill = "rgba(" + (isActive ? this.config.activeNoteRGB : this.config.noteRGB) + ",\n  " + opacity + ")";
        return fill;
    };
    PianoRollSVGVisualizer.prototype.drawNote = function (x, y, w, h, fill, index) {
        if (!this.svg) {
            return;
        }
        var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('fill', fill);
        rect.setAttribute('x', "" + Math.round(x));
        rect.setAttribute('y', "" + Math.round(y));
        rect.setAttribute('width', "" + Math.round(w));
        rect.setAttribute('height', "" + Math.round(h));
        rect.setAttribute('data-index', "" + index);
        this.svg.appendChild(rect);
    };
    PianoRollSVGVisualizer.prototype.clear = function () {
        this.svg.innerHTML = '';
        this.drawn = false;
    };
    return PianoRollSVGVisualizer;
}(BaseVisualizer));
exports.PianoRollSVGVisualizer = PianoRollSVGVisualizer;
//# sourceMappingURL=visualizer.js.map