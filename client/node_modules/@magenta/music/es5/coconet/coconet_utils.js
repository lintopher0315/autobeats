"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tf = require("@tensorflow/tfjs-core");
var __1 = require("..");
var protobuf_1 = require("../protobuf");
exports.IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
exports.NUM_PITCHES = 46;
exports.MIN_PITCH = 36;
exports.NUM_VOICES = 4;
function pianorollToSequence(pianoroll, numberOfSteps) {
    var reshaped = tf.tidy(function () { return pianoroll.reshape([numberOfSteps, exports.NUM_PITCHES, exports.NUM_VOICES])
        .arraySync(); });
    var sequence = protobuf_1.NoteSequence.create();
    var notes = [];
    for (var s = 0; s < numberOfSteps; s++) {
        for (var p = 0; p < exports.NUM_PITCHES; p++) {
            for (var v = 0; v < exports.NUM_VOICES; v++) {
                var value = reshaped[s][p][v];
                if (value === 1.0) {
                    var note = protobuf_1.NoteSequence.Note.create({
                        pitch: p + exports.MIN_PITCH,
                        instrument: v,
                        quantizedStartStep: s,
                        quantizedEndStep: s + 1
                    });
                    notes.push(note);
                }
            }
        }
    }
    sequence.notes = notes;
    sequence.totalQuantizedSteps = notes[notes.length - 1].quantizedEndStep;
    sequence.quantizationInfo = { stepsPerQuarter: 4 };
    return sequence;
}
exports.pianorollToSequence = pianorollToSequence;
function sequenceToPianoroll(ns, numberOfSteps) {
    var pianoroll = tf.tidy(function () { return tf.zeros([numberOfSteps, exports.NUM_PITCHES, exports.NUM_VOICES]).arraySync(); });
    var notes = ns.notes;
    notes.forEach(function (note) {
        var pitchIndex = note.pitch - exports.MIN_PITCH;
        var stepIndex = note.quantizedStartStep;
        var duration = note.quantizedEndStep - note.quantizedStartStep;
        var voice = note.instrument;
        if (voice < 0 || voice >= exports.NUM_VOICES) {
            __1.logging.log("Found invalid voice " + voice + ". Skipping.", 'Coconet', 5);
        }
        else {
            if (stepIndex + duration > numberOfSteps) {
                throw new Error("NoteSequence " + ns.id + " has notes that are longer than the sequence's\n          totalQuantizedSteps.");
            }
            for (var i = stepIndex; i < stepIndex + duration; i++) {
                pianoroll[i][pitchIndex][voice] = 1;
            }
        }
    });
    return tf.tensor([pianoroll]);
}
exports.sequenceToPianoroll = sequenceToPianoroll;
//# sourceMappingURL=coconet_utils.js.map