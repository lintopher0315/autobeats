"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tf = require("@tensorflow/tfjs");
var PixelNorm = (function (_super) {
    __extends(PixelNorm, _super);
    function PixelNorm(epsilon, layerConfig) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (layerConfig === void 0) { layerConfig = {}; }
        var _this = _super.call(this, layerConfig) || this;
        _this.epsilon = epsilon;
        _this.layerConfig = layerConfig;
        _this.supportsMasking = true;
        return _this;
    }
    PixelNorm.prototype.computeOutputShape = function (inputShape) {
        return [inputShape[0], inputShape[1], inputShape[2], inputShape[3]];
    };
    PixelNorm.prototype.call = function (inputs) {
        var _this = this;
        return tf.tidy(function () {
            var input = inputs;
            if (Array.isArray(input)) {
                input = input[0];
            }
            var mean = tf.mean(tf.square(input), [3], true);
            return tf.mul(input, tf.rsqrt(tf.add(mean, _this.epsilon)));
        });
    };
    PixelNorm.prototype.getClassName = function () {
        return 'PixelNorm';
    };
    return PixelNorm;
}(tf.layers.Layer));
function pixelNorm(epsilon, layerConfig) {
    if (epsilon === void 0) { epsilon = 1e-8; }
    if (layerConfig === void 0) { layerConfig = {}; }
    return new PixelNorm(epsilon, layerConfig);
}
exports.pixelNorm = pixelNorm;
var InitialPad = (function (_super) {
    __extends(InitialPad, _super);
    function InitialPad(kernelH, kernelW, layerConfig) {
        if (kernelH === void 0) { kernelH = 2; }
        if (kernelW === void 0) { kernelW = 16; }
        if (layerConfig === void 0) { layerConfig = {}; }
        var _this = _super.call(this, layerConfig) || this;
        _this.kernelH = kernelH;
        _this.kernelW = kernelW;
        _this.layerConfig = layerConfig;
        _this.supportsMasking = true;
        return _this;
    }
    InitialPad.prototype.computeOutputShape = function (inputShape) {
        return [
            inputShape[0], 2 * (this.kernelH - 1) + inputShape[1],
            2 * (this.kernelW - 1) + inputShape[2], inputShape[3]
        ];
    };
    InitialPad.prototype.call = function (inputs) {
        var input = inputs;
        if (Array.isArray(input)) {
            input = input[0];
        }
        var padH = this.kernelH - 1;
        var padW = this.kernelW - 1;
        return tf.pad(input, [[0, 0], [padH, padH], [padW, padW], [0, 0]]);
    };
    InitialPad.prototype.getClassName = function () {
        return 'InitialPad';
    };
    return InitialPad;
}(tf.layers.Layer));
function initialPad(kernelH, kernelW, layerConfig) {
    if (kernelH === void 0) { kernelH = 2; }
    if (kernelW === void 0) { kernelW = 16; }
    if (layerConfig === void 0) { layerConfig = {}; }
    return new InitialPad(kernelH, kernelW, layerConfig);
}
exports.initialPad = initialPad;
var BoxUpscale = (function (_super) {
    __extends(BoxUpscale, _super);
    function BoxUpscale(scale) {
        if (scale === void 0) { scale = 2; }
        var _this = _super.call(this, {}) || this;
        _this.scale = scale;
        _this.supportsMasking = true;
        return _this;
    }
    BoxUpscale.prototype.computeOutputShape = function (inputShape) {
        return [
            inputShape[0], this.scale * inputShape[1], this.scale * inputShape[2],
            inputShape[3]
        ];
    };
    BoxUpscale.prototype.call = function (inputs) {
        var _this = this;
        return tf.tidy(function () {
            var input = inputs;
            if (Array.isArray(input)) {
                input = input[0];
            }
            var tiledInput = tf.tile(input, [Math.pow(_this.scale, 2), 1, 1, 1]);
            return tf.batchToSpaceND(tiledInput, [_this.scale, _this.scale], [[0, 0], [0, 0]]);
        });
    };
    BoxUpscale.prototype.getClassName = function () {
        return 'BoxUpscale';
    };
    return BoxUpscale;
}(tf.layers.Layer));
function boxUpscale(scale) {
    if (scale === void 0) { scale = 2; }
    return new BoxUpscale(scale);
}
exports.boxUpscale = boxUpscale;
//# sourceMappingURL=custom_layers.js.map