import { serialization, Tensor } from '@tensorflow/tfjs-core';
import { Layer, LayerArgs, SymbolicTensor } from '../engine/topology';
import { Shape } from '../keras_format/common';
import { Kwargs } from '../types';
export declare abstract class Merge extends Layer {
    protected reshapeRequired: boolean;
    constructor(args?: LayerArgs);
    protected mergeFunction(inputs: Tensor[]): Tensor;
    private computeElementwiseOpOutputShape(shape1, shape2);
    build(inputShape: Shape | Shape[]): void;
    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];
    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];
    computeMask(inputs: Tensor | Tensor[], mask?: Tensor | Tensor[]): Tensor;
}
export declare class Add extends Merge {
    static className: string;
    constructor(args?: LayerArgs);
    protected mergeFunction(inputs: Tensor[]): Tensor;
}
export declare function add(config?: SymbolicTensor[] | Tensor[] | LayerArgs): Layer | SymbolicTensor | Tensor;
export declare class Multiply extends Merge {
    static className: string;
    constructor(args?: LayerArgs);
    protected mergeFunction(inputs: Tensor[]): Tensor;
}
export declare function multiply(config?: SymbolicTensor[] | Tensor[] | LayerArgs): Layer | SymbolicTensor | Tensor;
export declare class Average extends Merge {
    static className: string;
    constructor(args?: LayerArgs);
    protected mergeFunction(inputs: Tensor[]): Tensor;
}
export declare function average(config?: SymbolicTensor[] | Tensor[] | LayerArgs): Layer | SymbolicTensor | Tensor;
export declare class Maximum extends Merge {
    static className: string;
    constructor(args?: LayerArgs);
    protected mergeFunction(inputs: Tensor[]): Tensor;
}
export declare function maximum(config?: SymbolicTensor[] | Tensor[] | LayerArgs): Layer | SymbolicTensor | Tensor;
export declare class Minimum extends Merge {
    static className: string;
    constructor(args?: LayerArgs);
    protected mergeFunction(inputs: Tensor[]): Tensor;
}
export declare function minimum(config?: SymbolicTensor[] | Tensor[] | LayerArgs): Layer | SymbolicTensor | Tensor;
export interface ConcatenateLayerArgs extends LayerArgs {
    axis?: number;
}
export declare class Concatenate extends Merge {
    static className: string;
    readonly DEFAULT_AXIS: number;
    private readonly axis;
    constructor(args?: ConcatenateLayerArgs);
    build(inputShape: Shape | Shape[]): void;
    protected mergeFunction(inputs: Tensor[]): Tensor;
    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];
    computeMask(inputs: Tensor | Tensor[], mask?: Tensor | Tensor[]): Tensor;
    getConfig(): serialization.ConfigDict;
}
export declare function concatenate(config?: SymbolicTensor[] | Tensor[] | ConcatenateLayerArgs): Layer | SymbolicTensor | Tensor;
export interface DotLayerArgs extends LayerArgs {
    axes: number | [number, number];
    normalize?: boolean;
}
export declare class Dot extends Merge {
    static className: string;
    private axes;
    private normalize;
    constructor(args: DotLayerArgs);
    build(inputShape: Shape | Shape[]): void;
    protected mergeFunction(inputs: Tensor[]): Tensor;
    private interpretAxes(shape1, shape2);
    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];
    computeMask(inputs: Tensor | Tensor[], mask?: Tensor | Tensor[]): Tensor;
    getConfig(): serialization.ConfigDict;
}
